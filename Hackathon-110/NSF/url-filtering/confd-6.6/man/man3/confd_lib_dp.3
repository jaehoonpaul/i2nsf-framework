'\" t
.\"     Title: confd_lib_dp
.\"    Author:  <support@tail-f.com>
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 03/02/2018
.\"    Manual: ConfD Manual
.\"    Source: Tail-f Systems
.\"  Language: English
.\"
.TH "CONFD_LIB_DP" "3" "03/02/2018" "Tail-f Systems" "ConfD Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
confd_lib_dp \- callback library for connecting data providers to ConfD
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <confd_lib\&.h>
#include <confd_dp\&.h>
      
.fi
.ft
.nr wf \w'struct\ confd_daemon_ctx\ *confd_init_daemon('
.nr wm 0
.nr wp \w'const\ char\ *name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "struct confd_daemon_ctx *confd_init_daemon("
.br
.BI "const\ char\ *" "name" ");" \}
.el \{\
.HP \n(wfu
.BI "struct confd_daemon_ctx *confd_init_daemon(const\ char\ *" "name" ");" \}
.nr wf \w'int\ confd_set_daemon_flags('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_set_daemon_flags("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_set_daemon_flags(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "flags" ");" \}
.nr wf \w'void\ confd_release_daemon('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_release_daemon("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_release_daemon(struct\ confd_daemon_ctx\ *" "dx" ");" \}
.nr wf \w'int\ confd_connect('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_sock_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr\ *srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ addrsz);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_connect("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "sock" ", enum\ confd_sock_type\ " "type" ", const\ struct\ sockaddr\ *" "srv" ", int\ " "addrsz" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_connect(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "sock" ", enum\ confd_sock_type\ " "type" ", const\ struct\ sockaddr\ *" "srv" ", int\ " "addrsz" ");" \}
.nr wf \w'int\ confd_register_trans_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_trans_cbs\ *trans);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_trans_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_cbs\ *" "trans" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_trans_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_cbs\ *" "trans" ");" \}
.nr wf \w'int\ confd_register_db_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_db_cbs\ *dbcbs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_db_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_db_cbs\ *" "dbcbs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_db_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_db_cbs\ *" "dbcbs" ");" \}
.nr wf \w'int\ confd_register_range_data_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_data_cbs\ *data,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *lower,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *upper,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_range_data_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_range_data_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_register_data_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_data_cbs\ *data);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_data_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_data_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ");" \}
.nr wf \w'int\ confd_register_usess_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_usess_cbs\ *ucb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_usess_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_usess_cbs\ *" "ucb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_usess_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_usess_cbs\ *" "ucb" ");" \}
.nr wf \w'int\ ncs_register_service_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_service_cbs\ *scb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int ncs_register_service_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ ncs_service_cbs\ *" "scb" ");" \}
.el \{\
.HP \n(wfu
.BI "int ncs_register_service_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ ncs_service_cbs\ *" "scb" ");" \}
.nr wf \w'int\ ncs_register_nano_service_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *component_type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *state,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_nano_service_cbs\ *scb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int ncs_register_nano_service_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ char\ *" "component_type" ", const\ char\ *" "state" ", const\ struct\ ncs_nano_service_cbs\ *" "scb" ");" \}
.el \{\
.HP \n(wfu
.BI "int ncs_register_nano_service_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ char\ *" "component_type" ", const\ char\ *" "state" ", const\ struct\ ncs_nano_service_cbs\ *" "scb" ");" \}
.nr wf \w'int\ confd_register_done('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_done("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_done(struct\ confd_daemon_ctx\ *" "dx" ");" \}
.nr wf \w'int\ confd_fd_ready('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ fd);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_fd_ready("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_fd_ready(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ");" \}
.nr wf \w'void\ confd_trans_set_fd('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_trans_set_fd("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_trans_set_fd(struct\ confd_trans_ctx\ *" "tctx" ", int\ " "sock" ");" \}
.nr wf \w'int\ confd_data_reply_value('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *v);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_value("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_value(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ");" \}
.nr wf \w'int\ confd_data_reply_value_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *vs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_value_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "vs" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_value_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "vs" ", int\ " "n" ");" \}
.nr wf \w'int\ confd_data_reply_tag_value_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *tvs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_tag_value_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tvs" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_tag_value_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tvs" ", int\ " "n" ");" \}
.nr wf \w'int\ confd_data_reply_next_key('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_vals_in_key,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'long\ next);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_key("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "num_vals_in_key" ", long\ " "next" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_key(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "num_vals_in_key" ", long\ " "next" ");" \}
.nr wf \w'int\ confd_data_reply_not_found('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_not_found("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_not_found(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.nr wf \w'int\ confd_data_reply_found('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_found("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_found(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.nr wf \w'int\ confd_data_reply_next_object_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'long\ next);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "n" ", long\ " "next" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "n" ", long\ " "next" ");" \}
.nr wf \w'int\ confd_data_reply_next_object_tag_value_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *tv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'long\ next);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_tag_value_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tv" ", int\ " "n" ", long\ " "next" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_tag_value_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tv" ", int\ " "n" ", long\ " "next" ");" \}
.nr wf \w'int\ confd_data_reply_next_object_arrays('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_next_object\ *obj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_millisecs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_arrays("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_next_object\ *" "obj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_arrays(struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_next_object\ *" "obj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.nr wf \w'int\ confd_data_reply_next_object_tag_value_arrays('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_tag_next_object\ *tobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_millisecs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_tag_value_arrays("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_tag_next_object\ *" "tobj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_tag_value_arrays(struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_tag_next_object\ *" "tobj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.nr wf \w'int\ confd_data_reply_attrs('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_attr_value_t\ *attrs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attrs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_attrs("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_attr_value_t\ *" "attrs" ", int\ " "num_attrs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_attrs(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_attr_value_t\ *" "attrs" ", int\ " "num_attrs" ");" \}
.nr wf \w'int\ ncs_service_reply_proplist('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_name_value\ *proplist,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_props);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int ncs_service_reply_proplist("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ ncs_name_value\ *" "proplist" ", int\ " "num_props" ");" \}
.el \{\
.HP \n(wfu
.BI "int ncs_service_reply_proplist(struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ ncs_name_value\ *" "proplist" ", int\ " "num_props" ");" \}
.nr wf \w'int\ ncs_nano_service_reply_proplist('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_name_value\ *proplist,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_props);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int ncs_nano_service_reply_proplist("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ ncs_name_value\ *" "proplist" ", int\ " "num_props" ");" \}
.el \{\
.HP \n(wfu
.BI "int ncs_nano_service_reply_proplist(struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ ncs_name_value\ *" "proplist" ", int\ " "num_props" ");" \}
.nr wf \w'int\ confd_delayed_reply_ok('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_delayed_reply_ok("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_delayed_reply_ok(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.nr wf \w'int\ confd_delayed_reply_error('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *errstr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_delayed_reply_error("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "errstr" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_delayed_reply_error(struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "errstr" ");" \}
.nr wf \w'int\ confd_data_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_set_timeout("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_set_timeout(struct\ confd_trans_ctx\ *" "tctx" ", int\ " "timeout_secs" ");" \}
.nr wf \w'void\ confd_trans_seterr('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_trans_seterr("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_trans_seterr(struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'void\ confd_trans_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_trans_seterr_extended("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_trans_seterr_extended(struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_trans_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_trans_seterr_extended_info("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_trans_seterr_extended_info(struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'void\ confd_db_seterr('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_db_seterr("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_db_seterr(struct\ confd_db_ctx\ *" "dbx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'void\ confd_db_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_db_seterr_extended("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_db_seterr_extended(struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_db_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_db_seterr_extended_info("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_db_seterr_extended_info(struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_db_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_db_set_timeout("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_db_set_timeout(struct\ confd_db_ctx\ *" "dbx" ", int\ " "timeout_secs" ");" \}
.nr wf \w'int\ confd_aaa_reload('
.nr wm 0
.nr wp \w'const\ struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_aaa_reload("
.br
.BI "const\ struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_aaa_reload(const\ struct\ confd_trans_ctx\ *" "tctx" ");" \}
.nr wf \w'int\ confd_install_crypto_keys('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx*\ dtx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_install_crypto_keys("
.br
.BI "struct\ confd_daemon_ctx*\ " "dtx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_install_crypto_keys(struct\ confd_daemon_ctx*\ " "dtx" ");" \}
.nr wf \w'void\ confd_register_trans_validate_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_trans_validate_cbs\ *vcbs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_register_trans_validate_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_validate_cbs\ *" "vcbs" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_register_trans_validate_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_validate_cbs\ *" "vcbs" ");" \}
.nr wf \w'int\ confd_register_valpoint_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_valpoint_cb\ *vcb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_valpoint_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_valpoint_cb\ *" "vcb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_valpoint_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_valpoint_cb\ *" "vcb" ");" \}
.nr wf \w'int\ confd_register_range_valpoint_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_valpoint_cb\ *vcb,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *lower,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *upper,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_range_valpoint_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", struct\ confd_valpoint_cb\ *" "vcb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_range_valpoint_cb(struct\ confd_daemon_ctx\ *" "dx" ", struct\ confd_valpoint_cb\ *" "vcb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_delayed_reply_validation_warn('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_delayed_reply_validation_warn("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_delayed_reply_validation_warn(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.nr wf \w'int\ confd_register_action_cbs('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_action_cbs\ *acb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_action_cbs("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_action_cbs(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ");" \}
.nr wf \w'int\ confd_register_range_action_cbs('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_action_cbs\ *acb,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *lower,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *upper,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_range_action_cbs("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_range_action_cbs(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'void\ confd_action_set_fd('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_action_set_fd("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_action_set_fd(struct\ confd_user_info\ *" "uinfo" ", int\ " "sock" ");" \}
.nr wf \w'void\ confd_action_seterr('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_action_seterr("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_action_seterr(struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'void\ confd_action_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_action_seterr_extended("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_action_seterr_extended(struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_action_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_seterr_extended_info("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_seterr_extended_info(struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_action_reply_values('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_values("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_values(struct\ confd_user_info\ *" "uinfo" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.nr wf \w'int\ confd_action_reply_command('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_command("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_command(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ");" \}
.nr wf \w'int\ confd_action_reply_rewrite('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhides,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nunhides);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_rewrite("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_rewrite(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ");" \}
.nr wf \w'int\ confd_action_reply_rewrite2('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhides,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nunhides,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_rewrite_select\ **selects,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nselects);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_rewrite2("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ", struct\ confd_rewrite_select\ **" "selects" ", int\ " "nselects" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_rewrite2(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ", struct\ confd_rewrite_select\ **" "selects" ", int\ " "nselects" ");" \}
.nr wf \w'int\ confd_action_reply_completion('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_completion_value\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_completion("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", struct\ confd_completion_value\ *" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_completion(struct\ confd_user_info\ *" "uinfo" ", struct\ confd_completion_value\ *" "values" ", int\ " "nvalues" ");" \}
.nr wf \w'int\ confd_action_reply_range_enum('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ keysize,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nkeys);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_range_enum("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "keysize" ", int\ " "nkeys" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_range_enum(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "keysize" ", int\ " "nkeys" ");" \}
.nr wf \w'int\ confd_action_delayed_reply_ok('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_delayed_reply_ok("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_delayed_reply_ok(struct\ confd_user_info\ *" "uinfo" ");" \}
.nr wf \w'int\ confd_action_delayed_reply_error('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *errstr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_delayed_reply_error("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "errstr" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_delayed_reply_error(struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "errstr" ");" \}
.nr wf \w'int\ confd_action_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_set_timeout("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_set_timeout(struct\ confd_user_info\ *" "uinfo" ", int\ " "timeout_secs" ");" \}
.nr wf \w'int\ confd_register_notification_stream('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_notification_stream_cbs\ *ncbs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_notification_ctx\ **nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_notification_stream("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_stream_cbs\ *" "ncbs" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_notification_stream(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_stream_cbs\ *" "ncbs" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.nr wf \w'int\ confd_notification_send('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *time,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_send("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "time" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_send(struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "time" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.nr wf \w'int\ confd_notification_replay_complete('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_replay_complete("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_replay_complete(struct\ confd_notification_ctx\ *" "nctx" ");" \}
.nr wf \w'int\ confd_notification_replay_failed('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_replay_failed("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_replay_failed(struct\ confd_notification_ctx\ *" "nctx" ");" \}
.nr wf \w'int\ confd_notification_reply_log_times('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *creation,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *aged);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_reply_log_times("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "creation" ", struct\ confd_datetime\ *" "aged" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_reply_log_times(struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "creation" ", struct\ confd_datetime\ *" "aged" ");" \}
.nr wf \w'void\ confd_notification_set_fd('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ fd);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_set_fd("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", int\ " "fd" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_set_fd(struct\ confd_notification_ctx\ *" "nctx" ", int\ " "fd" ");" \}
.nr wf \w'void\ confd_notification_set_snmp_src_addr('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_set_snmp_src_addr("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ struct\ confd_ip\ *" "src_addr" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_set_snmp_src_addr(struct\ confd_notification_ctx\ *" "nctx" ", const\ struct\ confd_ip\ *" "src_addr" ");" \}
.nr wf \w'int\ confd_notification_set_snmp_notify_name('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notify_name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_set_snmp_notify_name("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notify_name" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_set_snmp_notify_name(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notify_name" ");" \}
.nr wf \w'void\ confd_notification_seterr('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_seterr("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_seterr(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'void\ confd_notification_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_seterr_extended("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_seterr_extended(struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_notification_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_seterr_extended_info("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_seterr_extended_info(struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_register_snmp_notification('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ fd,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notify_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *ctx_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_notification_ctx\ **nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_snmp_notification("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ", const\ char\ *" "notify_name" ", const\ char\ *" "ctx_name" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_snmp_notification(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ", const\ char\ *" "notify_name" ", const\ char\ *" "ctx_name" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.nr wf \w'int\ confd_notification_send_snmp('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notification,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_snmp_varbind\ *varbinds,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_vars);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_send_snmp("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_send_snmp(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ");" \}
.nr wf \w'int\ confd_register_notification_snmp_inform_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_notification_snmp_inform_cbs\ *cb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_notification_snmp_inform_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_snmp_inform_cbs\ *" "cb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_notification_snmp_inform_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_snmp_inform_cbs\ *" "cb" ");" \}
.nr wf \w'int\ confd_notification_send_snmp_inform('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notification,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_snmp_varbind\ *varbinds,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_vars,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cb_id,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ ref);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_send_snmp_inform("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ", const\ char\ *" "cb_id" ", int\ " "ref" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_send_snmp_inform(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ", const\ char\ *" "cb_id" ", int\ " "ref" ");" \}
.nr wf \w'int\ confd_register_notification_sub_snmp_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_notification_sub_snmp_cb\ *cb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_notification_sub_snmp_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_sub_snmp_cb\ *" "cb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_notification_sub_snmp_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_sub_snmp_cb\ *" "cb" ");" \}
.nr wf \w'int\ confd_notification_flush('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_flush("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_flush(struct\ confd_notification_ctx\ *" "nctx" ");" \}
.nr wf \w'int\ confd_register_auth_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_auth_cb\ *acb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_auth_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_auth_cb\ *" "acb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_auth_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_auth_cb\ *" "acb" ");" \}
.nr wf \w'void\ confd_auth_seterr('
.nr wm 0
.nr wp \w'struct\ confd_auth_ctx\ *actx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_auth_seterr("
.br
.BI "struct\ confd_auth_ctx\ *" "actx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_auth_seterr(struct\ confd_auth_ctx\ *" "actx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ confd_register_authorization_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_authorization_cbs\ *acb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_authorization_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_authorization_cbs\ *" "acb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_authorization_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_authorization_cbs\ *" "acb" ");" \}
.nr wf \w'int\ confd_access_reply_result('
.nr wm 0
.nr wp \w'struct\ confd_authorization_ctx\ *actx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ result);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_access_reply_result("
.br
.BI "struct\ confd_authorization_ctx\ *" "actx" ", int\ " "result" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_access_reply_result(struct\ confd_authorization_ctx\ *" "actx" ", int\ " "result" ");" \}
.nr wf \w'int\ confd_authorization_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_authorization_ctx\ *actx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_authorization_set_timeout("
.br
.BI "struct\ confd_authorization_ctx\ *" "actx" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_authorization_set_timeout(struct\ confd_authorization_ctx\ *" "actx" ", int\ " "timeout_secs" ");" \}
.nr wf \w'int\ confd_register_error_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_error_cb\ *ecb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_error_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_error_cb\ *" "ecb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_error_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_error_cb\ *" "ecb" ");" \}
.nr wf \w'void\ confd_error_seterr('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_error_seterr("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_error_seterr(struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.SH "LIBRARY"
.PP
ConfD Library, (libconfd,
\fB\-lconfd\fR)
.SH "DESCRIPTION"
.PP
The
libconfd
shared library is used to connect to the ConfD Data Provider API\&. The purpose of this API is to provide callback hooks so that user\-written data providers can provide data stored externally to ConfD\&. ConfD needs this information in order to drive its northbound agents\&.
.PP
The library is also used to populate items in the data model which are not data or configuration items, such as statistics items from the device\&.
.PP
The library consists of a number of API functions whose purpose is to install different callback functions at different points in the data model tree which is the representation of the device configuration\&. Read more about callpoints in
\m[blue]\fBtailf_yang_extensions(5)\fR\m[]\&. Read more about how to use the library in the User Guide chapters on Operational data and External data\&.
.SH "FUNCTIONS"
.nr wf \w'struct\ confd_daemon_ctx\ *confd_init_daemon('
.nr wm 0
.nr wp \w'const\ char\ *name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "struct confd_daemon_ctx *confd_init_daemon("
.br
.BI "const\ char\ *" "name" ");" \}
.el \{\
.HP \n(wfu
.BI "struct confd_daemon_ctx *confd_init_daemon(const\ char\ *" "name" ");" \}
.PP
Initializes a new daemon context or returns NULL on failure\&. For most of the library functions described here a daemon_ctx is required, so we must create a daemon context before we can use them\&. The daemon context contains a
\fBd_opaque\fR
pointer which can be used by the application to pass application specific data into the callback functions\&.
.PP
The
\fIname\fR
parameter is used in various debug printouts and and is also used to uniquely identify the daemon\&. The
\fBconfd \-\fR\fB\-\fR\fBstatus\fR
will use this name when indicating which callpoints are registered\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_PROTOUSAGE
.nr wf \w'int\ confd_set_daemon_flags('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_set_daemon_flags("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_set_daemon_flags(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "flags" ");" \}
.PP
This function modifies the API behaviour according to the flags ORed into the
\fIflags\fR
argument\&. It should be called immediately after creating the daemon context with
\fBconfd_init_daemon()\fR\&. The following flags are available:
.PP
\fBCONFD_DAEMON_FLAG_STRINGSONLY\fR
.RS 4
If this flag is used, the callback functions described below will only receive string values for all instances of
\fBconfd_value_t\fR
(i\&.e\&. the type is always
\fBC_BUF\fR)\&. The callbacks must also give only string values in their reply functions\&. This feature can be useful for proxy\-type applications that are unaware of the types of all elements, i\&.e\&. data model agnostic\&.
.RE
.PP
\fBCONFD_DAEMON_FLAG_REG_REPLACE_DISCONNECT\fR
.RS 4
By default, if one daemon replaces a callpoint registration made by another daemon, this is only logged, and no action is taken towards the daemon that has "lost" its registration\&. This can be useful in some scenarios, e\&.g\&. it is possible to have an "initial default" daemon providing "null" data for many callpoints, until the actual data provider daemons have registered\&. If a daemon uses the
\fBCONFD_DAEMON_FLAG_REG_REPLACE_DISCONNECT\fR
flag, it will instead be disconnected from ConfD if any of its registrations are replaced by another daemon, and can take action as appropriate\&.
.RE
.PP
\fBCONFD_DAEMON_FLAG_NO_DEFAULTS\fR
.RS 4
This flag tells ConfD that the daemon does not store default values\&. By default, ConfD assumes that the daemon doesn\*(Aqt know about default values, and thus whenever default values come into effect, ConfD will issue
\fBset_elem()\fR
callbacks to set those values, even if they have not actually been set by the northbound agent\&. Similarly
\fBset_case()\fR
will be issued with the default case for choices that have one\&.
.sp
When the
\fBCONFD_DAEMON_FLAG_NO_DEFAULTS\fR
flag is set, ConfD will only issue
\fBset_elem()\fR
callbacks when values have been explicitly set, and
\fBset_case()\fR
when a case has been selected by explicitly setting an element in the case\&. Specifically:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
When a list entry or presence container is created, there will be no callbacks for descendant leafs with default value, or descendant choices with default case, unless values have been explicitly set\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
When a leaf with a default value is deleted, a
\fBremove()\fR
callback will be issued instead of a
\fBset_elem()\fR
with the default value\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
When the current case in a choice with default case is deleted without another case being selected, the
\fBset_case()\fR
callback will be invoked with the case value given as NULL instead of the default case\&.
.RE
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
A daemon that has the
\fBCONFD_DAEMON_FLAG_NO_DEFAULTS\fR
flag set
\fImust\fR
reply to
\fBget_elem()\fR
and the other callbacks that request leaf values with a value of type C_DEFAULT, rather than the actual default value, when the default value for a leaf is in effect\&. It
\fImust\fR
also reply to
\fBget_case()\fR
with C_DEFAULT when the default case is in effect\&.
.sp .5v
.RE
.RE
.PP
\fBCONFD_DAEMON_FLAG_PREFER_BULK_GET\fR
.RS 4
This flag requests that the
\fBget_object()\fR
callback rather than
\fBget_elem()\fR
should be used whenever possible, regardless of whether a "bulk hint" is given by the northbound agent\&. If
\fBget_elem()\fR
is not registered, the flag is not useful (it has no effect \-
\fBget_object()\fR
is always used anyway), but in cases where the callpoint also covers leafs that cannot be retrieved with
\fBget_object()\fR, the daemon
\fImust\fR
register
\fBget_elem()\fR\&.
.RE
.PP
\fBCONFD_DAEMON_FLAG_BULK_GET_CONTAINER\fR
.RS 4
This flag tells ConfD that the data provider is prepared to handle a
\fBget_object()\fR
callback invocation for the toplevel ancestor container when a leaf is requested by a northbound agent, if there exists no ancestor list node but there exists such a container\&. If this flag is not set,
\fBget_object()\fR
is only invoked for list entries, and
\fBget_elem()\fR
is always used for leafs that do not have an ancestor list node\&. If both
\fBget_object()\fR
and
\fBget_elem()\fR
are registered, the choice between them is made as for list entries, i\&.e\&. based on a "bulk hint" from the northbound agent unless the flag
\fBCONFD_DAEMON_FLAG_PREFER_BULK_GET\fR
is also set (see above)\&.
.RE
.PP
\fBCONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF\fR
.RS 4
This flag requests that data provider and transform callbacks should treat leaf\-lists as leafs and not as lists, e\&.g\&. use
\fBget_elem()\fR
/
\fBset_elem()\fR
rather than
\fBget_next()\fR
/
\fBcreate()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This flag is deprecated, and only present for temporary backward compatibility \- it will be removed in a future release\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This flag is not supported for hooks, i\&.e\&. hook callbacks will always treat leaf\-lists as lists \- if the flag is set for a hook, it will cause an error on callback invocation for a leaf\-list\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This flag has no effect for validation callbacks \- however just as for a list, a
tailf:validate
statement for a leaf\-list may use a
tailf:call\-once
substatement to request a single invocation for validation of the whole leaf\-list\&.
.sp .5v
.RE
.RE
.nr wf \w'void\ confd_release_daemon('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_release_daemon("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_release_daemon(struct\ confd_daemon_ctx\ *" "dx" ");" \}
.PP
Returns all memory that has been allocated by
\fBconfd_init_daemon()\fR
and other functions for the daemon context\&. The control socket as well as all the worker sockets must be closed by the application (before or after
\fBconfd_release_daemon()\fR
has been called)\&.
.nr wf \w'int\ confd_connect('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_sock_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr\ *srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ addrsz);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_connect("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "sock" ", enum\ confd_sock_type\ " "type" ", const\ struct\ sockaddr\ *" "srv" ", int\ " "addrsz" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_connect(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "sock" ", enum\ confd_sock_type\ " "type" ", const\ struct\ sockaddr\ *" "srv" ", int\ " "addrsz" ");" \}
.PP
Connects to the ConfD daemon\&. The
\fIdx\fR
parameter is a daemon context acquired through a call to
\fBconfd_init_daemon()\fR\&.
.PP
There are two different types of connected sockets between an external daemon and ConfD\&.
.PP
\fBCONTROL_SOCKET\fR
.RS 4
The first socket that is connected must always be a control socket\&. All requests from ConfD to create new transactions will arrive on the control socket, but it is also used for a number of other requests that are expected to complete quickly \- the general rule is that all callbacks that do not have a corresponding
\fBinit()\fR
callback are in fact control socket requests\&. There can only be one control socket for a given daemon context\&.
.RE
.PP
\fBWORKER_SOCKET\fR
.RS 4
We must always create at least one worker socket\&. All transaction, data, validation, and action callbacks, except the
\fBinit()\fR
callbacks, use a worker socket\&. It is possible for a daemon to have multiple worker sockets, and the
\fBinit()\fR
callback (see e\&.g\&.
\fBconfd_register_trans_cb()\fR) must indicate which worker socket should be used for the subsequent requests\&. This makes it possible for an application to be multi\-threaded, where different threads can be used for different transactions\&.
.RE
.PP
Returns CONFD_OK when successful or CONFD_ERR on connection error\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
All the callbacks that are invoked via these sockets are subject to timeouts configured in
confd\&.conf, see
\m[blue]\fBconfd\&.conf(5)\fR\m[]\&. The callbacks invoked via the control socket must generate a reply back to ConfD within the time configured for
/confdConfig/capi/newSessionTimeout, the callbacks invoked via a worker socket within the time configured for
/confdConfig/capi/queryTimeout\&. If either timeout is exceeded, the daemon will be considered dead, and ConfD will disconnect it by closing the control and worker sockets\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If this call fails (i\&.e\&. does not return CONFD_OK), the socket descriptor must be closed and a new socket created before the call is re\-attempted\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_PROTOUSAGE
.nr wf \w'int\ confd_register_trans_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_trans_cbs\ *trans);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_trans_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_cbs\ *" "trans" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_trans_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_cbs\ *" "trans" ");" \}
.PP
This function registers transaction callback functions\&. A transaction is a ConfD concept\&. There may be multiple sources of data for the device configuration\&.
.PP
In order to orchestrate transactions with multiple sources of data, ConfD implements a two\-phase commit protocol towards all data sources that participate in a transaction\&.
.PP
Each NETCONF operation will be an individual ConfD transaction\&. These transactions are typically very short lived\&. Transactions originating from the CLI or the Web UI have longer life\&. The ConfD transaction can be viewed as a conceptual state machine where the different phases of the transaction are different states and the invocations of the callback functions are state transitions\&. The following ASCII art depicts the state machine\&.
.sp
.if n \{\
.RS 4
.\}
.nf
               +\-\-\-\-\-\-\-+
               | START |
               +\-\-\-\-\-\-\-+
                   | init()
                   |
                   v
      read()   +\-\-\-\-\-\-+          finish()
      \-\-\-\-\-\->  | READ | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> START
               +\-\-\-\-\-\-+
                 ^  |
  trans_unlock() |  | trans_lock()
                 |  v
      read()  +\-\-\-\-\-\-\-\-\-\-+       finish()
      \-\-\-\-\-\-> | VALIDATE | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> START
              +\-\-\-\-\-\-\-\-\-\-+
                   | write_start()
                   |
                   v
      write()  +\-\-\-\-\-\-\-+          finish()
      \-\-\-\-\-\-\-> | WRITE | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> START
               +\-\-\-\-\-\-\-+
                   | prepare()
                   |
                   v
              +\-\-\-\-\-\-\-\-\-\-+   commit()   +\-\-\-\-\-\-\-\-\-\-\-+
              | PREPARED | \-\-\-\-\-\-\-\-\-\-\-> | COMMITTED |
              +\-\-\-\-\-\-\-\-\-\-+              +\-\-\-\-\-\-\-\-\-\-\-+
                   | abort()                  |
                   |                          | finish()
                   v                          |
               +\-\-\-\-\-\-\-\-\-+                    v
               | ABORTED |                  START
               +\-\-\-\-\-\-\-\-\-+
                   | finish()
                   |
                   v
                 START
.fi
.if n \{\
.RE
.\}
.PP
The
\fBstruct confd_trans_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_trans_cbs {
    int (*init)(struct confd_trans_ctx *tctx);
    int (*trans_lock)(struct confd_trans_ctx *sctx);
    int (*trans_unlock)(struct confd_trans_ctx *sctx);
    int (*write_start)(struct confd_trans_ctx *sctx);
    int (*prepare)(struct confd_trans_ctx *tctx);
    int (*abort)(struct confd_trans_ctx *tctx);
    int (*commit)(struct confd_trans_ctx *tctx);
    int (*finish)(struct confd_trans_ctx *tctx);
    void (*interrupt)(struct confd_trans_ctx *tctx);
};
.fi
.if n \{\
.RE
.\}
.PP
Transactions can be performed towards fours different kind of storages\&.
.PP
\fBCONFD_CANDIDATE\fR
.RS 4
If the system has been configured so that the external database owns the candidate data share, we will have to execute candidate transactions here\&. Usually ConfD owns the candidate and in that case the external database will never see any CONFD_CANDIDATE transactions\&.
.RE
.PP
\fBCONFD_RUNNING\fR
.RS 4
This is a transaction towards the actual running configuration of the device\&. All write operations in a CONFD_RUNNING transaction must be propagated to the individual subsystems that use this configuration data\&.
.RE
.PP
\fBCONFD_STARTUP\fR
.RS 4
If the system has ben configured to support the NETCONF startup capability, this is a transaction towards the startup database\&.
.RE
.PP
\fBCONFD_OPERATIONAL\fR
.RS 4
This value indicates a transaction towards writable operational data\&. This transaction is used only if there are non\-config data marked as
tailf:writable true
in the YANG module\&.
.sp
Currently, these transaction are only started by the SNMP agent, and only when writable operational data is SET over SNMP\&.
.RE
.PP
Which type we have is indicated through the
\fIconfd_dbname\fR
field in the
\fBconfd_trans_ctx\fR\&.
.PP
A transaction, regardless of whether it originates from the NETCONF agent, the CLI or the Web UI, has several distinct phases:
.PP
\fBinit()\fR
.RS 4
This callback must always be implemented\&. All other callbacks are optional\&. This means that if the callback is set to NULL, ConfD will treat it as an implicit CONFD_OK\&.
libconfd
will allocate a transaction context on behalf of the transaction and give this newly allocated structure as an argument to the
\fBinit()\fR
callback\&. The structure is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_user_info {
    int af;                        /* AF_INET | AF_INET6 */
    union {
        struct in_addr v4;         /* address from where the */
        struct in6_addr v6;        /* user session originates */
    } ip;
    u_int16_t port;                /* source port */
    char username[MAXUSERNAMELEN]; /* who is the user */
    int usid;                      /* user session id */
    char context[MAXCTXLEN];       /* cli | webui | netconf | */
                                   /* noaaa | any MAAPI string */
    enum confd_proto proto;        /* which protocol */
    struct confd_action_ctx actx;  /* used during action call */
    time_t logintime;
    enum confd_usess_lock_mode lmode;  /* the lock we have (only from */
                                       /* maapi_get_user_session())   */
    char snmp_v3_ctx[255];         /* SNMP context for SNMP sessions */
                                   /* empty string ("") for non\-SNMP sessions */
    char clearpass[255];           /* if have the pass, it\*(Aqs here */
                                   /* only if confd internal ssh is used */
    int flags;                     /* CONFD_USESS_FLAG_\&.\&.\&. */
    void *u_opaque;                /* Private User data */
    /* ConfD internal fields */
    char *errstr;                  /* for error formatting callback */
    int refc;
};
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_trans_ctx {
    int fd;                      /* trans (worker) socket */
    int vfd;                     /* validation worker socket */
    struct confd_daemon_ctx *dx; /* our daemon ctx */
    enum confd_trans_mode mode;
    enum confd_dbname dbname;
    struct confd_user_info *uinfo;
    void *t_opaque;              /* Private User data (transaction) */
    void *v_opaque;              /* Private User data (validation) */
    struct confd_error error;    /* user settable via */
                                 /* confd_trans_seterr*() */
    struct confd_tr_item *accumulated;
    int thandle;                 /* transaction handle */
    void *cb_opaque;             /* private user data from */
                                 /* data callback registration */
    void *vcb_opaque;            /* private user data from */
                                 /* validation callback registration */
    int secondary_index;         /* if != 0: secondary index number */
                                 /* for list traversal */
    int validation_info;         /* CONFD_VALIDATION_FLAG_XXX */
    char *callpoint_opaque;      /* tailf:opaque for callpoint
                                    in data model */
    char *validate_opaque;       /* tailf:opaque for validation point
                                    in data model */
    union confd_request_data request_data; /* info from northbound agent */
    int hide_inactive;           /* if != 0: config data with
                                    CONFD_ATTR_INACTIVE should be hidden */

    /* ConfD internal fields                            */
    int index;         /* array pos                       */
    int lastop;        /* remember what we were doing     */
    int last_proto_op; /* ditto */
    int seen_reply;    /* have we seen a reply msg        */
    int query_ref;     /* last query ref for this trans   */
    int in_num_instances;
    u_int32_t num_instances;
    long nextarg;
    struct confd_data_cbs *next_dcb;
    confd_hkeypath_t *next_kp;
    struct confd_tr_item *lastack; /* tail of acklist */
    int refc;
};
.fi
.if n \{\
.RE
.\}
This callback is required to prepare for future read/write operations towards the data source\&. It could be that a file handle or socket must be established\&. The place to do that is usually the
\fBinit()\fR
callback\&.
.sp
The
\fBinit()\fR
callback is conceptually invoked at the start of the transaction, but as an optimization, ConfD will as far as possible delay the actual invocation for a given daemon until it is required\&. In case of a read\-only transaction, or a daemon that is only providing operational data, this can have the result that a daemon will not have any callbacks at all invoked (if none of the data elements that it provides are accessed)\&.
.sp
The callback must also indicate to
libconfd
which WORKER_SOCKET should be used for future communications in this transaction\&. This is the mechanism which is used by libconfd to distribute work among multiple worker threads in the database application\&. If another thread than the thread which owns the CONTROL_SOCKET should be used, it is up to the application to somehow notify that thread\&.
.sp
The choice of descriptor is done through the API call
\fBconfd_trans_set_fd()\fR
which sets the
\fIfd\fR
field in the transaction context\&.
.sp
The callback must return CONFD_OK, CONFD_DELAYED_RESPONSE or CONFD_ERR\&.
.sp
The transaction then enters READ state, where ConfD will perform a series of
\fBread()\fR
operations\&.
.RE
.PP
\fBtrans_lock()\fR
.RS 4
This callback is invoked when the validation phase of the transaction starts\&. If the underlying database supports real transactions, it is usually appropriate to start such a native transaction here\&.
.sp
The callback must return CONFD_OK, CONFD_DELAYED_RESPONSE, CONFD_ERR, or CONFD_ALREADY_LOCKED\&. The transaction enters VALIDATE state, where ConfD will perform a series of
\fBread()\fR
operations\&.
.sp
The trans lock is set until either
\fBtrans_unlock()\fR
or
\fBfinish()\fR
is called\&. ConfD ensures that a trans_lock is set on a single transaction only\&. In the case of the CONFD_DELAYED_RESPONSE \- to later indicate that the database is already locked, use the
\fBconfd_delayed_reply_error()\fR
function with the special error string "locked"\&. An alternate way to indicate that the database is already locked is to use
\fBconfd_trans_seterr_extended()\fR
(see below) with CONFD_ERRCODE_IN_USE \- this is the only way to give a message in the "delayed" case\&. If this function is used, the callback must return CONFD_ERR in the "normal" case, and in the "delayed" case
\fBconfd_delayed_reply_error()\fR
must be called with a NULL argument after
\fBconfd_trans_seterr_extended()\fR\&.
.RE
.PP
\fBtrans_unlock()\fR
.RS 4
This callback is called when the validation of the transaction failed, or the validation is triggered explicitly (i\&.e\&. not part of a \*(Aqcommit\*(Aq operation)\&. This is common in the CLI and the Web UI where the user can enter invalid data\&. Transactions that originate from NETCONF will never trigger this callback\&. If the underlying database supports real transactions and they are used, the transaction should be aborted here\&.
.sp
The callback must return CONFD_OK, CONFD_DELAYED_RESPONSE or CONFD_ERR\&. The transaction re\-enters READ state\&.
.RE
.PP
\fBwrite_start()\fR
.RS 4
This callback is invoked when the validation succeeded and the write phase of the transaction starts\&. If the underlying database supports real transactions, it is usually appropriate to start such a native transaction here\&.
.sp
The transaction enters the WRITE state\&. No more
\fBread()\fR
operations will be performed by ConfD\&.
.sp
The callback must return CONFD_OK, CONFD_DELAYED_RESPONSE, CONFD_ERR, or CONFD_IN_USE\&.
.sp
If CONFD_IN_USE is returned, the transaction is restarted, i\&.e\&. it effectively returns to the READ state\&. To give this return code after CONFD_DELAYED_RESPONSE, use the
\fBconfd_delayed_reply_error()\fR
function with the special error string "in_use"\&. An alternative for both cases is to use
\fBconfd_trans_seterr_extended()\fR
(see below) with CONFD_ERRCODE_IN_USE \- this is the only way to give a message in the "delayed" case\&. If this function is used, the callback must return CONFD_ERR in the "normal" case, and in the "delayed" case
\fBconfd_delayed_reply_error()\fR
must be called with a NULL argument after
\fBconfd_trans_seterr_extended()\fR\&.
.RE
.PP
\fBprepare()\fR
.RS 4
If we have multiple sources of data it is highly recommended that the callback is implemented\&. The callback is called at the end of the transaction, when all read and write operations for the transaction have been performed and the transaction should prepare to commit\&.
.sp
This callback should allocate the resources necessary for the commit, if any\&. The callback must return CONFD_OK, CONFD_DELAYED_RESPONSE, CONFD_ERR, or CONFD_IN_USE\&.
.sp
If CONFD_IN_USE is returned, the transaction is restarted, i\&.e\&. it effectively returns to the READ state\&. To give this return code after CONFD_DELAYED_RESPONSE, use the
\fBconfd_delayed_reply_error()\fR
function with the special error string "in_use"\&. An alternative for both cases is to use
\fBconfd_trans_seterr_extended()\fR
(see below) with CONFD_ERRCODE_IN_USE \- this is the only way to give a message in the "delayed" case\&. If this function is used, the callback must return CONFD_ERR in the "normal" case, and in the "delayed" case
\fBconfd_delayed_reply_error()\fR
must be called with a NULL argument after
\fBconfd_trans_seterr_extended()\fR\&.
.RE
.PP
\fBcommit()\fR
.RS 4
This callback is optional\&. This callback is responsible for writing the data to persistent storage\&. Must return CONFD_OK, CONFD_DELAYED_RESPONSE or CONFD_ERR\&.
.RE
.PP
\fBabort()\fR
.RS 4
This callback is optional\&. This callback is responsible for undoing whatever was done in the
\fBprepare()\fR
phase\&. Must return CONFD_OK, CONFD_DELAYED_RESPONSE or CONFD_ERR\&.
.RE
.PP
\fBfinish()\fR
.RS 4
This callback is optional\&. This callback is responsible for releasing resources allocated in the
\fBinit()\fR
phase\&. In particular, if the application choose to use the
\fIt_opaque\fR
field in the
\fBconfd_trans_ctx\fR
to hold any resources, these resources must be released here\&.
.RE
.PP
\fBinterrupt()\fR
.RS 4
This callback is optional\&. Unlike the other transaction callbacks, it does not imply a change of the transaction state, it is instead a notification that the user running the transaction requested that it should be interrupted (e\&.g\&. Ctrl\-C in the CLI)\&. Also unlike the other transaction callbacks, the callback request is sent asynchronously on the control socket\&. Registering this callback may be useful for a configuration data provider that has some (transaction or data) callbacks which require extensive processing \- the callback could then determine whether one of these callbacks is being processed, and if feasible return an error from that callback instead of completing the processing\&. In that case,
\fBconfd_trans_seterr_extended()\fR
with
\fIcode\fR\fBCONFD_ERRCODE_INTERRUPT\fR
should be used\&.
.RE
.PP
All the callback functions (except
\fBinterrupt()\fR) must return CONFD_OK, CONFD_DELAYED_RESPONSE or CONFD_ERR\&.
.PP
It is often useful to associate an error string with a CONFD_ERR return value\&. This can be done through a call to
\fBconfd_trans_seterr()\fR
or
\fBconfd_trans_seterr_extended()\fR\&.
.PP
Depending on the situation (original caller) the error string gets propagated to the CLI, the Web UI or the NETCONF manager\&.
.nr wf \w'int\ confd_register_db_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_db_cbs\ *dbcbs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_db_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_db_cbs\ *" "dbcbs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_db_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_db_cbs\ *" "dbcbs" ");" \}
.PP
We may also optionally have a set of callback functions which span over several ConfD transactions\&.
.PP
If the system is configured in such a way so that the external database owns the candidate data store we must implement four callback functions to do this\&. If ConfD owns the candidate the candidate callbacks should be set to NULL\&.
.PP
If ConfD owns the candidate, ConfD has been configured to support
confirmed\-commit
and the
\fIrevertByCommit\fR
isn\*(Aqt enabled, then three checkpointing functions must be implemented; otherwise these should be set to NULL\&. When
confirmed\-commit
is enabled, the user can commit the candidate with a timeout\&. Unless a confirming commit is given by the user before the timer expires, the system must rollback to the previous running configuration\&. This mechanism is controlled by the checkpoint callbacks\&. If the revertByCommit feature is enabled the potential rollback to previous running configuration is done using normal reversed commits, hence no checkpointing support is required in this case\&. See further below\&.
.PP
An external database may also (optionally) support the lock/unlock and lock_partial/unlock_partial operations\&. This is only interesting if there exists additional locking mechanisms towards the database \- such as an external CLI which can lock the database, or if the external database owns the candidate\&.
.PP
Finally, the external database may optionally validate a candidate configuration\&. Configuration validation is preferably done through ConfD \- however if a system already has implemented extensive configuration validation \- the
\fBcandidate_validate()\fR
callback can be used\&.
.PP
The
\fBstruct confd_db_cbs\fR
structure looks like:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_db_cbs {
    int (*candidate_commit)(struct confd_db_ctx *dbx, int timeout);
    int (*candidate_confirming_commit)(struct confd_db_ctx *dbx);
    int (*candidate_reset)(struct confd_db_ctx *dbx);
    int (*candidate_chk_not_modified)(struct confd_db_ctx *dbx);
    int (*candidate_rollback_running)(struct confd_db_ctx *dbx);
    int (*candidate_validate)(struct confd_db_ctx *dbx);
    int (*add_checkpoint_running)(struct confd_db_ctx *dbx);
    int (*del_checkpoint_running)(struct confd_db_ctx *dbx);
    int (*activate_checkpoint_running)(struct confd_db_ctx *dbx);
    int (*copy_running_to_startup)(struct confd_db_ctx *dbx);
    int (*running_chk_not_modified)(struct confd_db_ctx *dbx);
    int (*lock)(struct confd_db_ctx *dbx, enum confd_dbname dbname);
    int (*unlock)(struct confd_db_ctx *dbx, enum confd_dbname dbname);
    int (*lock_partial)(struct confd_db_ctx *dbx,
                        enum confd_dbname dbname, int lockid,
                        confd_hkeypath_t paths[], int npaths);
    int (*unlock_partial)(struct confd_db_ctx *dbx,
                          enum confd_dbname dbname, int lockid);
    int (*delete_config)(struct confd_db_ctx *dbx,
                         enum confd_dbname dbname);
};
.fi
.if n \{\
.RE
.\}
.PP
If we have an externally implemented candidate, that is if confd\&.conf item
/confdConfig/datastores/candidate/implementation
is set to "external", we must implement the 5 candidate callbacks\&. Otherwise (recommended) they must be set to NULL\&.
.PP
If implementation is "external", all databases (if there are more than one) MUST take care of the candidate for their part of the configuration data tree\&. If ConfD is configured to use an external database for parts of the configuration, and the built\-in CDB database is used for some parts, CDB will handle the candidate for its part\&. See also
misc/extern_candidate
in the examples collection\&.
.PP
The callback functions are are the following:
.PP
\fBcandidate_commit()\fR
.RS 4
This function should copy the candidate DB into the running DB\&. If
\fItimeout\fR
!= 0, we should be prepared to do a rollback or act on a
\fBcandidate_confirming_commit()\fR\&. The
\fItimeout\fR
parameter can not be used to set a timer for when to rollback; this timer is handled by the ConfD daemon\&. If we terminate without having acted on the
\fBcandidate_confirming_commit()\fR, we MUST restart with a rollback\&. Thus we must remember that we are waiting for a
\fBcandidate_confirming_commit()\fR
and we must do so on persistent storage\&. Must only be implemented when the external database owns the candidate\&.
.RE
.PP
\fBcandidate_confirming_commit()\fR
.RS 4
If the
\fItimeout\fR
in the
\fBcandidate_commit()\fR
function is != 0, we will be either invoked here or in the
\fBcandidate_rollback_running()\fR
function within
\fItimeout\fR
seconds\&.
\fBcandidate_confirming_commit()\fR
should make the commit persistent, whereas a call to
\fBcandidate_rollback_running()\fR
would copy back the previous running configuration to running\&.
.RE
.PP
\fBcandidate_rollback_running()\fR
.RS 4
If for some reason, apart from a timeout, something goes wrong, we get invoked in the
\fBcandidate_rollback_running()\fR
function\&. The function should copy back the previous running configuration to running\&.
.RE
.PP
\fBcandidate_reset()\fR
.RS 4
This function is intended to copy the current running configuration into the candidate\&. It is invoked whenever the NETCONF operation
<discard\-changes>
is executed or when a lock is released without committing\&.
.RE
.PP
\fBcandidate_chk_not_modified()\fR
.RS 4
This function should check to see if the candidate has been modified or not\&. Returns CONFD_OK if no modifications has been done since the last commit or reset, and CONFD_ERR if any uncommitted modifications exist\&.
.RE
.PP
\fBcandidate_validate()\fR
.RS 4
This callback is optional\&. If implemented, the task of the callback is to validate the candidate configuration\&. Note that the running database can be validated by the database in the
\fBprepare()\fR
callback\&.
\fBcandidate_validate()\fR
is only meaningful when an explicit validate operation is received, e\&.g\&. through NETCONF\&.
.RE
.PP
\fBadd_checkpoint_running()\fR
.RS 4
This function should be implemented only when ConfD owns the candidate, confirmed\-commit is enabled and revertByCommit is disabled\&.
.sp
It is responsible for creating a checkpoint of the current running configuration and storing the checkpoint in non\-volatile memory\&. When the system restarts this function should check if there is a checkpoint available, and use the checkpoint instead of running\&.
.RE
.PP
\fBdel_checkpoint_running()\fR
.RS 4
This function should delete a checkpoint created by
\fBadd_checkpoint_running()\fR\&. It is called by ConfD when a confirming commit is received unless revertByCommit is enabled\&.
.RE
.PP
\fBactivate_checkpoint_running()\fR
.RS 4
This function should rollback running to the checkpoint created by
\fBadd_checkpoint_running()\fR\&. It is called by ConfD when the timer expires or if the user session expires unless revertByCommit is enabled\&.
.RE
.PP
\fBcopy_running_to_startup()\fR
.RS 4
This function should copy running to startup\&. It only needs to be implemented if the startup data store is enabled\&.
.RE
.PP
\fBrunning_chk_not_modified()\fR
.RS 4
This function should check to see if running has been modified or not\&. It only needs to be implemented if the startup data store is enabled\&. Returns CONFD_OK if no modifications have been done since the last copy of running to startup, and CONFD_ERR if any modifications exist\&.
.RE
.PP
\fBlock()\fR
.RS 4
This should only be implemented if our database supports locking from other sources than through ConfD\&. In this case both the lock/unlock and lock_partial/unlock_partial callbacks must be implemented\&. If a lock on the whole database is set through e\&.g\&. NETCONF, ConfD will first make sure that no other ConfD transaction has locked the database\&. Then it will call
\fBlock()\fR
to make sure that the database is not locked by some other source (such as a non\-ConfD CLI)\&. Returns CONFD_OK on success, and CONFD_ERR if the lock was already held by an external entity\&.
.RE
.PP
\fBunlock()\fR
.RS 4
Unlocks the database\&.
.RE
.PP
\fBlock_partial()\fR
.RS 4
This should only be implemented if our database supports locking from other sources than through ConfD, see
\fBlock()\fR
above\&. This callback is invoked if a northbound agent requests a partial lock\&. The
\fIpaths[]\fR
argument is an
\fInpaths\fR
long array of hkeypaths that identify the leafs and/or subtrees that are to be locked\&. The
\fIlockid\fR
is a reference that will be used on a subsequent corresponding
\fBunlock_partial()\fR
invocation\&.
.RE
.PP
\fBunlock_partial()\fR
.RS 4
Unlocks the partial lock that was requested with
\fIlockid\fR\&.
.RE
.PP
\fBdelete_config()\fR
.RS 4
Will be called for \*(Aqstartup\*(Aq or \*(Aqcandidate\*(Aq only\&. The database is supposed to be set to erased\&.
.RE
.PP
All the above callback functions must return either CONFD_OK or CONFD_ERR\&. If the system is configured so that ConfD owns the candidate, then obviously the candidate related functions need not be implemented\&. If the system is configured to not do confirmed commit,
\fBcandidate_confirming_commit()\fR
and
\fBcandidate_commit()\fR
need not to be implemented\&.
.PP
It is often interesting to associate an error string with a CONFD_ERR return value\&. In particular the
\fBvalidate()\fR
callback must typically indicate which item was invalid and why\&. This can be done through a call to
\fBconfd_db_seterr()\fR
or
\fBconfd_db_seterr_extended()\fR\&.
.PP
Depending on the situation (original caller) the error string is propagated to the CLI, the Web UI or the NETCONF manager\&.
.nr wf \w'int\ confd_register_data_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_data_cbs\ *data);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_data_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_data_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ");" \}
.PP
This function registers the data manipulation callbacks\&. The data model defines a number of "callpoints"\&. Each callpoint must have an associated set of data callbacks\&.
.PP
Thus if our database application serves three different callpoints in the data model we must install three different sets of data manipulation callbacks \- one set at each callpoint\&.
.PP
The data callbacks either return data back to ConfD or they do not\&. For example the
\fBcreate()\fR
callback does not return data whereas the
\fBget_next()\fR
callback does\&. All the callbacks that return data do so through API functions, not by means of return values from the function itself\&.
.PP
The
\fBstruct confd_data_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_data_cbs {
    char callpoint[MAX_CALLPOINT_LEN];
    /* where in the XML tree do we */
    /* want this struct */

    /* Only necessary to have this cb if our data model has */
    /* typeless optional nodes or oper data lists w/o keys */
    int (*exists_optional)(struct confd_trans_ctx *tctx,
                           confd_hkeypath_t *kp);
    int (*get_elem)(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp);
    int (*get_next)(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp, long next);
    int (*set_elem)(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp,
                    confd_value_t *newval);
    int (*create)(struct confd_trans_ctx *tctx,
                  confd_hkeypath_t *kp);
    int (*remove)(struct confd_trans_ctx *tctx,
                  confd_hkeypath_t *kp);
    /* optional (find list entry by key/index values) */
    int (*find_next)(struct confd_trans_ctx *tctx,
                     confd_hkeypath_t *kp,
                     enum confd_find_next_type type,
                     confd_value_t *keys, int nkeys);
    /* optional optimizations */
    int (*num_instances)(struct confd_trans_ctx *tctx,
                         confd_hkeypath_t *kp);
    int (*get_object)(struct confd_trans_ctx *tctx,
                      confd_hkeypath_t *kp);
    int (*get_next_object)(struct confd_trans_ctx *tctx,
                           confd_hkeypath_t *kp, long next);
    int (*find_next_object)(struct confd_trans_ctx *tctx,
                            confd_hkeypath_t *kp,
                            enum confd_find_next_type type,
                            confd_value_t *keys, int nkeys);
    /* next two are only necessary if \*(Aqchoice\*(Aq is used */
    int (*get_case)(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp, confd_value_t *choice);
    int (*set_case)(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp, confd_value_t *choice,
                    confd_value_t *caseval);
    /* next two are only necessary for config data providers,
       and only if /confdConfig/enableAttributes is \*(Aqtrue\*(Aq */
    int (*get_attrs)(struct confd_trans_ctx *tctx,
                     confd_hkeypath_t *kp,
                     u_int32_t *attrs, int num_attrs);
    int (*set_attr)(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp,
                    u_int32_t attr, confd_value_t *v);
    /* only necessary if "ordered\-by user" is used */
    int (*move_after)(struct confd_trans_ctx *tctx,
                      confd_hkeypath_t *kp, confd_value_t *prevkeys);
    /* only for per\-transaction\-invoked transaction hook */
    int (*write_all)(struct confd_trans_ctx *tctx,
                     confd_hkeypath_t *kp);
    void *cb_opaque; /* private user data    */
};
.fi
.if n \{\
.RE
.\}
.PP
One of the parameters to the callback is a
\fBconfd_hkeypath_t\fR
(h \- as in hashed keypath)\&. This is fully described in
\m[blue]\fBconfd_types(3)\fR\m[]\&.
.PP
The
\fIcb_opaque\fR
element can be used to pass arbitrary data to the callbacks, e\&.g\&. when the same set of callbacks is used for multiple callpoints\&. It is made available to the callbacks via an element with the same name in the transaction context (\fItctx\fR
argument), see the structure definition above\&.
.PP
If the
tailf:opaque
substatement has been used with the
tailf:callpoint
statement in the data model, the argument string is made available to the callbacks via the
\fIcallpoint_opaque\fR
element in the transaction context\&.
.PP
When use of the
\fBCONFD_ATTR_INACTIVE\fR
attribute is enabled in the ConfD configuration (/confdConfig/enableAttributes
and
/confdConfig/enableInactive
both set to
\fBtrue\fR), read callbacks (\fBget_elem()\fR
etc) for configuration data must observe the current value of the
\fIhide_inactive\fR
element in the transaction context\&. If it is non\-zero, those callbacks must act as if data with the
\fBCONFD_ATTR_INACTIVE\fR
attribute set does not exist\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_PROTOUSAGE
.PP
\fBget_elem()\fR
.RS 4
This callback function needs to return the value of a specific leaf\&. Assuming we have the following data model:
.sp
.if n \{\
.RS 4
.\}
.nf
container servers {
  tailf:callpoint mycp;
  list server {
    key name;
    max\-elements 64;
    leaf name {
      type string;
    }
    leaf ip {
      type inet:ip\-address;
    }
    leaf port {
      type inet:port\-number;
    }
  }
}
.fi
.if n \{\
.RE
.\}
For example the value of the
ip
leaf in the server entry whose key is "www" can be returned separately\&. The way to return a single data item is through
\fBconfd_data_reply_value()\fR\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE if the reply value is not yet available\&. In the latter case the application must at a later stage call
\fBconfd_data_reply_value()\fR
(or
\fBconfd_delayed_reply_ok()\fR
for a write operation)\&. If an error is discovered at the time of a delayed reply, the error is signaled through a call to
\fBconfd_delayed_reply_error()\fR
.sp
If the leaf does not exist the callback must call
\fBconfd_data_reply_not_found()\fR\&. If the leaf has a default value defined in the data model, and no value has been set, the callback should use
\fBconfd_data_reply_value()\fR
with a value of type C_DEFAULT \- this makes it possible for northbound agents to leave such leafs out of the data returned to the user/manager (if requested)\&.
.sp
The implementation of
\fBget_elem()\fR
must be prepared to return values for all the leafs including the key(s)\&. When ConfD invokes
\fBget_elem()\fR
on a key leaf it is an existence test\&. The application should verify whether the object exists or not\&.
.RE
.PP
\fBget_next()\fR
.RS 4
This callback makes it possible for ConfD to traverse a set of list entries, or a set leaf\-list elements (unless the deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is used)\&. The
\fInext\fR
parameter will be
\fB\-1\fR
on the first invocation\&. This function should reply by means of the function
\fBconfd_data_reply_next_key()\fR\&.
.sp
If the list has a
tailf:secondary\-index
statement (see
\m[blue]\fBtailf_yang_extensions(5)\fR\m[]), and the entries are supposed to be retrieved according to one of the secondary indexes, the variable
\fItctx\->secondary_index\fR
will be set to a value greater than
\fB0\fR, indicating which secondary\-index is used\&. The first secondary\-index in the definition is identified with the value
\fB1\fR, the second with
\fB2\fR, and so on\&. confdc can be used to generate
#defines for the index names\&. If no secondary indexes are defined, or if the sort order should be according to the key values,
\fItctx\->secondary_index\fR
is
\fB0\fR\&.
.sp
To signal that no more entries exist, we reply with a NULL pointer as the key value in the
\fBconfd_data_reply_next_key()\fR
function\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE if the reply value is not yet available\&. In the latter case the application must at a later stage call
\fBconfd_data_reply_next_key()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
For a list that does not specify a non\-default sort order by means of a
ordered\-by user
or
tailf:sort\-order
statement, ConfD assumes that list entries are ordered strictly by increasing key (or secondary index) values\&. Thus for correct operation, we must observe this order when returning list entries in a sequence of
\fBget_next()\fR
calls\&.
.sp .5v
.RE
.RE
.PP
\fBset_elem()\fR
.RS 4
This callback writes the value of a leaf\&. Note that an optional leaf with a type other than
\fBempty\fR
is created by a call to this function\&. The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE\&.
.RE
.PP
\fBcreate()\fR
.RS 4
This callback creates a new list entry, a
presence
container, a leaf of type
empty, or a leaf\-list element (unless the deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is used)\&. In the case of the
servers
data model above, this function need to create a new
server
entry\&. Must return CONFD_OK on success, CONFD_ERR on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE\&.
.sp
The data provider is responsible for maintaining the order of list entries\&. If the list is marked as
ordered\-by user
in the YANG data model, the
create()
callback must add the list entry to the end of the list\&.
.RE
.PP
\fBremove()\fR
.RS 4
This callback is used to remove an existing list entry or
presence
container and all its sub nodes (if any), an optional leaf, or a leaf\-list element (unless the deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is used)\&. When we use the YANG
choice
statement in the data model, it may also be used to remove nodes that are not optional as such when a different
case
(or none) is selected\&. I\&.e\&. it must always be possible to remove cases in a choice\&.
.sp
Must return CONFD_OK on success, CONFD_ERR on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE\&.
.RE
.PP
\fBexists_optional()\fR
.RS 4
If we have
presence
containers or leafs of type
empty, we cannot use the
\fBget_elem()\fR
callback to read the value of such a node, since it does not have a type\&. An example of a data model could be:
.sp
.if n \{\
.RS 4
.\}
.nf
container bs {
  presence "";
  tailf:callpoint bcp;
  list b {
    key name;
    max\-elements 64;
    leaf name {
      type string;
    }
    container opt {
      presence "";
      leaf ii {
        type int32;
      }
    }
    leaf foo {
      type empty;
    }
  }
}
.fi
.if n \{\
.RE
.\}
The above YANG fragment has 3 nodes that may or may not exist and that do not have a type\&. If we do not have any such elements, nor any operational data lists without keys (see below), we do not need to implement the
\fBexists_optional()\fR
callback and can set it to NULL\&.
.sp
If we have the above data model, we must implement the
\fBexists_optional()\fR, and our implementation must be prepared to reply on calls of the function for the paths
/bs,
/bs/b/opt, and
/bs/b/foo\&. The leaf
/bs/b/opt/ii
is not mandatory, but it does have a type namely
\fBint32\fR, and thus the existence of that leaf will be determined through a call to the
\fBget_elem()\fR
callback\&.
.sp
The
\fBexists_optional()\fR
callback may also be invoked by ConfD as "existence test" for an entry in an operational data list without keys (see the
\m[blue]\fBOperational Data chapter in the User Guide\fR\m[]), or for a leaf\-list entry (unless the deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is used)\&. Normally this existence test is done with a
\fBget_elem()\fR
request for the first key, but since there are no keys, this callback is used instead\&. Thus if we have such lists, or leaf\-lists, we must also implement this callback, and handle a request where the keypath identifies a list entry or a leaf\-list element\&.
.sp
The callback must reply to ConfD using either the
\fBconfd_data_reply_not_found()\fR
or the
\fBconfd_data_reply_found()\fR
function\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE if the reply value is not yet available\&.
.RE
.PP
\fBfind_next()\fR
.RS 4
This optional callback can be registered to optimize cases where ConfD wants to start a list traversal at some other point than at the first entry of the list, or otherwise make a "jump" in a list traversal\&. If the callback is not registered, ConfD will use a sequence of
\fBget_next()\fR
calls to find the desired list entry\&.
.sp
Where the
\fBget_next()\fR
callback provides a
\fInext\fR
parameter to indicate which keys should be returned, this callback instead provides a
\fItype\fR
parameter and a set of values to indicate which keys should be returned\&. Just like for
\fBget_next()\fR, the callback should reply by calling
\fBconfd_data_reply_next_key()\fR
with the keys for the requested list entry\&.
.sp
The
\fIkeys\fR
parameter is a pointer to a
\fInkeys\fR
elements long array of key values, or secondary index\-leaf values (see below)\&. The
\fItype\fR
can have one of two values:
.PP
\fBCONFD_FIND_NEXT\fR
.RS 4
The callback should always reply with the key values for the first list entry
\fIafter\fR
the one indicated by the
\fIkeys\fR
array, and a
\fInext\fR
value appropriate for retrieval of subsequent entries\&. The
\fIkeys\fR
array may not correspond to an actual existing list entry \- the callback must return the keys for the first existing entry that is "later" in the list order than the keys provided by the callback\&. Furthermore the number of values provided in the array (\fInkeys\fR) may be fewer than the number of keys (or number of index\-leafs for a secondary\-index) in the data model, possibly even zero\&. This means that only the first
\fInkeys\fR
values are provided, and the remaining ones should be taken to have a value "earlier" than the value for any existing list entry\&.
.RE
.PP
\fBCONFD_FIND_SAME_OR_NEXT\fR
.RS 4
If the values in the
\fIkeys\fR
array completely identify an actual existing list entry, the callback should reply with the keys for this list entry and a corresponding
\fInext\fR
value\&. Otherwise the same logic as described for
\fBCONFD_FIND_NEXT\fR
should be used\&.
.RE
.sp
The
dp/find_next
example in the bundled examples collection has an implementation of the
\fBfind_next()\fR
callback for a list with two integer keys\&. It shows how the
\fItype\fR
value and the provided keys need to be combined in order to find the requested entry \- or find that no entry matching the request exists\&.
.sp
If the list has a
tailf:secondary\-index
statement (see
\m[blue]\fBtailf_yang_extensions(5)\fR\m[]), the callback must examine the value of the
\fItctx\->secondary_index\fR
variable, as described for the
\fBget_next()\fR
callback\&. If
\fItctx\->secondary_index\fR
has a value greater than
\fB0\fR, the
\fIkeys\fR
and
\fInkeys\fR
parameters do not represent key values, but instead values for the index leafs specified by the
tailf:index\-leafs
statement for the secondary index\&. The callback should however still reply with the actual key values for the list entry in the
\fBconfd_data_reply_next_key()\fR
call\&.
.sp
Once we have called
\fBconfd_data_reply_next_key()\fR, ConfD will use
\fBget_next()\fR
(or
\fBget_next_object()\fR) for any subsequent entry\-by\-entry list traversal \- however we can request that this traversal should be done using
\fBfind_next()\fR
(or
\fBfind_next_object()\fR) instead, by passing
\fB\-1\fR
for the
\fInext\fR
parameter to
\fBconfd_data_reply_next_key()\fR\&. In this case ConfD will always invoke
\fBfind_next()\fR/\fBfind_next_object()\fR
with
\fItype\fR\fBCONFD_FIND_NEXT\fR, and the (complete) set of keys from the previous reply\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
In the case of list traversal by means of a secondary index, the secondary index values must be unique for entry\-by\-entry traversal with
\fBfind_next()\fR/\fBfind_next_object()\fR
to be possible\&. Thus we can not pass
\fB\-1\fR
for the
\fInext\fR
parameter to
\fBconfd_data_reply_next_key()\fR
in this case if the secondary index values are not unique\&.
.sp .5v
.RE
To signal that no entry matching the request exists, i\&.e\&. we have reached the end of the list while evaluating the request, we reply with a NULL pointer as the key value in the
\fBconfd_data_reply_next_key()\fR
function\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
For a list that does not specify a non\-default sort order by means of a
ordered\-by user
or
tailf:sort\-order
statement, ConfD assumes that list entries are ordered strictly by increasing key values\&.
.sp .5v
.RE
If we have registered
\fBfind_next()\fR
(or
\fBfind_next_object()\fR), it is not strictly necessary to also register
\fBget_next()\fR
(or
\fBget_next_object()\fR) \- except for the case of traversal by secondary index when the secondary index values are not unique, see above\&. If a northbound agent does a get_next request, and neither
\fBget_next()\fR
nor
\fBget_next_object()\fR
is registered, ConfD will instead invoke
\fBfind_next()\fR
(or
\fBfind_next_object()\fR), the same way as if
\fB\-1\fR
had been passed for the
\fInext\fR
parameter to
\fBconfd_data_reply_next_key()\fR
as described above \- the actual
\fInext\fR
value passed is ignored\&. The very first get_next request for a traversal (i\&.e\&. where the
\fInext\fR
parameter would be
\fB\-1\fR) will cause a find_next invocation with
\fItype\fR\fBCONFD_FIND_NEXT\fR
and
\fInkeys\fR
== 0, i\&.e\&. no keys provided\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE if the reply value is not yet available\&. In the latter case the application must at a later stage call
\fBconfd_data_reply_next_key()\fR\&.
.RE
.PP
\fBnum_instances()\fR
.RS 4
This callback can optionally be implemented\&. The purpose is to return the number of entries in a list, or the number of elements in a leaf\-list\&. If the callback is set to NULL, whenever ConfD needs to calculate the number of entries in a certain list, ConfD will iterate through the entries by means of consecutive calls to the
\fBget_next()\fR
callback\&.
.sp
If we have a large number of entries
\fIand\fR
it is computationally cheap to calculate the number of entries in a list, it may be worth the effort to implement this callback for performance reasons\&.
.sp
The number of entries is returned in an
\fBconfd_value_t\fR
value of type C_INT32\&. The value is returned through a call to
\fBconfd_data_reply_value()\fR, see code example below:
.sp
.if n \{\
.RS 4
.\}
.nf
    int num_instances;
    confd_value_t v;

    CONFD_SET_INT32(&v, num_instances);
    confd_data_reply_value(trans_ctx, &v);
    return CONFD_OK;
.fi
.if n \{\
.RE
.\}
Must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE\&.
.RE
.PP
\fBget_object()\fR
.RS 4
The implementation of this callback is also optional\&. The purpose of the callback is to return an entire object, i\&.e\&. a list entry, in one swoop\&. If the callback is not implemented, ConfD will retrieve the whole object through a series of calls to
\fBget_elem()\fR\&.
.sp
By default, the callback will only be called for list entries \- i\&.e\&.
\fBget_elem()\fR
is still needed for leafs that are not defined in a list, but if there are no such leafs in the part of the data model covered by a given callpoint, the
\fBget_elem()\fR
callback may be omitted when
\fBget_object()\fR
is registered\&. This has the drawback that ConfD will have to invoke get_object() even if only a single leaf in a list entry is needed though, e\&.g\&. for the existence test mentioned for
\fBget_elem()\fR\&.
.sp
However, if the
\fBCONFD_DAEMON_FLAG_BULK_GET_CONTAINER\fR
flag is set via
\fBconfd_set_daemon_flags()\fR,
\fBget_object()\fR
will also be used for the toplevel ancestor container (if any) when no ancestor list node exists\&. I\&.e\&. in this case,
\fBget_elem()\fR
is only needed for toplevel leafs \- if there are any such leafs in the part of the data model covered by a given callpoint\&.
.sp
When ConfD invokes the
\fBget_elem()\fR
callback, it is the responsibility of the application to issue calls to the reply function
\fBconfd_data_reply_value()\fR\&. The
\fBget_object()\fR
callback cannot use this function since it needs to return a sequence of values\&. The
\fBget_object()\fR
callback must use either the
\fBconfd_data_reply_value_array()\fR
function or the
\fBconfd_data_reply_tag_value_array()\fR
function\&. See the description of these functions below for the details of the arguments passed\&. If the entry requested does not exist, the callback must call
\fBconfd_data_reply_not_found()\fR\&.
.sp
Remember, the callback
\fBexists_optional()\fR
must always be implemented when we have
presence
containers or leafs of type
empty\&. If we also choose to implement the
\fBget_object()\fR
callback, ConfD can sometimes derive the existence of such a node through a previous call to
\fBget_object()\fR\&. This is however not always the case, thus even if we implement
\fBget_object()\fR, we must also implement
\fBexists_optional()\fRif we have such nodes\&.
.sp
If we pass an array of values which does not comply with the rules for the above functions, ConfD will notice and an error is reported to the agent which issued the request\&. A message is also logged to ConfD\*(Aqs developerLog\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE if the reply value is not yet available\&.
.RE
.PP
\fBget_next_object()\fR
.RS 4
The implementation of this callback is also optional\&. Similar to the
\fBget_object()\fR
callback the purpose of this callback is to return an entire object, or even multiple objects, in one swoop\&. It combines the functionality of
\fBget_next()\fR
and
\fBget_object()\fR
into a single callback, and adds the possibility to return multiple objects\&. Thus we need only implement this callback if it very important to be able to traverse a list very fast\&. If the callback is not implemented, ConfD will retrieve the whole object through a series of calls to
\fBget_next()\fR
and consecutive calls to either
\fBget_elem()\fR
or
\fBget_object()\fR\&.
.sp
When we have registered
\fBget_next_object()\fR, it is not strictly necessary to also register
\fBget_next()\fR, but omitting
\fBget_next()\fR
may have a serious performance impact, since there are cases (e\&.g\&. CLI tab completion) when ConfD only wants to retrieve the keys for a list\&. In such a case, if we have only registered
\fBget_next_object()\fR, all the data for the list will be retrieved, but everything except the keys will be discarded\&. Also note that even if we have registered
\fBget_next_object()\fR, at least one of the
\fBget_elem()\fR
and
\fBget_object()\fR
callbacks must be registered\&.
.sp
Similar to the
\fBget_next()\fR
callback, if the
\fInext\fR
parameter is
\fB\-1\fR
ConfD wants to retrieve the first entry in the list\&.
.sp
Similar to the
\fBget_next()\fR
callback, if the
\fItctx\->secondary_index\fR
parameter is greater than
\fB0\fR
ConfD wants to retrieve the entries in the order defined by the secondary index\&.
.sp
Similar to the
\fBget_object()\fR
callback,
\fBget_next_object()\fR
needs to reply with an entire object expressed as either an array of
\fBconfd_value_t\fR
values or an array of
\fBconfd_tag_value_t\fR
values\&. It must also indicate which is the
\fInext\fR
entry in the list similar to the
\fBget_next()\fR
callback\&. The two functions
\fBconfd_data_reply_next_object_array()\fR
and
\fBconfd_data_reply_next_object_tag_value_array()\fR
are use to convey the return values for one object from the
\fBget_next_object()\fR
callback\&.
.sp
If we want to reply with multiple objects, we must instead use one of the functions
\fBconfd_data_reply_next_object_arrays()\fR
and
\fBconfd_data_reply_next_object_tag_value_arrays()\fR\&. These functions take an "array of object arrays", where each element in the array corresponds to the reply for a single object with
\fBconfd_data_reply_next_object_array()\fR
and
\fBconfd_data_reply_next_object_tag_value_array()\fR, respectively\&.
.sp
If we pass an array of values which does not comply with the rules for the above functions, ConfD will notice and an error is reported to the agent which issued the request\&. A message is also logged to ConfD\*(Aqs developerLog\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE if the reply value is not yet available\&.
.RE
.PP
\fBfind_next_object()\fR
.RS 4
The implementation of this callback is also optional\&. It relates to
\fBget_next_object()\fR
in exactly the same way as
\fBfind_next()\fR
relates to
\fBget_next()\fR\&. I\&.e\&. instead of a parameter
\fInext\fR, we get a
\fItype\fR
parameter and a set of key values, or secondary index\-leaf values, to indicate which object or objects to return to ConfD via one of the reply functions\&.
.sp
Similar to the
\fBget_next_object()\fR
callback, if the
\fItctx\->secondary_index\fR
parameter is greater than
\fB0\fR
ConfD wants to retrieve the entries in the order defined by the secondary index\&. And as described for the
\fBfind_next()\fR
callback, in this case the
\fIkeys\fR
and
\fInkeys\fR
parameters represent values for the index leafs specified by the
tailf:index\-leafs
statement for the secondary index\&.
.sp
Similar to the
\fBget_next_object()\fR
callback, the callback can use any of the functions
\fBconfd_data_reply_next_object_array()\fR,
\fBconfd_data_reply_next_object_tag_value_array()\fR,
\fBconfd_data_reply_next_object_arrays()\fR, and
\fBconfd_data_reply_next_object_tag_value_arrays()\fR
to return one or more objects to ConfD\&.
.sp
If we pass an array of values which does not comply with the rules for the above functions, ConfD will notice and an error is reported to the agent which issued the request\&. A message is also logged to ConfD\*(Aqs developerLog\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error or CONFD_DELAYED_RESPONSE if the reply value is not yet available\&.
.RE
.PP
\fBget_case()\fR
.RS 4
This callback only needs to be implemented if we use the YANG
choice
statement in the part of the data model that our data provider is responsible for, but when we use choice, the callback is required\&. It should return the currently selected
case
for the choice given by the
\fIchoice\fR
argument \-
\fIkp\fR
is the path to the container or list entry where the choice is defined\&.
.sp
In the general case, where there may be multiple levels of
choice
statements without intervening
container
or
list
statements in the data model, the choice is represented as an array of
\fBconfd_value_t\fR
elements with the type C_XMLTAG, terminated by an element with the type C_NOEXISTS\&. This array gives a reversed path with alternating choice and case names, from the data node given by
\fIkp\fR
to the specific choice that the callback request pertains to \- similar to how a
\fBconfd_hkeypath_t\fR
gives a path through the data tree\&.
.sp
If we don\*(Aqt have such "nested" choices in the data model, we can ignore this array aspect, and just treat the
\fIchoice\fR
argument as a single
\fBconfd_value_t\fR
value\&. The case is always represented as a
\fBconfd_value_t\fR
with the type C_XMLTAG\&. I\&.e\&. we can use CONFD_GET_XMLTAG() to get the choice tag from
\fIchoice\fR
and CONFD_SET_XMLTAG() to set the case tag for the reply value\&. The callback should use
\fBconfd_data_reply_value()\fR
to return the case value to ConfD, or
\fBconfd_data_reply_not_found()\fR
for an optional choice without default case if no case is currently selected\&. If an optional choice with default case does not have a selected case, the callback should use
\fBconfd_data_reply_value()\fR
with a value of type C_DEFAULT\&.
.sp
Must return CONFD_OK on success, CONFD_ERR on error, or CONFD_DELAYED_RESPONSE\&.
.RE
.PP
\fBset_case()\fR
.RS 4
This callback is completely optional, and will only be invoked (if registered) if we use the YANG
choice
statement and provide configuration data\&. The callback sets the currently selected
case
for the choice given by the
\fIkp\fR
and
\fIchoice\fR
arguments, and is mainly intended to make it easier to support the
\fBget_case()\fR
callback\&. ConfD will additionally invoke the
\fBremove()\fR
callback for all nodes in the previously selected case, i\&.e\&. if we register
\fBset_case()\fR, we do not need to analyze
\fBset_elem()\fR
callbacks to determine the currently selected case, or figure out which nodes that should be deleted\&.
.sp
For a choice without a
mandatory true
statement, it is possible to have no case at all selected\&. To indicate that the previously selected case should be deleted without selecting another case, the callback will be invoked with NULL for the
\fIcaseval\fR
argument\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE\&.
.RE
.PP
\fBget_attrs()\fR
.RS 4
This callback only needs to be implemented for callpoints specified for configuration data, and only if attributes are enabled in the ConfD configuration (/confdConfig/enableAttributes
set to
\fBtrue\fR)\&. These are the currently supported attributes:
.sp
.if n \{\
.RS 4
.\}
.nf
/* CONFD_ATTR_TAGS: value is C_LIST of C_BUF/C_STR */
#define CONFD_ATTR_TAGS       0x80000000
/* CONFD_ATTR_ANNOTATION: value is C_BUF/C_STR */
#define CONFD_ATTR_ANNOTATION 0x80000001
/* CONFD_ATTR_INACTIVE: value is C_BOOL 1 (i\&.e\&. "true") */
#define CONFD_ATTR_INACTIVE   0x00000000
/* CONFD_ATTR_BACKPOINTER: value is C?LIST of C_BUF/C_STR */
#define CONFD_ATTR_BACKPOINTER 0x80000003


          
.fi
.if n \{\
.RE
.\}
The
\fIattrs\fR
parameter is an array of attributes of length
\fInum_attrs\fR, giving the requested attributes \- if
\fInum_attrs\fR
is 0, all attributes are requested\&. If the node given by
\fIkp\fR
does not exist, the callback should reply by calling
\fBconfd_data_reply_not_found()\fR, otherwise it should call
\fBconfd_data_reply_attrs()\fR, even if no attributes are set\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
It is very important to observe this distinction, i\&.e\&. to use
\fBconfd_data_reply_not_found()\fR
when the node doesn\*(Aqt exist, since ConfD may use
\fBget_attrs()\fR
as an existence check when attributes are enabled\&. (This avoids doing one callback request for existence check and another to collect the attributes\&.)
.sp .5v
.RE
Must return CONFD_OK on success, CONFD_ERR on error, or CONFD_DELAYED_RESPONSE\&.
.RE
.PP
\fBset_attr()\fR
.RS 4
This callback also only needs to be implemented for callpoints specified for configuration data, and only if attributes are enabled in the ConfD configuration (/confdConfig/enableAttributes
set to
\fBtrue\fR)\&. See
\fBget_attrs()\fR
above for the supported attributes\&.
.sp
The callback should set the attribute
\fIattr\fR
for the node given by
\fIkp\fR
to the value
\fIv\fR\&. If the callback is invoked with NULL for the value argument, it means that the attribute should be deleted\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE\&.
.RE
.PP
\fBmove_after()\fR
.RS 4
This callback only needs to be implemented if we provide configuration data that has YANG lists or leaf\-lists with a
ordered\-by user
statement\&. The callback moves the list entry or leaf\-list element given by
\fIkp\fR\&. If
\fIprevkeys\fR
is NULL, the entry/element is moved first in the list/leaf\-list, otherwise it is moved after the entry/element given by
\fIprevkeys\fR\&. In this case, for a list,
\fIprevkeys\fR
is a pointer to an array of key values identifying an entry in the list\&. The array is terminated with an element that has type C_NOEXISTS\&. For a leaf\-list,
\fIprevkeys\fR
is a pointer to an array with the leaf\-list element followed by an element that has type C_NOEXISTS\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE\&.
.RE
.PP
\fBwrite_all()\fR
.RS 4
This callback will only be invoked for a transaction hook specified with
tailf:invocation\-mode per\-transaction;
\- see the chapter
\m[blue]\fBTransformations, Hooks, Hidden Data and Symlinks\fR\m[]
in the User Guide\&. It is also the only callback that is invoked for such a hook\&. The callback is expected to make all the modifications to the current transaction that hook functionality requires\&. The
\fIkp\fR
parameter is currently always NULL, since the callback does not pertain to any particular data node\&.
.sp
The callback must return CONFD_OK on success, CONFD_ERR on error, or CONFD_DELAYED_RESPONSE\&.
.RE
.PP
The six write callbacks (excluding
\fBwrite_all()\fR), namely
\fBset_elem()\fR,
\fBcreate()\fR,
\fBremove()\fR,
\fBset_case()\fR,
\fBset_attr()\fR, and
\fBmove_after()\fR
may return the value CONFD_ACCUMULATE\&. If CONFD_ACCUMULATE is returned the library will accumulate the written values as a linked list of operations\&. This list can later be traversed in either of the transaction callbacks
\fBprepare()\fR
or
\fBcommit()\fR\&.
.PP
This provides trivial transaction support for applications that want to implement the ConfD two\-phase commit protocol but lacks an underlying database with proper transaction support\&. The write operations are available as a linked list of confd_tr_item structs:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_tr_item {
    char *callpoint;
    enum confd_tr_op op;
    confd_hkeypath_t *hkp;
    confd_value_t *val;
    confd_value_t *choice;  /* only for set_case */
    u_int32_t attr;         /* only for set_attr */
    struct confd_tr_item *next;
};
.fi
.if n \{\
.RE
.\}
.PP
The list is available in the transaction context in the field
\fIaccumulated\fR\&. The entire list and its content will be automatically freed by the library once the transaction finishes\&.
.nr wf \w'int\ confd_register_range_data_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_data_cbs\ *data,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *lower,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *upper,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_range_data_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_range_data_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_data_cbs\ *" "data" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This is a variant of
\fBconfd_register_data_cb()\fR
which registers a set of callbacks for a range of list entries\&. There can thus be multiple sets of C functions registered on the same callpoint, even by different daemons\&. The
\fIlower\fR
and
\fIupper\fR
parameters are two
\fInumkeys\fR
long arrays of key values, which define the endpoints of the list range\&. It is also possible to do a "default" registration, by giving
\fIlower\fR
and
\fIupper\fR
as NULL (\fInumkeys\fR
is ignored)\&. The callbacks for the default registration will be invoked when the keys are not in any of the explicitly registered ranges\&.
.PP
The
\fIfmt\fR
and remaining parameters specify a string path for the list that the keys apply to, in the same form as for the
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]
and
\m[blue]\fBconfd_lib_cdb(3)\fR\m[]
functions\&. However if the list is a sublist to another list, the key element for the parent list(s) may be completely omitted, to indicate that the registration applies to all entries for the parent list(s) (similar to CDB subscription paths)\&.
.PP
An example that registers one set of callbacks for the range
/servers/server{aaa}
\-
/servers/server{mzz}
and another set for
/servers/server{naa}
\-
/servers/server{zzz}:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_value_t lower, upper;

CONFD_SET_STR(&lower, "aaa");
CONFD_SET_STR(&upper, "mzz");
if (confd_register_range_data_cb(dctx, &data_cb1, &lower, &upper, 1,
                                 "/servers/server") == CONFD_ERR)
    confd_fatal("Failed to register data cb\en");

CONFD_SET_STR(&lower, "naa");
CONFD_SET_STR(&upper, "zzz");
if (confd_register_range_data_cb(dctx, &data_cb2, &lower, &upper, 1,
                                 "/servers/server") == CONFD_ERR)
    confd_fatal("Failed to register data cb\en");
.fi
.if n \{\
.RE
.\}
.PP
In this example, as in most cases where this function is used, the data model defines a list with a single key, and
\fInumkeys\fR
is thus always
\fB1\fR\&. However it can also be used for lists that have multiple keys, in which case the
\fIupper\fR
and
\fIlower\fR
arrays may be populated with multiple keys, upto however many keys the data model specifies for the list, and
\fInumkeys\fR
gives the number of keys in the arrays\&. If fewer keys than specified in the data model are given, the registration covers all possible values for the remaining keys, i\&.e\&. they are effectively wildcarded\&.
.PP
While traversal of a list with range registrations will always invoke e\&.g\&.
\fBget_next()\fR
only for actually registered ranges, it is also possible that a request from a northbound interface is made for data in a specific list entry\&. If the registrations do not cover all possible key values, such a request could be for a list entry that does not fall in any of the registered ranges, which will result in a "no registration" error\&. To avoid the error, we can either restrict the type of the keys such that only values that fall in the registered ranges are valid, or, for operational data, use a "default" registration as described above\&. In this case the daemon with the "default" registration would just reply with
\fBconfd_data_reply_not_found()\fR
for all requests for specific data, and
\fBconfd_data_reply_next_key()\fR
with NULL for the key values for all
\fBget_next()\fR
etc requests\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
For a given callpoint name, there can only be either one non\-range registration or a number of range registrations that all pertain to the same list\&. If a range registration is done after a non\-range registration or vice versa, or if a range registration is done with a different list path than earlier range registrations, the latest registration completely replaces the earlier one(s)\&. If we want to register for the same ranges in different lists, we must thus have a unique callpoint for each list\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Range registrations can not be used for lists that have the
tailf:secondary\-index
extension, since there is no way for ConfD to traverse the registrations in secondary\-index order\&.
.sp .5v
.RE
.nr wf \w'int\ confd_register_usess_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_usess_cbs\ *ucb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_usess_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_usess_cbs\ *" "ucb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_usess_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_usess_cbs\ *" "ucb" ");" \}
.PP
This function can be used to register information callbacks that are invoked for user session start and stop\&. The
\fBstruct confd_usess_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_usess_cbs {
    void (*start)(struct confd_daemon_ctx *dx,
                  struct confd_user_info *uinfo);
    void (*stop)(struct confd_daemon_ctx *dx,
                 struct confd_user_info *uinfo);
};
.fi
.if n \{\
.RE
.\}
.PP
Both callbacks are optional\&. They can be used e\&.g\&. for a multi\-threaded daemon to manage a pool of worker threads, by allocating worker threads to user sessions\&. In this case we would ideally allocate a worker thread the first time an
\fBinit()\fR
callback for a given user session requires a worker socket to be assigned, and use only the
\fBstop()\fR
usess callback to release the worker thread \- using the
\fBstart()\fR
callback to allocate a worker thread would often mean that we allocated a thread that was never used\&. The
\fIu_opaque\fR
element in the
\fBstruct confd_user_info\fR
can be used to manage such allocations\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
These callbacks will only be invoked if the daemon has also registered other callbacks\&. Furthermore, as an optimization, ConfD will delay the invocation of the
\fBstart()\fR
callback until some other callback is invoked\&. This means that if no other callbacks for the daemon are invoked for the duration of a user session, neither
\fBstart()\fR
nor
\fBstop()\fR
will be invoked for that user session\&. If we want timely notification of start and stop for all user sessions, we can subscribe to
\fBCONFD_NOTIF_AUDIT\fR
events, see
\m[blue]\fBconfd_lib_events(3)\fR\m[]\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
When we call
\fBconfd_register_done()\fR
(see below), the
\fBstart()\fR
callback (if registered) will be invoked for each user session that already exists\&.
.sp .5v
.RE
.nr wf \w'int\ confd_register_done('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_done("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_done(struct\ confd_daemon_ctx\ *" "dx" ");" \}
.PP
When we have registered all the callbacks for a daemon (including the other types described below if we have them), we must call this function to synchronize with ConfD\&. No callbacks will be invoked until it has been called, and after the call, no further registrations are allowed\&.
.nr wf \w'int\ confd_fd_ready('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ fd);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_fd_ready("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_fd_ready(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ");" \}
.PP
The database application owns all data provider sockets to ConfD and is responsible for the polling of these sockets\&. When one of the ConfD sockets has I/O ready to read, the application must invoke
\fBconfd_fd_ready()\fR
on the socket\&. This function will:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Read data from ConfD
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Unmarshal this data
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Invoke the right callback with the right arguments
.RE
.PP
When this function reads the request from from ConfD it will block on
\fBread()\fR, thus if it is important for the application to have nonblocking I/O, the application must dispatch I/O from ConfD in a separate thread\&.
.PP
The function returns the return value from the callback function, normally CONFD_OK (0), or CONFD_ERR (\-1) on error and CONFD_EOF (\-2) when the socket to ConfD has been closed\&. Thus CONFD_ERR can mean either that the callback function that was invoked returned CONFD_ERR, or that some error condition occurred within the
\fBconfd_fd_ready()\fR
function\&. These cases can be distinguished via
\fIconfd_errno\fR, which will be set to CONFD_ERR_EXTERNAL if CONFD_ERR comes from the callback function\&. Thus a correct call to
\fBconfd_fd_ready()\fR
looks like:
.sp
.if n \{\
.RS 4
.\}
.nf
struct pollfd set[n];
/* \&.\&.\&.\&.\&.\&. */

if (set[0]\&.revents & POLLIN) {
    if ((ret = confd_fd_ready(dctx, mysock)) == CONFD_EOF) {
        confd_fatal("ConfD socket closed\en");
    } else if (ret == CONFD_ERR &&
               confd_errno != CONFD_ERR_EXTERNAL) {
        confd_fatal("Error on ConfD socket request: %s (%d): %s\en",
                    confd_strerror(confd_errno), confd_errno,
                    confd_lasterr());
    }
}
.fi
.if n \{\
.RE
.\}
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_PROTOUSAGE, CONFD_ERR_EXTERNAL
.nr wf \w'void\ confd_trans_set_fd('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_trans_set_fd("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_trans_set_fd(struct\ confd_trans_ctx\ *" "tctx" ", int\ " "sock" ");" \}
.PP
Associate a worker socket with the transaction, or validation phase\&. This function must be called in the transaction and validation
\fBinit()\fR
callbacks \- a minimal implementation of a transaction
\fBinit()\fR
callback looks like:
.sp
.if n \{\
.RS 4
.\}
.nf
static int init(struct confd_trans_ctx *tctx)
{
    confd_trans_set_fd(tctx, workersock);
    return CONFD_OK;
}
.fi
.if n \{\
.RE
.\}
.nr wf \w'int\ confd_data_reply_value('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *v);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_value("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_value(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ");" \}
.PP
This function is used to return a single data item to ConfD\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ confd_data_reply_value_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *vs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_value_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "vs" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_value_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "vs" ", int\ " "n" ");" \}
.PP
This function is used to return an array of values, corresponding to a complete list entry, to ConfD\&. It can be used by the optional
\fBget_object()\fR
callback\&. The
\fIvs\fR
array is populated with
\fIn\fR
values according to the specification of the Value Array format in the
\m[blue]\fBXML STRUCTURES\fR\m[]
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
In the easiest case, similar to the "servers" example above, we can construct a reply array as follows:
.sp
.if n \{\
.RS 4
.\}
.nf
struct in_addr ip4 = my_get_ip(\&.\&.\&.\&.\&.);
confd_value_t ret[3];

CONFD_SET_STR(&ret[0], "www");
CONFD_SET_IPV4(&ret[1], ip4);
CONFD_SET_UINT16(&ret[2], 80);
confd_data_reply_value_array(tctx, ret, 3);
.fi
.if n \{\
.RE
.\}
.PP
Any containers inside the object must also be passed in the array\&. For example an entry in the
b
list used in the explanation for
\fBexists_optional()\fR
would have to be passed as:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_value_t ret[4];

CONFD_SET_STR(&ret[0], "b_name");
CONFD_SET_XMLTAG(&ret[1], myprefix_opt, myprefix__ns);
CONFD_SET_INT32(&ret[2], 77);
CONFD_SET_NOEXISTS(&ret[3]);

confd_data_reply_value_array(tctx, ret, 4);
.fi
.if n \{\
.RE
.\}
.PP
Thus, a container or a leaf of type
empty
must be passed as its equivalent XML tag if it exists\&. If a
presence
container or leaf of type
empty
does not exist, it must be passed as a value of C_NOEXISTS\&. In the example above, the leaf
foo
does not exist, thus the contents of position
\fB3\fR
in the array\&.
.PP
If a
presence
container does not exist, its non existing values must not be passed \- it suffices to say that the container itself does not exist\&. In the example above, the
opt
container did exist and thus we also had to pass the contained value(s), the
ii
leaf\&.
.PP
Hence, the above example represents:
.sp
.if n \{\
.RS 4
.\}
.nf
<b>
   <name>b_name</name>
   <opt>
      <ii>77</ii>
   </opt>
</b>
.fi
.if n \{\
.RE
.\}
.nr wf \w'int\ confd_data_reply_tag_value_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *tvs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_tag_value_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tvs" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_tag_value_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tvs" ", int\ " "n" ");" \}
.PP
This function is used to return an array of values, corresponding to a complete list entry, to ConfD\&. It can be used by the optional
\fBget_object()\fR
callback\&. The
\fItvs\fR
array is populated with
\fIn\fR
values according to the specification of the Tagged Value Array format in the
\m[blue]\fBXML STRUCTURES\fR\m[]
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
I\&.e\&. the difference from
\fBconfd_data_reply_value_array()\fR
is that the values are tagged with the node names from the data model \- this means that non\-existing values can simply be omitted from the array, per the specification above\&. Additionally the key leafs can be omitted, since they are already known by ConfD \- if the key leafs are included, they will be ignored\&. Finally, in e\&.g\&. the case of a container with both config and non\-config data, where the config data is in CDB and only the non\-config data provided by the callback, the config elements can be omitted (for
\fBconfd_data_reply_value_array()\fR
they must be included as C_NOEXISTS elements)\&.
.PP
However, although the tagged value array format can represent nested lists, these must not be passed via this function, since the
\fBget_object()\fR
callback only pertains to a single entry of one list\&. Nodes representing sub\-lists must thus be omitted from the array, and ConfD will issue separate
\fBget_object()\fR
invocations to retrieve the data for those\&.
.PP
Using the same examples as above, in the "servers" case, we can construct a reply array as follows:
.sp
.if n \{\
.RS 4
.\}
.nf
struct in_addr ip4 = my_get_ip(\&.\&.\&.\&.\&.);
confd_tag_value_t ret[2];
int n = 0;

CONFD_SET_TAG_IPV4(&ret[n], myprefix_ip, ip4); n++;
CONFD_SET_TAG_UINT16(&ret[n], myprefix_port, 80); n++;
confd_data_reply_tag_value_array(tctx, ret, n);
.fi
.if n \{\
.RE
.\}
.PP
An entry in the
b
list used in the explanation for
\fBexists_optional()\fR
would be passed as:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_tag_value_t ret[3];
int n = 0;

CONFD_SET_TAG_XMLBEGIN(&ret[n], myprefix_opt, myprefix__ns); n++;
CONFD_SET_TAG_INT32(&ret[n], myprefix_ii, 77); n++;
CONFD_SET_TAG_XMLEND(&ret[n], myprefix_opt, myprefix__ns); n++;
confd_data_reply_tag_value_array(tctx, ret, n);
.fi
.if n \{\
.RE
.\}
.PP
The C_XMLEND element is not strictly necessary in this case, since there are no subsequent elements in the array\&. However it would have been required if the optional
foo
leaf had existed, thus it is good practice to always include both the C_XMLBEGIN and C_XMLEND elements for nested containers (if they exist, that is \- otherwise neither must be included)\&.
.nr wf \w'int\ confd_data_reply_next_key('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_vals_in_key,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'long\ next);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_key("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "num_vals_in_key" ", long\ " "next" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_key(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "num_vals_in_key" ", long\ " "next" ");" \}
.PP
This function is used by the
\fBget_next()\fR
and
\fBfind_next()\fR
callbacks to return the next key, or the next leaf\-list element in case
\fBget_next()\fR
is invoked for a leaf\-list\&. A list may have multiple key leafs specified in the data model\&. The parameter
\fInum_vals_in_key\fR
indicates the number of key values, i\&.e\&. the length of the
\fIv\fR
array\&. In the typical case with a list having just a single key leaf specified,
\fInum_vals_in_key\fR
is always 1\&. For a leaf\-list,
\fInum_vals_in_key\fR
is always 1\&.
.PP
The
\fIlong next\fR
will be passed into the next invocation of the
\fBget_next()\fR
callback if it has a value other than
\fB\-1\fR\&. Thus this value provides a means for the application to traverse the data\&. Since this is
\fBlong\fR
it is possible to pass a
\fBvoid*\fR
pointing to the next list entry in the application \- effectively passing a pointer to confd and getting it back in the next invocation of
\fBget_next()\fR\&.
.PP
To indicate that no more entries exist, we reply with a NULL pointer for the
\fIv\fR
array\&. The values of the
\fInum_vals_in_key\fR
and
\fInext\fR
parameters are ignored in this case\&.
.PP
Passing the value
\fB\-1\fR
for
\fInext\fR
has a special meaning\&. It tells ConfD that we want the next request for this list traversal to use the
\fBfind_next()\fR
(or
\fBfind_next_object()\fR) callback instead of
\fBget_next()\fR
(or
\fBget_next_object()\fR)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
In the case of list traversal by means of a secondary index, the secondary index values must be unique for entry\-by\-entry traversal with
\fBfind_next()\fR/\fBfind_next_object()\fR
to be possible\&. Thus we can not pass
\fB\-1\fR
for the
\fInext\fR
parameter in this case if the secondary index values are not unique\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ confd_data_reply_not_found('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_not_found("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_not_found(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.PP
This function is used by the
\fBget_elem()\fR
and
\fBexists_optional()\fR
callbacks to indicate to ConfD that a list entry or node does not exist\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ confd_data_reply_found('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_found("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_found(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.PP
This function is used by the
\fBexists_optional()\fR
callback to indicate to ConfD that a node does exist\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ confd_data_reply_next_object_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'long\ next);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "n" ", long\ " "next" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_value_t\ *" "v" ", int\ " "n" ", long\ " "next" ");" \}
.PP
This function is used by the optional
\fBget_next_object()\fR
and
\fBfind_next_object()\fR
callbacks to return an entire object including its keys, as well as the
\fInext\fR
parameter that has the same function as for
\fBconfd_data_reply_next_key()\fR\&. It combines the functions of
\fBconfd_data_reply_next_key()\fR
and
\fBconfd_data_reply_value_array()\fR\&.
.PP
The array of
\fBconfd_value_t\fR
elements must be populated in exactly the same manner as for
\fBconfd_data_reply_value_array()\fR
and the
\fIlong next\fR
is used in the same manner as the equivalent
\fInext\fR
parameter in
\fBconfd_data_reply_next_key()\fR\&. To indicate the end of the list we \- similar to
\fBconfd_data_reply_next_key()\fR
\- pass a NULL pointer for the value array\&.
.PP
If we are replying to a
\fBget_next_object()\fR
or
\fBfind_next_object()\fR
request for an operational data list without keys (see the
\m[blue]\fBOperational Data chapter in the User Guide\fR\m[]), we must include the "pseudo" key in the array, as the first element (i\&.e\&. preceding the actual leafs from the data model)\&.
.PP
If we are replying to a
\fBget_next_object()\fR
request for a leaf\-list, we must pass the value of the leaf\-list element as the only element in the array\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ confd_data_reply_next_object_tag_value_array('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *tv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'long\ next);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_tag_value_array("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tv" ", int\ " "n" ", long\ " "next" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_tag_value_array(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_tag_value_t\ *" "tv" ", int\ " "n" ", long\ " "next" ");" \}
.PP
This function is used by the optional
\fBget_next_object()\fR
and
\fBfind_next_object()\fR
callbacks to return an entire object including its keys, as well as the
\fInext\fR
parameter that has the same function as for
\fBconfd_data_reply_next_key()\fR\&. It combines the functions of
\fBconfd_data_reply_next_key()\fR
and
\fBconfd_data_reply_tag_value_array()\fR\&.
.PP
Similar to how the
\fBconfd_data_reply_value_array()\fR
has its companion function
\fBconfd_data_reply_tag_value_array()\fR
if we want to return an object as an array of
\fBconfd_tag_value_t\fR
values instead of an array of
\fBconfd_value_t\fR
values, we can use this function instead of
\fBconfd_data_reply_next_object_array()\fR
when we wish to return values from the
\fBget_next_object()\fR
callback\&.
.PP
The array of
\fBconfd_tag_value_t\fR
elements must be populated in exactly the same manner as for
\fBconfd_data_reply_tag_value_array()\fR
(except that the key values must be included), and the
\fIlong next\fR
is used in the same manner as the equivalent
\fInext\fR
parameter in
\fBconfd_data_reply_next_key()\fR\&. The key leafs must always be given as the first elements of the array, and in the order specified in the data model\&. To indicate the end of the list we \- similar to
\fBconfd_data_reply_next_key()\fR
\- pass a NULL pointer for the value array\&.
.PP
If we are replying to a
\fBget_next_object()\fR
or
\fBfind_next_object()\fR
request for an operational data list without keys (see the
\m[blue]\fBOperational Data chapter in the User Guide\fR\m[]), the "pseudo" key must be included, as the first element in the array, with a tag value of 0 \- i\&.e\&. it can be set with code like this:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_tag_value_t tv[7];

CONFD_SET_TAG_INT64(&tv[0], 0, 42);
.fi
.if n \{\
.RE
.\}
.PP
Similarly, if we are replying to a
\fBget_next_object()\fR
request for a leaf\-list, we must pass the value of the leaf\-list element as the only element in the array, with a tag value of 0\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ confd_data_reply_next_object_arrays('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_next_object\ *obj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_millisecs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_arrays("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_next_object\ *" "obj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_arrays(struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_next_object\ *" "obj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.PP
This function is used by the optional
\fBget_next_object()\fR
and
\fBfind_next_object()\fR
callbacks to return multiple objects including their keys, in
\fBconfd_value_t\fR
form\&. The
\fBstruct confd_next_object\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_next_object {
    confd_value_t *v;
    int n;
    long next;
};
.fi
.if n \{\
.RE
.\}
.PP
I\&.e\&. it corresponds exactly to the data provided for a call of
\fBconfd_data_reply_next_object_array()\fR\&. The parameter
\fIobj\fR
is a pointer to an
\fInobj\fR
elements long array of such structs\&. We can also pass a timeout value for ConfD\*(Aqs caching of the returned data via
\fItimeout_millisecs\fR\&. If we pass 0 for this parameter, the value configured via
/confdConfig/capi/objectCacheTimeout
in
confd\&.conf
(see
\m[blue]\fBconfd\&.conf(5)\fR\m[]) will be used\&.
.PP
The cache in ConfD may become invalid (e\&.g\&. due to timeout) before all the returned list entries have been used, and ConfD may then need to issue a new callback request based on an "intermediate"
\fInext\fR
value\&. This is done exactly as for the single\-entry case, i\&.e\&. if
\fInext\fR
is
\fB\-1\fR,
\fBfind_next_object()\fR
(or
\fBfind_next()\fR) will be used, with the keys from the "previous" entry, otherwise
\fBget_next_object()\fR
(or
\fBget_next()\fR) will be used, with the given
\fInext\fR
value\&.
.PP
Thus a data provider can choose to give
\fInext\fR
values that uniquely identify list entries if that is convenient, or otherwise use
\fB\-1\fR
for all
\fInext\fR
elements \- or a combination, e\&.g\&.
\fB\-1\fR
for all but the last entry\&. If any
\fInext\fR
value is given as
\fB\-1\fR, at least one of the
\fBfind_next()\fR
and
\fBfind_next_object()\fR
callbacks must be registered\&.
.PP
To indicate the end of the list we can either pass a NULL pointer for the
\fIobj\fR
array, or pass an array where the last
\fBstruct confd_next_object\fR
element has the
\fIv\fR
element set to NULL\&. The latter is preferable, since we can then combine the final list entries with the end\-of\-list indication in the reply to a single callback invocation\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
When
\fInext\fR
values other than
\fB\-1\fR
are used, these must remain valid even after the end of the list has been reached, since ConfD may still need to issue a new callback request based on an "intermediate"
\fInext\fR
value as described above\&. They can be discarded (e\&.g\&. allocated memory released) when a new
\fBget_next_object()\fR
or
\fBfind_next_object()\fR
callback request for the same list in the same transaction has been received, or at the end of the transaction\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
In the case of list traversal by means of a secondary index, the secondary index values must be unique for entry\-by\-entry traversal with
\fBfind_next_object()\fR/\fBfind_next()\fR
to be possible\&. Thus we can not use
\fB\-1\fR
for the
\fInext\fR
element in this case if the secondary index values are not unique\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ confd_data_reply_next_object_tag_value_arrays('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_tag_next_object\ *tobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_millisecs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_next_object_tag_value_arrays("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_tag_next_object\ *" "tobj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_next_object_tag_value_arrays(struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ confd_tag_next_object\ *" "tobj" ", int\ " "nobj" ", int\ " "timeout_millisecs" ");" \}
.PP
This function is used by the optional
\fBget_next_object()\fR
and
\fBfind_next_object()\fR
callbacks to return multiple objects including their keys, in
\fBconfd_tag_value_t\fR
form\&. The
\fBstruct confd_tag_next_object\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_tag_next_object {
    confd_tag_value_t *tv;
    int n;
    long next;
};
.fi
.if n \{\
.RE
.\}
.PP
I\&.e\&. it corresponds exactly to the data provided for a call of
\fBconfd_data_reply_next_object_tag_value_array()\fR\&. The parameter
\fItobj\fR
is a pointer to an
\fInobj\fR
elements long array of such structs\&. We can also pass a timeout value for ConfD\*(Aqs caching of the returned data via
\fItimeout_millisecs\fR\&. If we pass 0 for this parameter, the value configured via
/confdConfig/capi/objectCacheTimeout
in
confd\&.conf
(see
\m[blue]\fBconfd\&.conf(5)\fR\m[]) will be used\&.
.PP
The cache in ConfD may become invalid (e\&.g\&. due to timeout) before all the returned list entries have been used, and ConfD may then need to issue a new callback request based on an "intermediate"
\fInext\fR
value\&. This is done exactly as for the single\-entry case, i\&.e\&. if
\fInext\fR
is
\fB\-1\fR,
\fBfind_next_object()\fR
(or
\fBfind_next()\fR) will be used, with the keys from the "previous" entry, otherwise
\fBget_next_object()\fR
(or
\fBget_next()\fR) will be used, with the given
\fInext\fR
value\&.
.PP
Thus a data provider can choose to give
\fInext\fR
values that uniquely identify list entries if that is convenient, or otherwise use
\fB\-1\fR
for all
\fInext\fR
elements \- or a combination, e\&.g\&.
\fB\-1\fR
for all but the last entry\&. If any
\fInext\fR
value is given as
\fB\-1\fR, at least one of the
\fBfind_next()\fR
and
\fBfind_next_object()\fR
callbacks must be registered\&.
.PP
To indicate the end of the list we can either pass a NULL pointer for the
\fItobj\fR
array, or pass an array where the last
\fBstruct confd_tag_next_object\fR
element has the
\fItv\fR
element set to NULL\&. The latter is preferable, since we can then combine the final list entries with the end\-of\-list indication in the reply to a single callback invocation\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
When
\fInext\fR
values other than
\fB\-1\fR
are used, these must remain valid even after the end of the list has been reached, since ConfD may still need to issue a new callback request based on an "intermediate"
\fInext\fR
value as described above\&. They can be discarded (e\&.g\&. allocated memory released) when a new
\fBget_next_object()\fR
or
\fBfind_next_object()\fR
callback request for the same list in the same transaction has been received, or at the end of the transaction\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
In the case of list traversal by means of a secondary index, the secondary index values must be unique for entry\-by\-entry traversal with
\fBfind_next_object()\fR/\fBfind_next()\fR
to be possible\&. Thus we can not use
\fB\-1\fR
for the
\fInext\fR
element in this case if the secondary index values are not unique\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ confd_data_reply_attrs('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_attr_value_t\ *attrs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attrs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_reply_attrs("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_attr_value_t\ *" "attrs" ", int\ " "num_attrs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_reply_attrs(struct\ confd_trans_ctx\ *" "tctx" ", const\ confd_attr_value_t\ *" "attrs" ", int\ " "num_attrs" ");" \}
.PP
This function is used by the
\fBget_attrs()\fR
callback to return the requested attribute values\&. The
\fIattrs\fR
array should be populated with
\fInum_attrs\fR
elements of type
\fBconfd_attr_value_t\fR, which is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
typedef struct confd_attr_value {
    u_int32_t attr;
    confd_value_t v;
} confd_attr_value_t;
.fi
.if n \{\
.RE
.\}
.PP
If multiple attributes were requested in the callback invocation, they should be given in the same order in the reply as in the request\&. Requested attributes that are not set should be omitted from the array\&. If none of the requested attributes are set, or no attributes at all are set when all attributes are requested,
\fInum_attrs\fR
should be given as 0, and the value of
\fIattrs\fR
is ignored\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ confd_delayed_reply_ok('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_delayed_reply_ok("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_delayed_reply_ok(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.PP
This function must be used to return the equivalent of CONFD_OK when the actual callback returned CONFD_DELAYED_RESPONSE\&. I\&.e\&. it is appropriate for a transaction callback, a data callback for a write operation, or a validation callback, when the result is successful\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ confd_delayed_reply_error('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *errstr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_delayed_reply_error("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "errstr" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_delayed_reply_error(struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "errstr" ");" \}
.PP
This function must be used to return an error when the actual callback returned CONFD_DELAYED_RESPONSE\&. There are two cases where the value of
\fIerrstr\fR
has a special significance:
.PP
"locked" after invocation of \fBtrans_lock()\fR
.RS 4
This is equivalent to returning CONFD_ALREADY_LOCKED from the callback\&.
.RE
.PP
"in_use" after invocation of \fBwrite_start()\fR or \fBprepare()\fR
.RS 4
This is equivalent to returning CONFD_IN_USE from the callback\&.
.RE
.PP
In all other cases, calling
\fBconfd_delayed_reply_error()\fR
is equivalent to calling
\fBconfd_trans_seterr()\fR
with the
\fIerrstr\fR
value and returning CONFD_ERR from the callback\&. It is also possible to first call
\fBconfd_trans_seterr()\fR
(for the varargs format) or
\fBconfd_trans_seterr_extended()\fR
etc (for
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
as described in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]), and then call
\fBconfd_delayed_reply_error()\fR
with NULL for
\fIerrstr\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ confd_data_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_data_set_timeout("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_data_set_timeout(struct\ confd_trans_ctx\ *" "tctx" ", int\ " "timeout_secs" ");" \}
.PP
A data callback should normally complete "quickly", since e\&.g\&. the execution of a \*(Aqshow\*(Aq command in the CLI may require many data callback invocations\&. Thus it should be possible to set the
/confdConfig/capi/queryTimeout
in
confd\&.conf
(see above) such that it covers the longest possible execution time for any data callback\&. In some rare cases it may still be necessary for a data callback to have a longer execution time, and then this function can be used to extend (or shorten) the timeout for the current callback invocation\&. The timeout is given in seconds from the point in time when the function is called\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'void\ confd_trans_seterr('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_trans_seterr("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_trans_seterr(struct\ confd_trans_ctx\ *" "tctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function is used by the application to set an error string\&. The next transaction or data callback which returns CONFD_ERR will have this error description attached to it\&. This error may propagate to the CLI, the NETCONF manager, the Web UI or the log files depending on the situation\&. We also use this function to propagate warning messages from the
\fBvalidate()\fR
callback if we are doing semantic validation in C\&. The
\fIfmt\fR
argument is a printf style format string\&.
.nr wf \w'void\ confd_trans_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_trans_seterr_extended("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_trans_seterr_extended(struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide more structured error information from a transaction or data callback, see the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ confd_trans_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_trans_seterr_extended_info("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_trans_seterr_extended_info(struct\ confd_trans_ctx\ *" "tctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide structured error information in the same way as
\fBconfd_trans_seterr_extended()\fR, and additionally provide contents for the NETCONF <error\-info> element\&. See the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'void\ confd_db_seterr('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_db_seterr("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_db_seterr(struct\ confd_db_ctx\ *" "dbx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function is used by the application to set an error string\&. The next db callback function which returns CONFD_ERR will have this error description attached to it\&. This error may propagate to the CLI, the NETCONF manager, the Web UI or the log files depending on the situation\&. The
\fIfmt\fR
argument is a printf style format string\&.
.nr wf \w'void\ confd_db_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_db_seterr_extended("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_db_seterr_extended(struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide more structured error information from a db callback, see the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ confd_db_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_db_seterr_extended_info("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_db_seterr_extended_info(struct\ confd_db_ctx\ *" "dbx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide structured error information in the same way as
\fBconfd_db_seterr_extended()\fR, and additionally provide contents for the NETCONF <error\-info> element\&. See the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ confd_db_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_db_ctx\ *dbx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_db_set_timeout("
.br
.BI "struct\ confd_db_ctx\ *" "dbx" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_db_set_timeout(struct\ confd_db_ctx\ *" "dbx" ", int\ " "timeout_secs" ");" \}
.PP
Some of the DB callbacks registered via
\fBconfd_register_db_cb()\fR, e\&.g\&.
\fBcopy_running_to_startup()\fR, may require a longer execution time than others, and in these cases the timeout specified for
/confdConfig/capi/newSessionTimeout
may be insufficient\&. This function can then be used to extend the timeout for the current callback invocation\&. The timeout is given in seconds from the point in time when the function is called\&.
.nr wf \w'int\ confd_aaa_reload('
.nr wm 0
.nr wp \w'const\ struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_aaa_reload("
.br
.BI "const\ struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_aaa_reload(const\ struct\ confd_trans_ctx\ *" "tctx" ");" \}
.PP
When the ConfD AAA tree is populated by an external data provider (see the
\m[blue]\fBAAA chapter in the User Guide\fR\m[]), this function can be used by the data provider to notify ConfD when there is a change to the AAA data\&. I\&.e\&. it is an alternative to executing the command
\fBconfd \-\-clear\-aaa\-cache\fR\&. See also
\fBmaapi_aaa_reload()\fR
in
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]\&.
.nr wf \w'int\ confd_install_crypto_keys('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx*\ dtx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_install_crypto_keys("
.br
.BI "struct\ confd_daemon_ctx*\ " "dtx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_install_crypto_keys(struct\ confd_daemon_ctx*\ " "dtx" ");" \}
.PP
It is possible to define DES3 and AES keys inside confd\&.conf\&. These keys are used by ConfD to encrypt data which is entered into the system which has either of the two builtin types
\fBtailf:des3\-cbc\-encrypted\-string\fR
or
\fBtailf:aes\-cfb\-128\-encrypted\-string\fR\&. See
\m[blue]\fBconfd_types(3)\fR\m[]\&.
.PP
This function will copy those keys from ConfD (which reads confd\&.conf) into memory in the library\&. The parameter
\fIdtx\fR
is a daemon context which is connected through a call to
\fBconfd_connect()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
The function must be called before
\fBconfd_register_done()\fR
is called\&. If this is impractical, or if the application doesn\*(Aqt otherwise use a daemon context, the equivalent function
\fBmaapi_install_crypto_keys()\fR
may be more convenient to use, see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]\&.
.sp .5v
.RE
.SH "NCS SERVICE CALLBACKS"
.PP
NCS service callbacks are invoked in a manner similar to the data callbacks described above, but require a registration for a service point, specified as
ncs:servicepoint
in the data model\&. The
\fBinit()\fR
transaction callback must also be registered, and must use the
\fBconfd_trans_set_fd()\fR
function to assign a worker socket for the transaction\&.
.nr wf \w'int\ ncs_register_service_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_service_cbs\ *scb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int ncs_register_service_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ ncs_service_cbs\ *" "scb" ");" \}
.el \{\
.HP \n(wfu
.BI "int ncs_register_service_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ ncs_service_cbs\ *" "scb" ");" \}
.PP
This function registers the service callbacks\&. The
\fBstruct ncs_service_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct ncs_name_value {
    char *name;
    char *value;
};
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
enum ncs_service_operation {
    NCS_SERVICE_CREATE = 0,
    NCS_SERVICE_UPDATE = 1,
    NCS_SERVICE_DELETE = 2
};
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
struct ncs_service_cbs {
    char servicepoint[MAX_CALLPOINT_LEN];

    int (*pre_modification)(struct confd_trans_ctx *tctx,
                            enum ncs_service_operation op,
                            confd_hkeypath_t *kp,
                            struct ncs_name_value *proplist,
                            int num_props);
    int (*pre_lock_create)(struct confd_trans_ctx *tctx,
                           confd_hkeypath_t *kp,
                           struct ncs_name_value *proplist,
                           int num_props, int fastmap_thandle);
    int (*create)(struct confd_trans_ctx *tctx, confd_hkeypath_t *kp,
                  struct ncs_name_value *proplist, int num_props,
                  int fastmap_thandle);
    int (*post_modification)(struct confd_trans_ctx *tctx,
                             enum ncs_service_operation op,
                             confd_hkeypath_t *kp,
                             struct ncs_name_value *proplist,
                             int num_props);
    void *cb_opaque; /* private user data    */
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fBcreate()\fR
callback is invoked inside NCS FASTMAP when creation or update of a service instance is committed\&. It should attach to the FASTMAP transaction by means of
\fBmaapi_attach2()\fR
(see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]), passing the
\fIfastmap_thandle\fR
transaction handle as the
\fIthandle\fR
parameter to
\fBmaapi_attach2()\fR\&. The
\fIusid\fR
parameter for
\fBmaapi_attach2()\fR
should be given as 0\&. To modify data in the FASTMAP transaction, the NCS\-specific
\fBmaapi_shared_xxx()\fR
functions must be used, see the section
\m[blue]\fBNCS SPECIFIC FUNCTIONS\fR\m[]
in the
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]
manual page\&.
.PP
The
\fBpre_lock_create()\fR
callback is invoked in the same way as the
\fBcreate()\fR
callback\&. The difference is that this callback is invoked outside the transaction lock of the current transaction, and may thus run in parallel with
\fBpre_lock_create()\fR
invocations in other transactions\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
A service can only register one of the two functions
\fBcreate()\fR
and
\fBpre_lock_create()\fR
.sp .5v
.RE
.PP
The
\fBpre_modification()\fR
and
\fBpost_modification()\fR
callbacks are optional, and are invoked outside FASTMAP\&.
\fBpre_modification()\fR
is invoked before create, update, or delete of the service, as indicated by the
\fIenum ncs_service_operation op\fR
parameter\&. Conversely
\fBpost_modification()\fR
is invoked after create, update, or delete of the service\&. These functions can be useful e\&.g\&. for allocations that should be stored and existing also when the service instance is removed\&.
.PP
All the callbacks receive a property list via the
\fIproplist\fR
and
\fInum_props\fR
parameters\&. This list is initially empty (\fIproplist\fR
== NULL and
\fInum_props\fR
== 0), but it can be used to store and later modify persistent data outside the service model that might be needed\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
We must call the
\fBconfd_register_done()\fR
function when we are done with all registrations for a daemon, see above\&.
.sp .5v
.RE
.nr wf \w'int\ ncs_service_reply_proplist('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_name_value\ *proplist,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_props);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int ncs_service_reply_proplist("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ ncs_name_value\ *" "proplist" ", int\ " "num_props" ");" \}
.el \{\
.HP \n(wfu
.BI "int ncs_service_reply_proplist(struct\ confd_trans_ctx\ *" "tctx" ", const\ struct\ ncs_name_value\ *" "proplist" ", int\ " "num_props" ");" \}
.PP
This function must be called with the new property list, immediately prior to returning from the callback, if the stored property list should be updated\&. If a callback returns without calling
\fBncs_service_reply_proplist()\fR, the previous property list is retained\&. To completely delete the property list, call this function with the
\fInum_props\fR
parameter given as 0\&.
.SH "VALIDATION CALLBACKS"
.PP
This library also supports the registration of callback functions on validation points in the data model\&. A validation point is a point in the data model where ConfD will invoke an external function to validate the associated data\&. The validation occurs before a transaction is committed\&. Similar to the state machine described for "external data bases" above where we install callback functions in the
\fBstruct confd_trans_cbs\fR, we have to install callback functions for each validation point\&. It does not matter if the database is CDB or an external database, the validation callbacks described here work equally well for both cases\&.
.nr wf \w'void\ confd_register_trans_validate_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_trans_validate_cbs\ *vcbs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_register_trans_validate_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_validate_cbs\ *" "vcbs" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_register_trans_validate_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_trans_validate_cbs\ *" "vcbs" ");" \}
.PP
This function installs two callback functions for the
\fBstruct confd_daemon_ctx\fR\&. One function that gets called when the validation phase starts in a transaction and one when the validation phase stops in a transaction\&. In the
\fBinit()\fR
callback we can use the MAAPI api to attach to the running transaction, this way we can later on, freely traverse the configuration and read data\&. The data we will be reading through MAAPI (see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]) will be read from the shadow storage containing the
\fInot\-yet\-committed\fR
data\&.
.PP
The
\fBstruct confd_trans_validate_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_trans_validate_cbs {
    int (*init)(struct confd_trans_ctx *tctx);
    int (*stop)(struct confd_trans_ctx *tctx);
};
.fi
.if n \{\
.RE
.\}
.PP
It must thus be populated with two function pointers when we call this function\&.
.PP
The
\fBinit()\fR
callback is conceptually invoked at the start of the validation phase, but just as for transaction callbacks, ConfD will as far as possible delay the actual invocation of the validation
\fBinit()\fR
callback for a given daemon until it is required\&. This means that if none of the daemon\*(Aqs
\fBvalidate()\fR
callbacks need to be invoked (see below),
\fBinit()\fR
and
\fBstop()\fR
will not be invoked either\&.
.PP
If we need to allocate memory or other resources for the validation this can also be done in the
\fBinit()\fR
callback, with the resources being freed in the
\fBstop()\fR
callback\&. We can use the
\fIt_opaque\fR
element in the
\fBstruct confd_trans_ctx\fR
to manage this, but in a daemon that implements both data and validation callbacks it is better to use the
\fIv_opaque\fR
element for validation, to be able to manage the allocations independently\&.
.PP
Similar to the
\fBinit()\fR
callback for external data bases, we must in the
\fBinit()\fR
callback associate a file descriptor with the transaction\&. This file descriptor will be used for the actual validation\&. Thus in a multi threaded application, we can have one thread performing validation for a transaction in parallel with other threads executing e\&.g\&. data callbacks\&. Thus a typical implementation of an
\fBinit()\fR
callback for validation looks as:
.sp
.if n \{\
.RS 4
.\}
.nf
static int init_validation(struct confd_trans_ctx *tctx)
{
    maapi_attach(maapi_socket, mtest__ns, tctx);
    confd_trans_set_fd(tctx, workersock);
    return CONFD_OK;
}
.fi
.if n \{\
.RE
.\}
.nr wf \w'int\ confd_register_valpoint_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_valpoint_cb\ *vcb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_valpoint_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_valpoint_cb\ *" "vcb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_valpoint_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_valpoint_cb\ *" "vcb" ");" \}
.PP
We must also install an actual validation function for each validation point, i\&.e\&. for each
tailf:validate
statement in the YANG data model\&.
.PP
A validation point has a name and an associated function pointer\&. The struct which must be populated for each validation point looks like:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_valpoint_cb {
    char valpoint[MAX_CALLPOINT_LEN];
    int (*validate)(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp,
                    confd_value_t *newval);
    void *cb_opaque;        /* private user data */
};
.fi
.if n \{\
.RE
.\}
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
We must call the
\fBconfd_register_done()\fR
function when we are done with all registrations for a daemon, see above\&.
.sp .5v
.RE
.PP
See the user guide chapter "Semantic validation" for code examples\&. The
\fBvalidate()\fR
callback can return CONFD_OK if all is well, or CONFD_ERROR if the validation fails\&. If we wish a message to accompany the error we must prior to returning from the callback, call
\fBconfd_trans_seterr()\fR
or
\fBconfd_trans_seterr_extended()\fR\&.
.PP
The
\fIcb_opaque\fR
element can be used to pass arbitrary data to the callback, e\&.g\&. when the same callback is used for multiple validation points\&. It is made available to the callback via the element
\fIvcb_opaque\fR
in the transaction context (\fItctx\fR
argument), see the structure definition above\&.
.PP
If the
tailf:opaque
substatement has been used with the
tailf:validate
statement in the data model, the argument string is made available to the callback via the
\fIvalidate_opaque\fR
element in the transaction context\&.
.PP
We also have yet another special return value which can be used (only) from the
\fBvalidate()\fR
callback which is CONFD_VALIDATION_WARN\&. Prior to return of this value we must call
\fBconfd_trans_seterr()\fR
which provides a string describing the warning\&. The warnings will get propagated to the transaction engine, and depending on where the transaction originates, ConfD may or may not act on the warnings\&. If the transaction originates from the CLI or the Web UI, ConfD will interactively present the user with a choice \- whereby the transaction can be aborted\&.
.PP
If the transaction originates from NETCONF \- which does not have any interactive capabilities \- the warnings are ignored\&. The warnings are primarily intended to alert inexperienced users that attempt to make \- dangerous \- configuration changes\&. There can be multiple warnings from multiple validation points in the same transaction\&.
.PP
It is also possible to let the
\fBvalidate()\fR
callback return CONFD_DELAYED_RESPONSE in which case the application at a later stage must invoke either
\fBconfd_delayed_reply_ok()\fR,
\fBconfd_delayed_reply_error()\fR
or
\fBconfd_delayed_reply_validation_warn()\fR\&.
.PP
In some cases it may be necessary for the validation callbacks to verify the availability of resources that will be needed if the new configuration is committed\&. To support this kind of verification, the
\fIvalidation_info\fR
element in the
\fBstruct confd_trans_ctx\fR
can carry one of these flags:
.PP
CONFD_VALIDATION_FLAG_TEST
.RS 4
When this flag is set, the current validation phase is a "test" validation, as in e\&.g\&. the CLI \*(Aqvalidate\*(Aq command, and the transaction will return to the READ state regardless of the validation result\&. This flag is available in all of the
\fBinit()\fR,
\fBvalidate()\fR, and
\fBstop()\fR
callbacks\&.
.RE
.PP
CONFD_VALIDATION_FLAG_COMMIT
.RS 4
When this flag is set, all requirements for a commit have been met, i\&.e\&. all validation as well as the write_start and prepare transitions have been successful, and the actual commit will follow\&. This flag is only available in the
\fBstop()\fR
callback\&.
.RE
.nr wf \w'int\ confd_register_range_valpoint_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_valpoint_cb\ *vcb,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *lower,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *upper,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_range_valpoint_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", struct\ confd_valpoint_cb\ *" "vcb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_range_valpoint_cb(struct\ confd_daemon_ctx\ *" "dx" ", struct\ confd_valpoint_cb\ *" "vcb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
A variant of
\fBconfd_register_valpoint_cb()\fR
which registers a validation function for a range of key values\&. The
\fIlower\fR,
\fIupper\fR,
\fInumkeys\fR,
\fIfmt\fR, and remaining parameters are the same as for
\fBconfd_register_range_data_cb()\fR, see above\&.
.nr wf \w'int\ confd_delayed_reply_validation_warn('
.nr wm 0
.nr wp \w'struct\ confd_trans_ctx\ *tctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_delayed_reply_validation_warn("
.br
.BI "struct\ confd_trans_ctx\ *" "tctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_delayed_reply_validation_warn(struct\ confd_trans_ctx\ *" "tctx" ");" \}
.PP
This function must be used to return the equivalent of CONFD_VALIDATION_WARN when the
\fBvalidate()\fR
callback returned CONFD_DELAYED_RESPONSE\&. Before calling this function, we must call
\fBconfd_trans_seterr()\fR
to provide a string describing the warning\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS
.SH "NOTIFICATION STREAMS"
.PP
The application can generate notifications that are sent via the northbound protocols\&. Currently NETCONF notification streams are supported\&. The application generates the content for each notification and sends it via a socket to ConfD, which in turn manages the stream subscriptions and distributes the notifications accordingly\&.
.PP
A stream always has a "live feed", which is the sequence of new notifications, sent in real time as they are generated\&. Subscribers may also request "replay" of older, logged notifications if the stream supports this, perhaps transitioning to the live feed when the end of the log is reached\&. There may be one or more replays active simultaneously with the live feed\&. ConfD forwards replay requests from subscribers to the application via callbacks if the stream supports replay\&.
.PP
Each notification has an associated time stamp, the "event time"\&. This is the time when the event that generated the notification occurred, rather than the time the notification is logged or sent, in case these times differ\&. The application must pass the event time to ConfD when sending a notification, and it is also needed when replaying logged events, see below\&.
.nr wf \w'int\ confd_register_notification_stream('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_notification_stream_cbs\ *ncbs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_notification_ctx\ **nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_notification_stream("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_stream_cbs\ *" "ncbs" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_notification_stream(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_stream_cbs\ *" "ncbs" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.PP
This function registers the notification stream and optionally two callback functions used for the replay functionality\&. If the stream does not support replay, the callback elements in the
\fBstruct confd_notification_stream_cbs\fR
are set to NULL\&. A context pointer is returned via the
\fI**nctx\fR
argument \- this must be used by the application for the sending of live notifications via
\fBconfd_notification_send()\fR
(see below)\&.
.PP
The
\fBconfd_notification_stream_cbs\fR
structure is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_notification_stream_cbs {
    char streamname[MAX_STREAMNAME_LEN];
    int fd;
    int (*get_log_times)(
        struct confd_notification_ctx *nctx);
    int (*replay)(struct confd_notification_ctx *nctx,
                  struct confd_datetime *start,
                  struct confd_datetime *stop);
    void *cb_opaque;        /* private user data */
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fIfd\fR
element must be set to a previously connected worker socket\&. This socket may be used for multiple notification streams, but not for any of the callback processing described above\&. Since it is only used for sending data to ConfD, there is no need for the application to poll the socket\&. Note that the control socket must be connected before registration even if the callbacks are not registered\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
We must call the
\fBconfd_register_done()\fR
function when we are done with all registrations for a daemon, see above\&.
.sp .5v
.RE
.PP
The
\fBget_log_times()\fR
callback is called by ConfD to find out a) the creation time of the current log and b) the event time of the last notification aged out of the log, if any\&. The application provides the times via the
\fBconfd_notification_reply_log_times()\fR
function (see below) and returns CONFD_OK\&.
.PP
The
\fBreplay()\fR
callback is called by ConfD to request replay\&. The
\fInctx\fR
context pointer must be saved by the application and used when sending the replay notifications via
\fBconfd_notification_send()\fR, as well as for the
\fBconfd_notification_replay_complete()\fR
(or
\fBconfd_notification_replay_failed()\fR) call (see below) \- the callback should return without waiting for the replay to complete\&. The pointer references allocated memory, which is freed by the
\fBconfd_notification_replay_complete()\fR
(or
\fBconfd_notification_replay_failed()\fR) call\&.
.PP
The times given by
\fI*start\fR
and
\fI*stop\fR
specify the extent of the replay\&. The start time will always be given and specify a time in the past, however the stop time may be either in the past or in the future or even omitted, i\&.e\&. the
\fIstop\fR
argument is NULL\&. This means that the subscriber has requested that the subscription continues indefinitely with the live feed when the logged notifications have been sent\&.
.PP
If the stop time is given:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The application sends all logged notifications that have an event time later than the start time but not later than the stop time, and then calls
\fBconfd_notification_replay_complete()\fR\&. Note that if the stop time is in the future when the replay request arrives, this includes notifications logged while the replay is in progress (if any), as long as their event time is not later than the stop time\&.
.RE
.PP
If the stop time is
\fInot\fR
given:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The application sends all logged notifications that have an event time later than the start time, and then calls
\fBconfd_notification_replay_complete()\fR\&. Note that this includes notifications logged after the request was received (if any)\&.
.RE
.PP
ConfD will if needed switch the subscriber over to the live feed and then end the subscription when the stop time is reached\&. The callback may analyze the
\fIstart\fR
and
\fIstop\fR
arguments to determine start and stop positions in the log, but if the analysis is postponed until after the callback has returned, the
\fBconfd_datetime\fR
structure(s) must be copied by the callback\&.
.PP
The
\fBreplay()\fR
callback may optionally select a separate worker socket to be used for the replay notifications\&. In this case it must call
\fBconfd_notification_set_fd()\fR
to indicate which socket should be used\&.
.PP
Note that unlike the callbacks for external data bases and validation, these callbacks do not use a worker socket for the callback processing, and consequently there is no
\fBinit()\fR
callback to request one\&. The callbacks are invoked, and the reply is sent, via the daemon control socket\&.
.PP
The
\fIcb_opaque\fR
element in the
\fBconfd_notification_stream_cbs\fR
structure can be used to pass arbitrary data to the callbacks in much the same way as for callpoint and validation point registrations, see the description of the
\fBstruct confd_data_cbs\fR
structure above\&. However since the callbacks are not associated with a transaction, this element is instead made available in the
\fBconfd_notification_ctx\fR
structure\&.
.nr wf \w'int\ confd_notification_send('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *time,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_send("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "time" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_send(struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "time" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.PP
This function is called by the application to send a notification, whether "live" or replay\&. The
\fInctx\fR
pointer is provided by ConfD as described above\&. The
\fItime\fR
argument specifies the event time for the notification\&. The
\fIvalues\fR
argument is an array of length
\fInvalues\fR, populated with the content of the notification as described for the Tagged Value Array format in the
\m[blue]\fBXML STRUCTURES\fR\m[]
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
For example, a NETCONF notification of the form
.sp
.if n \{\
.RS 4
.\}
.nf
<ncn:notification
 xmlns:ncn="urn:ietf:params:xml:ns:netconf:notification:1\&.0">
  <linkUp xmlns="http://example\&.com/ns/test/1\&.0">
    <ncn:eventTime>2007\-08\-17T08:56:05Z</ncn:eventTime>
    <ifIndex>3</ifIndex>
  </linkUp>
</ncn:notification>
.fi
.if n \{\
.RE
.\}
.PP
could be sent with the following code:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_notification_ctx *nctx;
struct confd_datetime event_time = {2007, 8, 17, 8, 56, 5, 0, 0, 0};
confd_tag_value_t notif[3];
int n = 0;

CONFD_SET_TAG_XMLBEGIN(&notif[n], test_linkUp, test__ns); n++;
CONFD_SET_TAG_UINT32(&notif[n], test_ifIndex, 3); n++;
CONFD_SET_TAG_XMLEND(&notif[n], test_linkUp, test__ns); n++;
confd_notification_send(nctx, &event_time, notif, n);
.fi
.if n \{\
.RE
.\}
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
While it is possible to use separate threads to send live and replay notifications for a given stream, or to send different streams on a given worker socket, this is not recommended\&. This is because it involves rather complex synchronization problems that can only be fully solved by the application, in particular in the case where a replay switches over to the live feed\&.
.sp .5v
.RE
.nr wf \w'int\ confd_notification_replay_complete('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_replay_complete("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_replay_complete(struct\ confd_notification_ctx\ *" "nctx" ");" \}
.PP
The application calls this function to notify ConfD that the replay is complete, using the
\fInctx\fR
pointer received in the corresponding
\fBreplay()\fR
callback invocation\&.
.nr wf \w'int\ confd_notification_replay_failed('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_replay_failed("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_replay_failed(struct\ confd_notification_ctx\ *" "nctx" ");" \}
.PP
In case the application fails to complete the replay as requested (e\&.g\&. the log gets overwritten while the replay is in progress), the application should call this function
\fIinstead\fR
of
\fBconfd_notification_replay_complete()\fR\&. An error message describing the reason for the failure can be supplied by first calling
\fBconfd_notification_seterr()\fR
or
\fBconfd_notification_seterr_extended()\fR, see below\&. The
\fInctx\fR
pointer received in the corresponding
\fBreplay()\fR
callback invocation is used for both calls\&.
.nr wf \w'void\ confd_notification_set_fd('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ fd);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_set_fd("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", int\ " "fd" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_set_fd(struct\ confd_notification_ctx\ *" "nctx" ", int\ " "fd" ");" \}
.PP
This function may optionally be called by the
\fBreplay()\fR
callback to request that the worker socket given by
\fIfd\fR
should be used for the replay\&. Otherwise the socket specified in the
\fBconfd_notification_stream_cbs\fR
at registration will be used\&.
.nr wf \w'int\ confd_notification_reply_log_times('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *creation,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *aged);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_reply_log_times("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "creation" ", struct\ confd_datetime\ *" "aged" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_reply_log_times(struct\ confd_notification_ctx\ *" "nctx" ", struct\ confd_datetime\ *" "creation" ", struct\ confd_datetime\ *" "aged" ");" \}
.PP
Reply function for use in the
\fBget_log_times()\fR
callback invocation\&. If no notifications have been aged out of the log, give NULL for the
\fIaged\fR
argument\&.
.nr wf \w'void\ confd_notification_seterr('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_seterr("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_seterr(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
In some cases the callbacks may be unable to carry out the requested actions, e\&.g\&. the capacity for simultaneous replays might be exceeded, and they can then return CONFD_ERR\&. This function allows the callback to associate an error message with the failure\&. It can also be used to supply an error message before calling
\fBconfd_notification_replay_failed()\fR\&.
.nr wf \w'void\ confd_notification_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_seterr_extended("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_seterr_extended(struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide more structured error information from a notification callback, see the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ confd_notification_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_seterr_extended_info("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_seterr_extended_info(struct\ confd_notification_ctx\ *" "nctx" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide structured error information in the same way as
\fBconfd_notification_seterr_extended()\fR, and additionally provide contents for the NETCONF <error\-info> element\&. See the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ confd_register_snmp_notification('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ fd,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notify_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *ctx_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_notification_ctx\ **nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_snmp_notification("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ", const\ char\ *" "notify_name" ", const\ char\ *" "ctx_name" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_snmp_notification(struct\ confd_daemon_ctx\ *" "dx" ", int\ " "fd" ", const\ char\ *" "notify_name" ", const\ char\ *" "ctx_name" ", struct\ confd_notification_ctx\ **" "nctx" ");" \}
.PP
SNMP notifications can also be sent via the notification framework, however most aspects of the stream concept described above do not apply for SNMP\&. This function is used to register a worker socket, the snmpNotifyName (\fInotify_name\fR), and SNMP context (\fIctx_name\fR) to be used for the notifications\&.
.PP
The
\fIfd\fR
parameter must give a previously connected worker socket\&. This socket may be used for different notifications, but not for any of the callback processing described above\&. Since it is only used for sending data to ConfD, there is no need for the application to poll the socket\&. Note that the control socket must be connected before registration, even if none of the callbacks described below are registered\&.
.PP
The context pointer returned via the
\fI**nctx\fR
argument must be used by the application for the subsequent sending of the notifications via
\fBconfd_notification_send_snmp()\fR
or
\fBconfd_notification_send_snmp_inform()\fR
(see below)\&.
.PP
When a notification is sent using one of these functions, it is delivered to the management targets defined for the
snmpNotifyName
in the
snmpNotifyTable
in SNMP\-NOTIFICATION\-MIB for the specified SNMP context\&. If
\fInotify_name\fR
is NULL or the empty string (""), the notification is sent to all management targets\&. If
\fIctx_name\fR
is NULL or the empty string (""), the default context ("") is used\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
We must call the
\fBconfd_register_done()\fR
function when we are done with all registrations for a daemon, see above\&.
.sp .5v
.RE
.nr wf \w'int\ confd_notification_send_snmp('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notification,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_snmp_varbind\ *varbinds,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_vars);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_send_snmp("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_send_snmp(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ");" \}
.PP
Sends the SNMP notification specified by
\fInotification\fR, without requesting inform\-request delivery information\&. This is equivalent to calling
\fBconfd_notification_send_snmp_inform()\fR
(see below) with NULL as the
\fIcb_id\fR
argument\&. I\&.e\&. if the common arguments are the same, the two functions will send the exact same set of traps and inform\-requests\&.
.nr wf \w'int\ confd_register_notification_snmp_inform_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_notification_snmp_inform_cbs\ *cb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_notification_snmp_inform_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_snmp_inform_cbs\ *" "cb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_notification_snmp_inform_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_snmp_inform_cbs\ *" "cb" ");" \}
.PP
If we want to receive information about the delivery of SNMP inform\-requests, we must register two callbacks for this\&. The
\fBstruct confd_notification_snmp_inform_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_notification_snmp_inform_cbs {
    char cb_id[MAX_CALLPOINT_LEN];
    void (*targets)(struct confd_notification_ctx *nctx,
                    int ref, struct confd_snmp_target *targets,
                    int num_targets);
    void (*result)(struct confd_notification_ctx *nctx,
                   int ref, struct confd_snmp_target *target,
                   int got_response);
    void *cb_opaque;        /* private user data */
};
.fi
.if n \{\
.RE
.\}
.PP
The callback identifier
\fIcb_id\fR
can be chosen arbitrarily, it is only used when sending SNMP notifications with
\fBconfd_notification_send_snmp_inform()\fR
\- however each inform callback registration must use a unique
\fIcb_id\fR\&. The callbacks are invoked via the control socket, i\&.e\&. the application must poll it and invoke
\fBconfd_fd_ready()\fR
when data is available\&.
.PP
When a notification is sent, the
\fBtarget()\fR
callback will be invoked once with
\fInum_targets\fR
(possibly 0) inform\-request targets in the
\fItargets\fR
array, followed by
\fInum_targets\fR
invocations of the
\fBresult()\fR
callback, one for each target\&. The
\fIref\fR
argument (passed from the
\fBconfd_notification_send_snmp_inform()\fR
call) allows for tracking the result of multiple notifications with delivery overlap\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
We must call the
\fBconfd_register_done()\fR
function when we are done with all registrations for a daemon, see above\&.
.sp .5v
.RE
.nr wf \w'int\ confd_notification_send_snmp_inform('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notification,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_snmp_varbind\ *varbinds,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_vars,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cb_id,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ ref);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_send_snmp_inform("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ", const\ char\ *" "cb_id" ", int\ " "ref" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_send_snmp_inform(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notification" ", struct\ confd_snmp_varbind\ *" "varbinds" ", int\ " "num_vars" ", const\ char\ *" "cb_id" ", int\ " "ref" ");" \}
.PP
Sends the SNMP notification specified by
\fInotification\fR\&. If
\fIcb_id\fR
is not NULL, the callbacks registered for
\fIcb_id\fR
will be invoked with the
\fIref\fR
argument as described above, otherwise no inform\-request delivery information will be provided\&. The
\fIvarbinds\fR
array should be populated with
\fInum_vars\fR
elements as described in the Notifications section of the SNMP Agent chapter in the User Guide\&.
.PP
If
\fInotification\fR
is the empty string, no notification is looked up; instead
\fIvarbinds\fR
defines the notification, including the notification id (variable name "snmpTrapOID")\&. This is especially useful for forwarding a notification which has been received from the SNMP gateway (see
\fBconfd_register_notification_sub_snmp_cb()\fR
below)\&.
.PP
If
\fIvarbinds\fR
does not contain a timestamp (variable name "sysUpTime"), one will be supplied by the agent\&.
.nr wf \w'void\ confd_notification_set_snmp_src_addr('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_notification_set_snmp_src_addr("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ struct\ confd_ip\ *" "src_addr" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_notification_set_snmp_src_addr(struct\ confd_notification_ctx\ *" "nctx" ", const\ struct\ confd_ip\ *" "src_addr" ");" \}
.PP
By default, the source address for the SNMP notifications that are sent by the above functions is chosen by the IP stack of the OS\&. This function may be used to select a specific source address, given by
\fIsrc_addr\fR, for the SNMP notifications subsequently sent using the
\fInctx\fR
context\&. The default can be restored by calling the function with a
\fIsrc_addr\fR
where the
\fIaf\fR
element is set to
\fBAF_UNSPEC\fR\&.
.nr wf \w'int\ confd_notification_set_snmp_notify_name('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *notify_name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_set_snmp_notify_name("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notify_name" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_set_snmp_notify_name(struct\ confd_notification_ctx\ *" "nctx" ", const\ char\ *" "notify_name" ");" \}
.PP
This function can be used to change the snmpNotifyName (\fInotify_name\fR) for the
\fInctx\fR
context\&. The new snmpNotifyName is used for notifications sent by subsequent calls to
\fBconfd_notification_send_snmp()\fR
and
\fBconfd_notification_send_snmp_inform()\fR
that use the
\fInctx\fR
context\&.
.nr wf \w'int\ confd_register_notification_sub_snmp_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_notification_sub_snmp_cb\ *cb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_notification_sub_snmp_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_sub_snmp_cb\ *" "cb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_notification_sub_snmp_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_notification_sub_snmp_cb\ *" "cb" ");" \}
.PP
Registers a callback function to be called when an SNMP notification is received by the SNMP gateway\&.
.PP
The
\fBstruct confd_notification_sub_snmp_cb\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_notification_sub_snmp_cb {
    char sub_id[MAX_CALLPOINT_LEN];
    int (*recv)(struct confd_notification_ctx *nctx,
                char *notification,
                struct confd_snmp_varbind *varbinds, int num_vars,
                confd_value_t *src_addr, u_int16_t src_port);
    void *cb_opaque;        /* private user data */
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fIsub_id\fR
element is the subscription id for the notifications\&. The
\fBrecv()\fR
callback will be called when a notification is received\&. See the section "Receiving and Forwarding Traps" in the chapter "The SNMP gateway" in the Users Guide\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
We must call the
\fBconfd_register_done()\fR
function when we are done with all registrations for a daemon, see above\&.
.sp .5v
.RE
.nr wf \w'int\ confd_notification_flush('
.nr wm 0
.nr wp \w'struct\ confd_notification_ctx\ *nctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_notification_flush("
.br
.BI "struct\ confd_notification_ctx\ *" "nctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_notification_flush(struct\ confd_notification_ctx\ *" "nctx" ");" \}
.PP
Notifications are sent asynchronously, i\&.e\&. normally without blocking the caller of the send functions described above\&. This means that in some cases, ConfD\*(Aqs sending of the notifications on the northbound interfaces may lag behind the send calls\&. If we want to make sure that the notifications have actually been sent out, e\&.g\&. in some shutdown procedure, we can call
\fBconfd_notification_flush()\fR\&. This function will block until all notifications sent using the given
\fInctx\fR
context have been fully processed by ConfD\&. It can be used both for notification streams and for SNMP notifications (however it will not wait for replies to SNMP inform\-requests to arrive)\&.
.SH "CONFD ACTIONS"
.PP
The use of action callbacks can be specified either via a
rpc
statement or via a
tailf:action
statement in the YANG data model, see the YANG specification and
\m[blue]\fBtailf_yang_extensions(5)\fR\m[]\&. In both cases the use of a
tailf:actionpoint
statement specifies that the action is implemented as a callback function\&. This section describes how such callback functions should be implemented and registered with ConfD\&.
.PP
Unlike the callbacks for data and validation, there is not always a transaction associated with an action callback\&. However an action is always associated with a user session (NETCONF, CLI, etc), and only one action at a time can be invoked from a given user session\&. Hence a pointer to the associated
\fBstruct confd_user_info\fR
is passed to the callbacks\&.
.PP
The action callback mechanism is also used for command and completion callbacks configured for the CLI, either in a YANG module using tailf extension statements, or in a
\m[blue]\fBclispec(5)\fR\m[]\&. As the parameter structure is significantly different, special callbacks are used for these functions\&.
.nr wf \w'int\ confd_register_action_cbs('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_action_cbs\ *acb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_action_cbs("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_action_cbs(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ");" \}
.PP
This function registers up to five callback functions, two of which will be called in sequence when an action is invoked\&. The
\fBstruct confd_action_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_action_cbs {
    char actionpoint[MAX_CALLPOINT_LEN];
    int (*init)(struct confd_user_info *uinfo);
    int (*abort)(struct confd_user_info *uinfo);
    int (*action)(struct confd_user_info *uinfo,
                  struct xml_tag *name,
                  confd_hkeypath_t *kp,
                  confd_tag_value_t *params,
                  int nparams);
    int (*command)(struct confd_user_info *uinfo,
                   char *path, int argc, char **argv);
    int (*completion)(struct confd_user_info *uinfo,
                      int cli_style, char *token, int completion_char,
                      confd_hkeypath_t *kp,
                      char *cmdpath, char *cmdparam_id,
                      struct confd_qname *simpleType, char *extra);
    void *cb_opaque;        /* private user data */
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fBinit()\fR
callback, and at least one of the
\fBaction()\fR,
\fBcommand()\fR, and
\fBcompletion()\fR
callbacks, must be specified\&. It is in principle possible to use a single "point name" for more than one of these callback types, and have the corresponding callback invoked in each case, but in typical usage we would only register one of the callbacks
\fBaction()\fR,
\fBcommand()\fR, and
\fBcompletion()\fR\&. Below, the term "action callback" is used to refer to any of these three\&.
.PP
Similar to the
\fBinit()\fR
callback for external data bases, we must in the
\fBinit()\fR
callback associate a worker socket with the action\&. This socket will be used for the invocation of the action callback, which actually carries out the action\&. Thus in a multi threaded application, actions can be dispatched to different threads\&.
.PP
However note that unlike the callbacks for external data bases and validation, both
\fBinit()\fR
and action callbacks are registered for each action point (i\&.e\&. different action points can have different
\fBinit()\fR
callbacks), and there is no
\fBfinish()\fR
callback \- the action is completed when the action callback returns\&.
.PP
The
\fBstruct confd_action_ctx actx\fR
element inside the
\fBstruct confd_user_info\fR
holds action\-specific data, in particular the
\fIt_opaque\fR
element could be used to pass data from the
\fBinit()\fR
callback to the action callback, if needed\&. If the action is associated with a transaction, the
\fIthandle\fR
element is set to the transaction handle, and can be used with a call to
\fBmaapi_attach2()\fR
(see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]), otherwise
\fIthandle\fR
will be \-1\&. It is up to the northbound interface whether to invoke the action with a transaction handle, and the action implementer must check if the thandle is \-1 or a proper transaction handle if the action intends to use it\&. The CLI will always invoke an action with a transaction handle (it will pass a handle to a read_write transaction when in configure mode, and a read transaction otherwise)\&. The NETCONF interface will do so if the tailf extension
<start\-transaction/>
was used before the action was invoked\&. A transaction handle will also be passed to the callback when invoked via
\fBmaapi_request_action_th()\fR
(see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[])\&.
.PP
The
\fIcb_opaque\fR
element in the
\fBconfd_action_cbs\fR
structure can be used to pass arbitrary data to the callbacks in much the same way as for callpoint and validation point registrations, see the description of the
\fBstruct confd_data_cbs\fR
structure above\&. This element is made available in the
\fBconfd_action_ctx\fR
structure\&.
.PP
If the
tailf:opaque
substatement has been used with the
tailf:actionpoint
statement in the data model, the argument string is made available to the callbacks via the
\fIactionpoint_opaque\fR
element in the
\fBconfd_action_ctx\fR
structure\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
We must call the
\fBconfd_register_done()\fR
function when we are done with all registrations for a daemon, see above\&.
.sp .5v
.RE
.PP
The
\fBaction()\fR
callback receives all the parameters pertaining to the action: The
\fIname\fR
argument is a pointer to the action name as defined in the data model, the
\fIkp\fR
argument gives the path through the data model for an action defined via
tailf:action
(it is a NULL pointer for an action defined via
rpc), and finally the
\fIparams\fR
argument is a representation of the inout parameters provided when the action is invoked\&. The
\fIparams\fR
argument is an array of length
\fInparams\fR, populated as described for the Tagged Value Array format in the
\m[blue]\fBXML STRUCTURES\fR\m[]
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
The
\fBcommand()\fR
callback is invoked for CLI callback commands\&. It must always result in a call of
\fBconfd_action_reply_command()\fR\&. As the parameters in this case are all in string form, they are passed in the traditional Unix
\fIargc\fR,
\fIargv\fR
manner \- i\&.e\&.
\fIargv\fR
is an array of
\fIargc\fR
pointers to NUL\-terminated strings plus a final NULL pointer element, and
\fIargv[0]\fR
is the name of the command\&. Additionally the full path of the command is available via the
\fIpath\fR
argument\&.
.PP
The
\fBcompletion()\fR
callback is invoked for CLI completion and information\&. It must result in a call of
\fBconfd_action_reply_completion()\fR, except for the case when the callback is invoked via a
tailf:cli\-custom\-range\-enumerator
statement in the data model (see below)\&. The
\fIcli_style\fR
argument gives the style of the CLI session as a character: \*(AqJ\*(Aq, \*(AqC\*(Aq, or \*(AqI\*(Aq\&. The
\fItoken\fR
argument is a NUL\-terminated string giving the parameter of the CLI command line that the callback invocation pertains to, and
\fIcompletion_char\fR
is the character that the user typed, i\&.e\&. TAB (\*(Aq\et\*(Aq), SPACE (\*(Aq \*(Aq), or \*(Aq?\*(Aq\&. If the callback pertains to a data model element,
\fIkp\fR
identifies that element, otherwise it is NULL\&. The
\fIcmdpath\fR
is a NUL\-terminated string giving the full path of the command\&. If a
cli\-completion\-id
is specified in the YANG module, or a
completionId
is specified in the clispec, it is given as a NUL\-terminated string via
\fIcmdparam_id\fR, otherwise this argument is NULL\&. If the invocation pertains to an element that has a type definition, the
\fIsimpleType\fR
argument identifies the type with namespace and type name, otherwise it is NULL\&. The
\fIextra\fR
argument is currently unused (always NULL)\&.
.PP
When
\fBcompletion()\fR
is invoked via a
tailf:cli\-custom\-range\-enumerator
statement in the data model, it is a request to provide possible key values for creation of an entry in a list with a custom range specification\&. The callback must in this case result in a call of
\fBconfd_action_reply_range_enum()\fR\&. Refer to the
cli/range_create
example in the bundled examples collection to see an implementation of such a callback\&.
.PP
The action callbacks must return CONFD_OK, CONFD_ERR, or CONFD_DELAYED_RESPONSE\&. CONFD_DELAYED_RESPONSE implies that the application must later reply asynchronously\&.
.PP
The optional
\fBabort()\fR
callback is called whenever an action is aborted, e\&.g\&. when a user invokes an action from one of the northbound agents and aborts it before it has completed\&. The
\fBabort()\fR
callback will be invoked on the control socket\&. It is the responsibility of the
\fBabort()\fR
callback to make sure that the pending reply from the action callback is sent\&. This is required to allow the worker socket to be used for further queries\&. There are several possible ways for an application to support aborting\&. E\&.g\&. the application can return CONFD_DELAYED_RESPONSE from the action callback\&. Then, when the
\fBabort()\fR
callback is called, it can terminate the executing action and use e\&.g\&.
\fBconfd_action_delayed_reply_error()\fR\&. Alternatively an application can use threads where the action callback is executed in a separate thread\&. In this case the
\fBabort()\fR
callback could inform the thread executing the action that it should be terminated, and that thread can just return from the action callback\&.
.nr wf \w'int\ confd_register_range_action_cbs('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_action_cbs\ *acb,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *lower,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *upper,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_range_action_cbs("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_range_action_cbs(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_action_cbs\ *" "acb" ", const\ confd_value_t\ *" "lower" ", const\ confd_value_t\ *" "upper" ", int\ " "numkeys" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
A variant of
\fBconfd_register_action_cbs()\fR
which registers action callbacks for a range of key values\&. The
\fIlower\fR,
\fIupper\fR,
\fInumkeys\fR,
\fIfmt\fR, and remaining parameters are the same as for
\fBconfd_register_range_data_cb()\fR, see above\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function can not be used for registration of the
\fBcommand()\fR
or
\fBcompletion()\fR
callbacks \- only actions specified in the data model are invoked via a keypath that can be used for selection of the corresponding callbacks\&.
.sp .5v
.RE
.nr wf \w'void\ confd_action_set_fd('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_action_set_fd("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "void confd_action_set_fd(struct\ confd_user_info\ *" "uinfo" ", int\ " "sock" ");" \}
.PP
Associate a worker socket with the action\&. This function must be called in the
\fBinit()\fR
callback \- a typical implementation of an
\fBinit()\fR
callback looks as:
.sp
.if n \{\
.RS 4
.\}
.nf
static int init_action(struct confd_user_info *uinfo)
{
    confd_action_set_fd(uinfo, workersock);
    return CONFD_OK;
}
.fi
.if n \{\
.RE
.\}
.nr wf \w'int\ confd_action_reply_values('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_values("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_values(struct\ confd_user_info\ *" "uinfo" ", confd_tag_value_t\ *" "values" ", int\ " "nvalues" ");" \}
.PP
If the action definition specifies that the action should return data, it must invoke this function in response to the
\fBaction()\fR
callback\&. The
\fIvalues\fR
argument points to an array of length
\fInvalues\fR, populated with the output parameters in the same way as the
\fIparams\fR
array above\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function must only be called for an
\fBaction()\fR
callback\&.
.sp .5v
.RE
.nr wf \w'int\ confd_action_reply_command('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_command("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_command(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ");" \}
.PP
If a CLI callback command should return data, it must invoke this function in response to the
\fBcommand()\fR
callback\&. The
\fIvalues\fR
argument points to an array of length
\fInvalues\fR, populated with pointers to NUL\-terminated strings\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function must only be called for a
\fBcommand()\fR
callback\&.
.sp .5v
.RE
.nr wf \w'int\ confd_action_reply_rewrite('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhides,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nunhides);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_rewrite("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_rewrite(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ");" \}
.PP
This function can be called instead of
\fBconfd_action_reply_command()\fR
as a response to a show path rewrite callback invocation\&. The
\fIvalues\fR
argument points to an array of length
\fInvalues\fR, populated with pointers to NUL\-terminated strings representing the tokens of the new path\&. The
\fIunhides\fR
argument points to an array of length
\fInunhides\fR, populated with pointers to NUL\-terminated strings representing hide groups to temporarily unhide during evaluation of the show command\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function must only be called for a
\fBcommand()\fR
callback\&.
.sp .5v
.RE
.nr wf \w'int\ confd_action_reply_rewrite2('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhides,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nunhides,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_rewrite_select\ **selects,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nselects);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_rewrite2("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ", struct\ confd_rewrite_select\ **" "selects" ", int\ " "nselects" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_rewrite2(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "nvalues" ", char\ **" "unhides" ", int\ " "nunhides" ", struct\ confd_rewrite_select\ **" "selects" ", int\ " "nselects" ");" \}
.PP
This function can be called instead of
\fBconfd_action_reply_command()\fR
as a response to a show path rewrite callback invocation\&. The
\fIvalues\fR
argument points to an array of length
\fInvalues\fR, populated with pointers to NUL\-terminated strings representing the tokens of the new path\&. The
\fIunhides\fR
argument points to an array of length
\fInunhides\fR, populated with pointers to NUL\-terminated strings representing hide groups to temporarily unhide during evaluation of the show command\&. The
\fIselects\fR
argument points to an array of length
\fInselects\fR, populated with pointers to confd_rewrite_select structs representing additional select targets\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function must only be called for a
\fBcommand()\fR
callback\&.
.sp .5v
.RE
.nr wf \w'int\ confd_action_reply_completion('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_completion_value\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_completion("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", struct\ confd_completion_value\ *" "values" ", int\ " "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_completion(struct\ confd_user_info\ *" "uinfo" ", struct\ confd_completion_value\ *" "values" ", int\ " "nvalues" ");" \}
.PP
This function must normally be called in response to the
\fBcompletion()\fR
callback\&. The
\fIvalues\fR
argument points to an
\fInvalues\fR
long array of
\fBconfd_completion_value\fR
elements:
.sp
.if n \{\
.RS 4
.\}
.nf
enum confd_completion_type {
    CONFD_COMPLETION,
    CONFD_COMPLETION_INFO,
    CONFD_COMPLETION_DESC,
    CONFD_COMPLETION_DEFAULT
};
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_completion_value {
    enum confd_completion_type type;
    char *value;
    char *extra;
};
.fi
.if n \{\
.RE
.\}
.PP
For a completion alternative,
\fItype\fR
is set to CONFD_COMPLETION,
\fIvalue\fR
gives the alternative as a NUL\-terminated string, and
\fIextra\fR
gives explanatory text as a NUL\-terminated string \- if there is no such text,
\fIextra\fR
is set to NULL\&. For "info" or "desc" elements,
\fItype\fR
is set to CONFD_COMPLETION_INFO or CONFD_COMPLETION_DESC, respectively, and
\fIvalue\fR
gives the text as a NUL\-terminated string (the
\fIextra\fR
element is ignored)\&.
.PP
In order to fallback to the normal completion behavior,
\fItype\fR
should be set to CONFD_COMPLETION_DEFAULT\&. CONFD_COMPLETION_DEFAULT cannot be combined with the other completion types, implying the
\fIvalues\fR
array always must have length
\fI1\fR
which is indicated by
\fInvalues\fR
setting\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function must only be called for a
\fBcompletion()\fR
callback\&.
.sp .5v
.RE
.nr wf \w'int\ confd_action_reply_range_enum('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ keysize,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nkeys);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_reply_range_enum("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "keysize" ", int\ " "nkeys" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_reply_range_enum(struct\ confd_user_info\ *" "uinfo" ", char\ **" "values" ", int\ " "keysize" ", int\ " "nkeys" ");" \}
.PP
This function must be called in response to the
\fBcompletion()\fR
callback when it is invoked via a
tailf:cli\-custom\-range\-enumerator
statement in the data model\&. The
\fIvalues\fR
argument points to a
\fIkeysize\fR*\fInkeys\fR
long array of strings giving the possible key values, where
\fIkeysize\fR
is the number of keys for the list in the data model and
\fInkeys\fR
is the number of list entries for which keys are provided\&. I\&.e\&. the array gives entry1\-key1, entry1\-key2, \&.\&.\&., entry2\-key1, entry2\-key2, \&.\&.\&. and so on\&. See the
cli/range_create
example in the bundled examples collection for details\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function must only be called for a
\fBcompletion()\fR
callback\&.
.sp .5v
.RE
.nr wf \w'void\ confd_action_seterr('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_action_seterr("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_action_seterr(struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
If action callback encounters fatal problems that can not be expressed via the reply function, it may call this function with an appropriate message and return CONFD_ERR instead of CONFD_OK\&.
.nr wf \w'void\ confd_action_seterr_extended('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_action_seterr_extended("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_action_seterr_extended(struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide more structured error information from an action callback, see the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ confd_action_seterr_extended_info('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_seterr_extended_info("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_seterr_extended_info(struct\ confd_user_info\ *" "uinfo" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide structured error information in the same way as
\fBconfd_action_seterr_extended()\fR, and additionally provide contents for the NETCONF <error\-info> element\&. See the section
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ confd_action_delayed_reply_ok('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_delayed_reply_ok("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_delayed_reply_ok(struct\ confd_user_info\ *" "uinfo" ");" \}
.nr wf \w'int\ confd_action_delayed_reply_error('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *errstr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_delayed_reply_error("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "errstr" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_delayed_reply_error(struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "errstr" ");" \}
.PP
If we use the CONFD_DELAYED_RESPONSE as a return value from the action callback, we must later asynchronously reply\&. If we use one of the
\fBconfd_action_reply_xxx()\fR
functions, this is a complete reply\&. Otherwise we must use the
\fBconfd_action_delayed_reply_ok()\fR
function to signal success, or the
\fBconfd_action_delayed_reply_error()\fR
function to signal an error\&.
.nr wf \w'int\ confd_action_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_action_set_timeout("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_action_set_timeout(struct\ confd_user_info\ *" "uinfo" ", int\ " "timeout_secs" ");" \}
.PP
Some action callbacks may require a significantly longer execution time than others, and this time may not even be possible to determine statically (e\&.g\&. a file download)\&. In such cases the
/confdConfig/capi/queryTimeout
setting in
confd\&.conf
(see above) may be insufficient, and this function can be used to extend (or shorten) the timeout for the current callback invocation\&. The timeout is given in seconds from the point in time when the function is called\&.
.PP
Examples on how to work with actions are available in the User Guide and in the bundled examples collection\&.
.SH "AUTHENTICATION CALLBACK"
.PP
We can register a callback with ConfD\*(Aqs AAA subsystem, to be invoked whenever AAA has completed processing of an authentication attempt\&. In the case where the authentication was otherwise successful, the callback can still cause it to be rejected\&. This can be used to implement specific access policies, as an alternative to using PAM or "External" authentication for this purpose\&. The callback will only be invoked if it is both enabled via
/confdConfig/aaa/authenticationCallback/enabled
in
confd\&.conf
(see
\m[blue]\fBconfd\&.conf(5)\fR\m[]) and registered as described here\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If the callback is enabled in
confd\&.conf
but not registered, or invocation keeps failing for some reason,
\fIall\fR
authentication attempts will fail\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This callback can not be used to actually
\fIperform\fR
the authentication\&. If we want to implement the authentication outside of ConfD, we need to use PAM or "External" authentication, see the
\m[blue]\fBAAA chapter in the User Guide\fR\m[]\&.
.sp .5v
.RE
.nr wf \w'int\ confd_register_auth_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_auth_cb\ *acb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_auth_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_auth_cb\ *" "acb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_auth_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_auth_cb\ *" "acb" ");" \}
.PP
Registers the authentication callback\&. The
\fBstruct confd_auth_cb\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_auth_cb {
    int (*auth)(struct confd_auth_ctx *actx);
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fBauth()\fR
callback is invoked with a pointer to an authentication context that provides information about the result of the authentication so far\&. The callback must return CONFD_OK or CONFD_ERR, see below\&. The
\fBstruct confd_auth_ctx\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_auth_ctx {
    struct confd_user_info *uinfo;
    char *method;
    int success;
    union {
        struct {         /* if success */
            int ngroups;
            char **groups;
        } succ;
        struct {         /* if !success */
            int logno;   /* number from confd_logsyms\&.h */
            char *reason;
        } fail;
    } ainfo;
    /* ConfD internal fields */
    char *errstr;
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fIuinfo\fR
element points to a
\fBstruct confd_user_info\fR
with details about the user logging in, specifically user name, password (if used), source IP address, context, and protocol\&. Note that the user session does not actually exist at this point, even if the AAA authentication was successful \- it will only be created if the callback accepts the authentication, hence e\&.g\&. the
\fIusid\fR
element is always 0\&.
.PP
The
\fImethod\fR
string gives the authentication method used, as follows:
.PP
"password"
.RS 4
Password authentication\&. This generic term is used if the authentication failed\&.
.RE
.PP
"local", "pam", "external"
.RS 4
Password authentication\&. On successful authentication, the specific method that succeeded is given\&. See the
\m[blue]\fBAAA chapter in the User Guide\fR\m[]
for an explanation of these methods\&.
.RE
.PP
"publickey"
.RS 4
Public key authentication via the internal SSH server\&.
.RE
.PP
Other
.RS 4
Authentication with an unknown or unsupported method with this name was attempted via the internal SSH server\&.
.RE
.PP
If
\fIsuccess\fR
is non\-zero, the AAA authentication succeeded, and
\fIgroups\fR
is an array of length
\fIngroups\fR
that gives the groups that will be assigned to the user at login\&. If the callback returns CONFD_OK, the complete authentication succeeds and the user is logged in\&. If it returns CONFD_ERR (or an invalid return value), the authentication fails\&.
.PP
If
\fIsuccess\fR
is zero, the AAA authentication failed (with
\fIlogno\fR
set to
\fBCONFD_AUTH_LOGIN_FAIL\fR), and the explanatory string
\fIreason\fR\&. This invocation is only for informational purposes \- the callback return value has no effect on the authentication, and should normally be CONFD_OK\&.
.nr wf \w'void\ confd_auth_seterr('
.nr wm 0
.nr wp \w'struct\ confd_auth_ctx\ *actx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_auth_seterr("
.br
.BI "struct\ confd_auth_ctx\ *" "actx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_auth_seterr(struct\ confd_auth_ctx\ *" "actx" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function can be used to provide a text message when the callback returns CONFD_ERR\&. If used when rejecting a successful authentication, the message will be logged in ConfD\*(Aqs audit log (otherwise a generic "rejected by application callback" message is logged)\&.
.SH "AUTHORIZATION CALLBACKS"
.PP
We can register two authorization callbacks with ConfD\*(Aqs AAA subsystem\&. These will be invoked when the northbound agents check that a command or a data access is allowed by the AAA access rules\&. The callbacks can partially or completely replace the access checks done within the AAA subsystem, and they may accept or reject the access\&. Typically many access checks are done during the processing of commands etc, and using these callbacks can thus have a significant performance impact\&. Unless it is a requirement to query an external authorization mechanism, it is far better to only configure access rules in the AAA data model (see the
\m[blue]\fBAAA chapter in the User Guide\fR\m[])\&.
.PP
The callbacks will only be invoked if they are both enabled via
/confdConfig/aaa/authorization/callback/enabled
in
confd\&.conf
(see
\m[blue]\fBconfd\&.conf(5)\fR\m[]) and registered as described here\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If the callbacks are enabled in
confd\&.conf
but no registration has been done, or if invocation keeps failing for some reason,
\fIall\fR
access checks will be rejected\&.
.sp .5v
.RE
.nr wf \w'int\ confd_register_authorization_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_authorization_cbs\ *acb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_authorization_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_authorization_cbs\ *" "acb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_authorization_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_authorization_cbs\ *" "acb" ");" \}
.PP
Registers the authorization callbacks\&. The
\fBstruct confd_authorization_cbs\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_authorization_cbs {
    int cmd_filter;
    int data_filter;
    int (*chk_cmd_access)(struct confd_authorization_ctx *actx,
                          char **cmdtokens, int ntokens, int cmdop);
    int (*chk_data_access)(struct confd_authorization_ctx *actx,
                           u_int32_t hashed_ns, confd_hkeypath_t *hkp,
                           int dataop, int how);
};
.fi
.if n \{\
.RE
.\}
.PP
Both callbacks are optional, i\&.e\&. we can set the function pointer in
\fBstruct confd_authorization_cbs\fR
to NULL if we don\*(Aqt want the corresponding callback invocation\&. In this case the AAA subsystem will handle the access check as if the callback was registered, but always replied with
\fBCONFD_ACCESS_RESULT_DEFAULT\fR
(see below)\&.
.PP
The
\fIcmd_filter\fR
and
\fIdata_filter\fR
elements can be used to prevent access checks from causing invocation of a callback even though it is registered\&. If we do not want any filtering, they must be set to zero\&. The value is a bitmask obtained by ORing together values: For
\fIcmd_filter\fR, we can use the possible values for
\fIcmdop\fR
(see below), preventing the corresponding invocations of
\fBchk_cmd_access()\fR\&. For
\fIdata_filter\fR, we can use the possible values for
\fIdataop\fR
and
\fIhow\fR
(see below), preventing the corresponding invocation of
\fBchk_data_access()\fR\&. If the callback invocation is prevented by filtering, the AAA subsystem will handle the access check as if the callback had replied with
\fBCONFD_ACCESS_RESULT_CONTINUE\fR
(see below)\&.
.PP
Both callbacks are invoked with a pointer to an authorization context that provides information about the user session that the access check pertains to, and the group list for that session\&. The
\fBstruct confd_authorization_ctx\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_authorization_ctx {
    struct confd_user_info *uinfo;
    int ngroups;
    char **groups;
    struct confd_daemon_ctx *dx;
    /* ConfD internal fields */
    int result;
    int query_ref;
};
.fi
.if n \{\
.RE
.\}
.PP
\fBchk_cmd_access()\fR
.RS 4
This callback is invoked for command authorization, i\&.e\&. it corresponds to the rules under
/aaa/authorization/cmdrules
in the AAA data model\&.
\fIcmdtokens\fR
is an array of
\fIntokens\fR
NUL\-terminated strings representing the command to be checked, corresponding to the
command
leaf in the
cmdrule
list\&. If
/confdConfig/cli/modeInfoInAAA
is enabled in
confd\&.conf
(see
\m[blue]\fBconfd\&.conf(5)\fR\m[]), mode names will be prepended in the
\fIcmdtokens\fR
array\&. The
\fIcmdop\fR
parameter gives the operation, corresponding to the
ops
leaf in the
cmdrule
list\&. The possible values for
\fIcmdop\fR
are:
.PP
\fBCONFD_ACCESS_OP_READ\fR
.RS 4
Read access\&. The CLI will use this during command completion, to filter out alternatives that are disallowed by AAA\&.
.RE
.PP
\fBCONFD_ACCESS_OP_EXECUTE\fR
.RS 4
Execute access\&. This is used when a command is about to be executed\&.
.RE
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This callback may be invoked with
actx\->uinfo == NULL, meaning that no user session has been established for the user yet\&. This will occur e\&.g\&. when the CLI checks whether a user attempting to log in is allowed to (implicitly) execute the command "request system logout user" (J\-CLI) or "logout" (C/I\-CLI) when the maximum number of sessions has already been reached (if allowed, the CLI will ask whether the user wants to terminate one of the existing sessions)\&.
.sp .5v
.RE
.RE
.PP
\fBchk_data_access()\fR
.RS 4
This callback is invoked for data authorization, i\&.e\&. it corresponds to the rules under
/aaa/authorization/datarules
in the AAA data model\&.
\fIhashed_ns\fR
and
\fIhkp\fR
give the namespace and hkeypath of the data node to to be checked, corresponding to the
namespace
and
keypath
leafs in the
datarule
list\&. The
\fIhkp\fR
parameter may be NULL, which means that access to the entire namespace given by
\fIhashed_ns\fR
is requested\&. When a hkeypath is provided, some key elements in the path may be without key values (i\&.e\&. hkp\->v[n][0]\&.type == C_NOEXISTS)\&. This indicates "wildcard" keys, used for CLI tab completion when keys are not fully specified\&. The
\fIdataop\fR
parameter gives the operation, corresponding the
ops
leaf in the
datarule
list\&. The possible values for
\fIdataop\fR
are:
.PP
\fBCONFD_ACCESS_OP_READ\fR
.RS 4
Read access\&.
.RE
.PP
\fBCONFD_ACCESS_OP_EXECUTE\fR
.RS 4
Execute access\&.
.RE
.PP
\fBCONFD_ACCESS_OP_CREATE\fR
.RS 4
Create access\&.
.RE
.PP
\fBCONFD_ACCESS_OP_UPDATE\fR
.RS 4
Update access\&.
.RE
.PP
\fBCONFD_ACCESS_OP_DELETE\fR
.RS 4
Delete access\&.
.RE
.PP
\fBCONFD_ACCESS_OP_WRITE\fR
.RS 4
Write access\&. This is used when the specific write operation (create/update/delete) isn\*(Aqt known yet, e\&.g\&. in CLI command completion or processing of a NETCONF
\fBedit\-config\fR\&.
.RE
.sp
The
\fIhow\fR
parameter is one of:
.PP
\fBCONFD_ACCESS_CHK_INTERMEDIATE\fR
.RS 4
Access to the given data node
\fIor\fR
its descendants is requested\&. This is used e\&.g\&. in CLI command completion or processing of a NETCONF
\fBedit\-config\fR\&.
.RE
.PP
\fBCONFD_ACCESS_CHK_FINAL\fR
.RS 4
Access to the specific data node is requested\&.
.RE
.RE
.nr wf \w'int\ confd_access_reply_result('
.nr wm 0
.nr wp \w'struct\ confd_authorization_ctx\ *actx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ result);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_access_reply_result("
.br
.BI "struct\ confd_authorization_ctx\ *" "actx" ", int\ " "result" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_access_reply_result(struct\ confd_authorization_ctx\ *" "actx" ", int\ " "result" ");" \}
.PP
The callbacks must call this function to report the result of the access check to ConfD, and should normally return CONFD_OK\&. If any other value is returned, it will cause the access check to be rejected\&. The
\fIactx\fR
parameter is the pointer to the authorization context passed in the callback invocation, and
\fIresult\fR
must be one of:
.PP
\fBCONFD_ACCESS_RESULT_ACCEPT\fR
.RS 4
The access is allowed\&. This is a "final verdict", analogous to a "full match" when the AAA rules are used\&.
.RE
.PP
\fBCONFD_ACCESS_RESULT_REJECT\fR
.RS 4
The access is denied\&.
.RE
.PP
\fBCONFD_ACCESS_RESULT_CONTINUE\fR
.RS 4
The access is allowed "so far"\&. I\&.e\&. access to sub\-elements is not necessarily allowed\&. This result is mainly useful when
\fBchk_cmd_access()\fR
is called with
\fIcmdop\fR
==
\fBCONFD_ACCESS_OP_READ\fR
or
\fBchk_data_access()\fR
is called with
\fIhow\fR
==
\fBCONFD_ACCESS_CHK_INTERMEDIATE\fR\&.
.RE
.PP
\fBCONFD_ACCESS_RESULT_DEFAULT\fR
.RS 4
The request should be handled according to the rules configured in the AAA data model\&.
.RE
.nr wf \w'int\ confd_authorization_set_timeout('
.nr wm 0
.nr wp \w'struct\ confd_authorization_ctx\ *actx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_authorization_set_timeout("
.br
.BI "struct\ confd_authorization_ctx\ *" "actx" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_authorization_set_timeout(struct\ confd_authorization_ctx\ *" "actx" ", int\ " "timeout_secs" ");" \}
.PP
The authorization callbacks are invoked on the daemon control socket, and as such are expected to complete quickly, within the timeout specified for
/confdConfig/capi/newSessionTimeout\&. However in case they send requests to a remote server, and such a request needs to be retried, this function can be used to extend the timeout for the current callback invocation\&. The timeout is given in seconds from the point in time when the function is called\&.
.SH "ERROR FORMATTING CALLBACK"
.PP
It is possible to register a callback function to generate customized error messages for ConfD\*(Aqs internally generated errors\&. All the customizable errors are defined with a type and a code in the XML document
$CONFD_DIR/src/confd/errors/errcode\&.xml
in the ConfD release\&. To use this functionality, the application must
#include
the file
confd_errcode\&.h, which defines C constants for the types and codes\&.
.nr wf \w'int\ confd_register_error_cb('
.nr wm 0
.nr wp \w'struct\ confd_daemon_ctx\ *dx,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_error_cb\ *ecb);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int confd_register_error_cb("
.br
.BI "struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_error_cb\ *" "ecb" ");" \}
.el \{\
.HP \n(wfu
.BI "int confd_register_error_cb(struct\ confd_daemon_ctx\ *" "dx" ", const\ struct\ confd_error_cb\ *" "ecb" ");" \}
.PP
Registers the error formatting callback\&. The
\fBstruct confd_error_cb\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_error_cb {
    int error_types;
    void (*format_error)(struct confd_user_info *uinfo,
                         struct confd_errinfo *errinfo,
                         char *default_msg);
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fIerror_types\fR
element is the logical OR of the error types that the callback should handle\&. An application daemon can only register one error formatting callback, and only one daemon can register for each error type\&. The available types are:
.PP
\fBCONFD_ERRTYPE_VALIDATION\fR
.RS 4
Errors detected by ConfD\*(Aqs internal semantic validation of the data model constraints, e\&.g\&. mandatory elements that are unset, dangling references, etc\&. The codes for this type are the
\fIconfd_errno\fR
values corresponding to the validation errors, as resulting e\&.g\&. from a call to
\fBmaapi_apply_trans()\fR
(see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[])\&. I\&.e\&. CONFD_ERR_NOTSET, CONFD_ERR_BAD_KEYREF, etc \- see the \*(Aqid\*(Aq attribute in
errcode\&.xml\&.
.RE
.PP
\fBCONFD_ERRTYPE_BAD_VALUE\fR
.RS 4
Type errors, i\&.e\&. errors generated when an invalid value is given for a leaf in the data model\&. The codes for this type are defined in
confd_errcode\&.h
as CONFD_BAD_VALUE_XXX, where "XXX" is the all\-uppercase form of the code name given in
errcode\&.xml\&.
.RE
.PP
\fBCONFD_ERRTYPE_CLI\fR
.RS 4
CLI\-specific errors\&. The codes for this type are defined in
confd_errcode\&.h
as CONFD_CLI_XXX in the same way as for
\fBCONFD_ERRTYPE_BAD_VALUE\fR\&.
.RE
.PP
\fBCONFD_ERRTYPE_MISC\fR
.RS 4
Miscellaneous errors, which do not fit into the other categories\&. The codes for this type are defined in
confd_errcode\&.h
as CONFD_MISC_XXX in the same way as for
\fBCONFD_ERRTYPE_BAD_VALUE\fR\&.
.RE
.PP
\fBCONFD_ERRTYPE_OPERATION\fR
.RS 4
The same set of errors and codes as for
\fBCONFD_ERRTYPE_VALIDATION\fR, but detected in validation of input parameters for an rpc or action\&.
.RE
.PP
The
\fBformat_error()\fR
callback is invoked with a pointer to a
\fBstruct confd_errinfo\fR, which gives the error type and type\-specific structured information about the details of the error\&. It is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_errinfo {
    int type;  /* CONFD_ERRTYPE_XXX */
    union {
        struct confd_errinfo_validation validation;
        struct confd_errinfo_bad_value bad_value;
        struct confd_errinfo_cli cli;
        struct confd_errinfo_misc misc;
    } info;
};
.fi
.if n \{\
.RE
.\}
.PP
For
\fBCONFD_ERRTYPE_VALIDATION\fR
and
\fBCONFD_ERRTYPE_OPERATION\fR, the
\fIstruct confd_errinfo_validation validation\fR
gives the detailed information, using an
\fIinfo\fR
union that has a specific struct member for each code:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_errinfo_validation {
    int code;  /* CONFD_ERR_NOTSET, CONFD_ERR_TOO_FEW_ELEMS, \&.\&.\&. */
    union {
        struct {
            /* the element given by kp is not set */
            confd_hkeypath_t *kp;
        } notset;
        struct {
            /* kp has n instances, must be at least min */
            confd_hkeypath_t *kp;
            int n, min;
        } too_few_elems;
        struct {
            /* kp has n instances, must be at most max */
            confd_hkeypath_t *kp;
            int n, max;
        } too_many_elems;
        struct {
            /* the elements given by kps1 have the same set
               of values vals as the elements given by kps2
               (kps1, kps2, and vals point to n_elems long arrays) */
            int n_elems;
            confd_hkeypath_t *kps1;
            confd_hkeypath_t *kps2;
            confd_value_t *vals;
        } non_unique;
        struct {
            /* the element given by kp references
               the non\-existing element given by ref
               Note: \*(Aqref\*(Aq may be NULL or have key elements without values
               (ref\->v[n][0]\&.type == C_NOEXISTS) if it cannot be instantiated */
            confd_hkeypath_t *kp;
            confd_hkeypath_t *ref;
        } bad_keyref;
        struct {
            /* the mandatory \*(Aqchoice\*(Aq statement choice in the
               container kp does not have a selected \*(Aqcase\*(Aq */
            confd_value_t *choice;
            confd_hkeypath_t *kp;
        } unset_choice;
        struct {
            /* the \*(Aqmust\*(Aq expression expr for element kp is not satisfied
               \- error_message and and error_app_tag are NULL if not given
               in the \*(Aqmust\*(Aq; val points to the value of the element if it
               has one, otherwise it is NULL */
            char *expr;
            confd_hkeypath_t *kp;
            char *error_message;
            char *error_app_tag;
            confd_value_t *val;
        } must_failed;
        struct {
            /* the element kp has the instance\-identifier value instance,
               which doesn\*(Aqt exist, but require\-instance is \*(Aqtrue\*(Aq */
            confd_hkeypath_t *kp;
            confd_hkeypath_t *instance;
        } missing_instance;
        struct {
            /* the element kp has the instance\-identifier value instance,
               which doesn\*(Aqt conform to the specified path filters */
            confd_hkeypath_t *kp;
            confd_hkeypath_t *instance;
        } invalid_instance;
        struct {
            /* the expression for a configuration policy rule evaluated to
               \*(Aqfalse\*(Aq \- error_message is the associated error message */
            char *error_message;
        } policy_failed;
        struct {
            /* the XPath expression expr, for the configuration policy
               rule with key name, could not be compiled due to msg */
            char *name;
            char *expr;
            char *msg;
        } policy_compilation_failed;
        struct {
            /* the expression expr, for the configuration policy rule
               with key name, failed XPath evaluation due to msg */
            char *name;
            char *expr;
            char *msg;
        } policy_evaluation_failed;
    } info;
    /* These are only provided for CONFD_ERRTYPE_VALIDATION */
    int test;            /* 1 if \*(Aqvalidate\*(Aq, 0 if \*(Aqcommit\*(Aq */
    struct confd_trans_ctx *tctx; /* only valid for duration of callback */
};
.fi
.if n \{\
.RE
.\}
.PP
The member structs are named as the
\fIconfd_errno\fR
values that are used for the
\fIcode\fR
elements, i\&.e\&.
\fInotset\fR
for CONFD_ERR_NOTSET, etc\&. For
\fBCONFD_ERRTYPE_VALIDATION\fR, the callback also has full information about the transaction that failed validation via the
\fIstruct confd_trans_ctx *tctx\fR
element \- it is even possible to use
\fBmaapi_attach()\fR
(see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]) to attach to the transaction and read arbitrary data from it, in case the data directly related to the error (as given in the code\-specific struct) is not sufficient\&.
.PP
For the other error types, the corresponding
\fIconfd_errinfo_xxx\fR
struct gives the code and an array with the parameters for the default error message, as defined by the
<fmt>
element in
errcode\&.xml:
.sp
.if n \{\
.RS 4
.\}
.nf
enum confd_errinfo_ptype {
    CONFD_ERRINFO_KEYPATH,
    CONFD_ERRINFO_STRING
};
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_errinfo_param {
    enum confd_errinfo_ptype type;
    union {
        confd_hkeypath_t *kp;
        char *str;
    } val;
};
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_errinfo_bad_value {
    int code;
    int n_params;
    struct confd_errinfo_param *params;
};
.fi
.if n \{\
.RE
.\}
.PP
The parameters in the
\fIparams\fR
array are given in the order they appear in the
<fmt>
specification\&. Parameters that are specified as
{path}
have
\fIparams[n]\&.type\fR
set to
\fBCONFD_ERRINFO_KEYPATH\fR, and are represented as a
\fBconfd_hkeypath_t\fR
that can be accessed via
\fIparams[n]\&.val\&.kp\fR\&. All other parameters are represented as strings, i\&.e\&.
\fIparams[n]\&.type\fR
is
\fBCONFD_ERRINFO_STR\fR
and the string value can be accessed via
\fIparams[n]\&.val\&.str\fR\&. The
\fIstruct confd_errinfo_cli cli\fR
and
\fIstruct confd_errinfo_misc misc\fR
union members have the same form as
\fIstruct confd_errinfo_bad_value\fR
shown above\&.
.PP
Finally, the
\fIdefault_msg\fR
callback parameter gives the default error message that will be reported to the user if the
\fBformat_error()\fR
function does not generate a replacement\&.
.nr wf \w'void\ confd_error_seterr('
.nr wm 0
.nr wp \w'struct\ confd_user_info\ *uinfo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void confd_error_seterr("
.br
.BI "struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "void confd_error_seterr(struct\ confd_user_info\ *" "uinfo" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function must be called by
\fBformat_error()\fR
to provide a replacement of the default error message\&. If
\fBformat_error()\fR
returns without calling
\fBconfd_error_seterr()\fR, the default message will be used\&.
.PP
Here is an example that targets a specific validation error for a specific element in the data model\&. For this case only, it replaces ConfD\*(Aqs internally generated messages of the form:
.PP
"too many \*(Aqprotocol bgp\*(Aq, 2 configured, at most 1 must be configured"
.PP
with
.PP
"Only 1 bgp instance is supported, cannot define 2"
.sp
.if n \{\
.RS 4
.\}
.nf
#include <confd_lib\&.h>
#include <confd_dp\&.h>
#include <confd_errcode\&.h>
\&.
\&.
int main(int argc, char **argv)
{
     struct confd_error_cb ecb;
     \&.
     \&.
     memset(&ecb, 0, sizeof(ecb));
     ecb\&.error_types = CONFD_ERRTYPE_VALIDATION;
     ecb\&.format_error = format_error;
     if (confd_register_error_cb(dctx, &ecb) != CONFD_OK)
          confd_fatal("Couldn\*(Aqt register error callback\en");
     \&.
}

static void format_error(struct confd_user_info *uinfo,
                         struct confd_errinfo *errinfo,
                         char *default_msg)
{
     struct confd_errinfo_validation *err;
     confd_hkeypath_t *kp;

     err = &errinfo\->info\&.validation;
     if (err\->code == CONFD_ERR_TOO_MANY_ELEMS) {
          kp = err\->info\&.too_many_elems\&.kp;
          if (CONFD_GET_XMLTAG(&kp\->v[0][0]) == myns_bgp &&
              CONFD_GET_XMLTAG(&kp\->v[1][0]) == myns_protocol) {
              confd_error_seterr(uinfo,
                                 "Only %d bgp instance is supported, "
                                 "cannot define %d",
                                 err\->info\&.too_many_elems\&.max,
                                 err\->info\&.too_many_elems\&.n);
          }
     }
}
.fi
.if n \{\
.RE
.\}
.PP
The CLI\-specific "Aborted: " prefix is not included in the message for this error type \- if we wanted to replace that too, we could include the
\fBCONFD_ERRTYPE_CLI\fR
error type in the registration and process the
\fBCONFD_CLI_COMMAND_ABORTED\fR
error code for this type, see
errcode\&.xml\&.
.SH "SEE ALSO"
.PP
\fBconfd.conf\fR(5)
\- ConfD daemon configuration file format
.PP
The ConfD User Guide
.SH "AUTHOR"
.PP
 <\&support@tail\-f\&.com\&>
.RS 4
.RE
.SH "COPYRIGHT"
.br
Copyright \(co 2018 Tail-f Systems AB
.br
