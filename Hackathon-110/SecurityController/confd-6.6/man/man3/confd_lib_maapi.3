'\" t
.\"     Title: confd_lib_maapi
.\"    Author:  <support@tail-f.com>
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 03/02/2018
.\"    Manual: ConfD Manual
.\"    Source: Tail-f Systems
.\"  Language: English
.\"
.TH "CONFD_LIB_MAAPI" "3" "03/02/2018" "Tail-f Systems" "ConfD Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
confd_lib_maapi \- MAAPI (Management Agent API)\&. A library for connecting to ConfD with a read/write interface inside transactions\&.
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <confd_lib\&.h>
#include <confd_maapi\&.h>
      
.fi
.ft
.nr wf \w'int\ maapi_start_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *username,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **groups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numgroups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_user_session("
.br
.BI "int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", enum\ confd_proto\ " "prot" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_user_session(int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", enum\ confd_proto\ " "prot" ");" \}
.nr wf \w'int\ maapi_start_user_session2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *username,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **groups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numgroups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ src_port,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_user_session2("
.br
.BI "int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_user_session2(int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ");" \}
.nr wf \w'int\ maapi_start_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ dbname,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans(int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ");" \}
.nr wf \w'int\ maapi_start_trans2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ dbname,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans2("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans2(int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ");" \}
.nr wf \w'int\ maapi_start_trans_flags('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ dbname,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans_flags("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans_flags(int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ");" \}
.nr wf \w'int\ maapi_connect('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr*\ srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ srv_sz);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_connect("
.br
.BI "int\ " "sock" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_connect(int\ " "sock" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.nr wf \w'int\ maapi_load_schemas('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_schemas("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_schemas(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_load_schemas_list('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ u_int32_t\ *nshash,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ int\ *nsflags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_ns);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_schemas_list("
.br
.BI "int\ " "sock" ", int\ " "flags" ", const\ u_int32_t\ *" "nshash" ", const\ int\ *" "nsflags" ", int\ " "num_ns" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_schemas_list(int\ " "sock" ", int\ " "flags" ", const\ u_int32_t\ *" "nshash" ", const\ int\ *" "nsflags" ", int\ " "num_ns" ");" \}
.nr wf \w'int\ maapi_get_schema_file_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **buf);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_schema_file_path("
.br
.BI "int\ " "sock" ", char\ **" "buf" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_schema_file_path(int\ " "sock" ", char\ **" "buf" ");" \}
.nr wf \w'int\ maapi_close('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_close("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_close(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_start_user_session3('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *username,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **groups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numgroups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ src_port,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *vendor,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *product,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *version,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *client_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_user_session3("
.br
.BI "int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_user_session3(int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.nr wf \w'int\ maapi_end_user_session('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_end_user_session("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_end_user_session(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_kill_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_kill_user_session("
.br
.BI "int\ " "sock" ", int\ " "usessid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_kill_user_session(int\ " "sock" ", int\ " "usessid" ");" \}
.nr wf \w'int\ maapi_get_user_sessions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ res[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_sessions("
.br
.BI "int\ " "sock" ", int\ " "res[]" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_sessions(int\ " "sock" ", int\ " "res[]" ", int\ " "n" ");" \}
.nr wf \w'int\ maapi_get_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_user_info\ *us);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_session("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_info\ *" "us" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_session(int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_info\ *" "us" ");" \}
.nr wf \w'int\ maapi_get_my_user_session_id('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_my_user_session_id("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_my_user_session_id(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_set_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_user_session("
.br
.BI "int\ " "sock" ", int\ " "usessid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_user_session(int\ " "sock" ", int\ " "usessid" ");" \}
.nr wf \w'int\ maapi_get_user_session_identification('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_user_identification\ *uident);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_session_identification("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_identification\ *" "uident" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_session_identification(int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_identification\ *" "uident" ");" \}
.nr wf \w'int\ maapi_get_user_session_opaque('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **opaque);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_session_opaque("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", char\ **" "opaque" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_session_opaque(int\ " "sock" ", int\ " "usessid" ", char\ **" "opaque" ");" \}
.nr wf \w'int\ maapi_get_authorization_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_authorization_info\ **ainfo);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_authorization_info("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", struct\ confd_authorization_info\ **" "ainfo" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_authorization_info(int\ " "sock" ", int\ " "usessid" ", struct\ confd_authorization_info\ **" "ainfo" ");" \}
.nr wf \w'int\ maapi_set_next_user_session_id('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_next_user_session_id("
.br
.BI "int\ " "sock" ", int\ " "usessid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_next_user_session_id(int\ " "sock" ", int\ " "usessid" ");" \}
.nr wf \w'int\ maapi_lock('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_lock("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_lock(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.nr wf \w'int\ maapi_unlock('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_unlock("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_unlock(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.nr wf \w'int\ maapi_is_lock_set('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_is_lock_set("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_is_lock_set(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.nr wf \w'int\ maapi_lock_partial('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *xpaths[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nxpaths,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *lockid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_lock_partial("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ", char\ *" "xpaths[]" ", int\ " "nxpaths" ", int\ *" "lockid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_lock_partial(int\ " "sock" ", enum\ confd_dbname\ " "name" ", char\ *" "xpaths[]" ", int\ " "nxpaths" ", int\ *" "lockid" ");" \}
.nr wf \w'int\ maapi_unlock_partial('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ lockid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_unlock_partial("
.br
.BI "int\ " "sock" ", int\ " "lockid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_unlock_partial(int\ " "sock" ", int\ " "lockid" ");" \}
.nr wf \w'int\ maapi_candidate_validate('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_validate("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_validate(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_delete_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_delete_config("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_delete_config(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.nr wf \w'int\ maapi_candidate_commit('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_commit("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_commit(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_candidate_commit_persistent('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_commit_persistent("
.br
.BI "int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_commit_persistent(int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.nr wf \w'int\ maapi_candidate_commit_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *label,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *comment);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_commit_info("
.br
.BI "int\ " "sock" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_commit_info(int\ " "sock" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.nr wf \w'int\ maapi_candidate_confirmed_commit('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_confirmed_commit("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_confirmed_commit(int\ " "sock" ", int\ " "timeoutsecs" ");" \}
.nr wf \w'int\ maapi_candidate_confirmed_commit_persistent('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_confirmed_commit_persistent("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_confirmed_commit_persistent(int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ");" \}
.nr wf \w'int\ maapi_candidate_confirmed_commit_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *label,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *comment);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_confirmed_commit_info("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_confirmed_commit_info(int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.nr wf \w'int\ maapi_candidate_abort_commit('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_abort_commit("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_abort_commit(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_candidate_abort_commit_persistent('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_abort_commit_persistent("
.br
.BI "int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_abort_commit_persistent(int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.nr wf \w'int\ maapi_candidate_reset('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_reset("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_reset(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_confirmed_commit_in_progress('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_confirmed_commit_in_progress("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_confirmed_commit_in_progress(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_copy_running_to_startup('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy_running_to_startup("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy_running_to_startup(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_is_running_modified('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_is_running_modified("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_is_running_modified(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_is_candidate_modified('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_is_candidate_modified("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_is_candidate_modified(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_start_trans_flags2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ dbname,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *vendor,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *product,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *version,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *client_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans_flags2("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans_flags2(int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.nr wf \w'int\ maapi_start_trans_in_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans_in_trans("
.br
.BI "int\ " "sock" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans_in_trans(int\ " "sock" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_finish_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_finish_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_finish_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_validate_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ unlock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ forcevalidation);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_validate_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "unlock" ", int\ " "forcevalidation" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_validate_trans(int\ " "sock" ", int\ " "thandle" ", int\ " "unlock" ", int\ " "forcevalidation" ");" \}
.nr wf \w'int\ maapi_prepare_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_prepare_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_prepare_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_prepare_trans_flags('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_prepare_trans_flags("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_prepare_trans_flags(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.nr wf \w'int\ maapi_commit_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_commit_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_commit_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_abort_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_abort_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_abort_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_apply_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ keepopen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_apply_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_apply_trans(int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ");" \}
.nr wf \w'int\ maapi_apply_trans_flags('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ keepopen,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_apply_trans_flags("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_apply_trans_flags(int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ", int\ " "flags" ");" \}
.nr wf \w'int\ maapi_apply_trans_with_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ keepopen,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_apply_trans_with_result("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ", int\ " "flags" ", const\ char\ *" "tag" ", int\ " "timeoutsecs" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_apply_trans_with_result(int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ", int\ " "flags" ", const\ char\ *" "tag" ", int\ " "timeoutsecs" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ");" \}
.nr wf \w'int\ maapi_commit_queue_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ ncs_commit_queue_result\ *result);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_commit_queue_result("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "timeoutsecs" ", struct\ ncs_commit_queue_result\ *" "result" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_commit_queue_result(int\ " "sock" ", int\ " "thandle" ", int\ " "timeoutsecs" ", struct\ ncs_commit_queue_result\ *" "result" ");" \}
.nr wf \w'int\ maapi_set_namespace('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_namespace("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "hashed_ns" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_namespace(int\ " "sock" ", int\ " "thandle" ", int\ " "hashed_ns" ");" \}
.nr wf \w'int\ maapi_cd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cd(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_pushd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_pushd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_pushd(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_popd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_popd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_popd(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_getcwd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'size_t\ strsz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *curdir);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_getcwd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_getcwd(int\ " "sock" ", int\ " "thandle" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.nr wf \w'int\ maapi_getcwd_kpath('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **kp);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_getcwd_kpath("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_hkeypath_t\ **" "kp" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_getcwd_kpath(int\ " "sock" ", int\ " "thandle" ", confd_hkeypath_t\ **" "kp" ");" \}
.nr wf \w'int\ maapi_exists('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_exists("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_exists(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_num_instances('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_num_instances("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_num_instances(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_int8_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int8_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_int8_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_int8_elem(int\ " "sock" ", int\ " "thandle" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_int16_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int16_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_int16_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_int16_elem(int\ " "sock" ", int\ " "thandle" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_int32_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_int32_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_int32_elem(int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_int64_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_int64_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_int64_elem(int\ " "sock" ", int\ " "thandle" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_u_int8_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int8_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_u_int8_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_u_int8_elem(int\ " "sock" ", int\ " "thandle" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_u_int16_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int16_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_u_int16_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_u_int16_elem(int\ " "sock" ", int\ " "thandle" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_u_int32_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_u_int32_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_u_int32_elem(int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_u_int64_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_u_int64_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_u_int64_elem(int\ " "sock" ", int\ " "thandle" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_ipv4_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ in_addr\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_ipv4_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_ipv4_elem(int\ " "sock" ", int\ " "thandle" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_ipv6_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ in6_addr\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_ipv6_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_ipv6_elem(int\ " "sock" ", int\ " "thandle" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_double_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'double\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_double_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_double_elem(int\ " "sock" ", int\ " "thandle" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_bool_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_bool_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_bool_elem(int\ " "sock" ", int\ " "thandle" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_datetime_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_datetime_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_datetime_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_date_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_date\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_date_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_date_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_time_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_time\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_time_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_time_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_duration_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_duration\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_duration_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_duration_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_enum_value_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_enum_value_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_enum_value_elem(int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_bit32_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_bit32_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_bit32_elem(int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_bit64_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_bit64_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_bit64_elem(int\ " "sock" ", int\ " "thandle" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_bitbig_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_bitbig_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_bitbig_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_objectref_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_objectref_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_hkeypath_t\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_objectref_elem(int\ " "sock" ", int\ " "thandle" ", confd_hkeypath_t\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_oid_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_snmp_oid\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_oid_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_oid_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_buf_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_buf_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_buf_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_str_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_str_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ *" "buf" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_str_elem(int\ " "sock" ", int\ " "thandle" ", char\ *" "buf" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_binary_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_binary_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_binary_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_hexstr_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_hexstr_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_hexstr_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_qname_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **prefix,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *prefixsz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *namesz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_qname_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_qname_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_list_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_list_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_list_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_ipv4prefix_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv4_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_ipv4prefix_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_ipv4prefix_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_ipv6prefix_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv6_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_ipv6prefix_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_ipv6prefix_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_decimal64_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_decimal64\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_decimal64_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_decimal64\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_decimal64_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_decimal64\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_identityref_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_identityref\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_identityref_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_identityref\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_identityref_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_identityref\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_ipv4_and_plen_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv4_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_ipv4_and_plen_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_ipv4_and_plen_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_ipv6_and_plen_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv6_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_ipv6_and_plen_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_ipv6_and_plen_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_dquad_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_dotted_quad\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_dquad_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_dotted_quad\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_dquad_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_dotted_quad\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_vget_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_vget_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_vget_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.nr wf \w'int\ maapi_init_cursor('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ maapi_cursor\ *mc,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_init_cursor("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ maapi_cursor\ *" "mc" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_init_cursor(int\ " "sock" ", int\ " "thandle" ", struct\ maapi_cursor\ *" "mc" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_next('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_next("
.br
.BI "struct\ maapi_cursor\ *" "mc" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_next(struct\ maapi_cursor\ *" "mc" ");" \}
.nr wf \w'int\ maapi_find_next('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_find_next_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *inkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n_inkeys);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_find_next("
.br
.BI "struct\ maapi_cursor\ *" "mc" ", enum\ confd_find_next_type\ " "type" ", confd_value_t\ *" "inkeys" ", int\ " "n_inkeys" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_find_next(struct\ maapi_cursor\ *" "mc" ", enum\ confd_find_next_type\ " "type" ", confd_value_t\ *" "inkeys" ", int\ " "n_inkeys" ");" \}
.nr wf \w'void\ maapi_destroy_cursor('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void maapi_destroy_cursor("
.br
.BI "struct\ maapi_cursor\ *" "mc" ");" \}
.el \{\
.HP \n(wfu
.BI "void maapi_destroy_cursor(struct\ maapi_cursor\ *" "mc" ");" \}
.nr wf \w'int\ maapi_set_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_set_elem2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *strval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_elem2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_elem2(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_vset_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_vset_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_vset_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.nr wf \w'int\ maapi_create('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_create("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_create(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_delete('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_delete("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_delete(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_object("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_object(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_objects('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nobj);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_objects("
.br
.BI "struct\ maapi_cursor\ *" "mc" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ *" "nobj" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_objects(struct\ maapi_cursor\ *" "mc" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ *" "nobj" ");" \}
.nr wf \w'int\ maapi_get_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_values("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_values(int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_set_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_object("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_object(int\ " "sock" ", int\ " "thandle" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_set_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_values("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_values(int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_case('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *rcase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_case("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_case(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_get_attrs('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *attrs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attrs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_attr_value_t\ **attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *num_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_attrs("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "attrs" ", int\ " "num_attrs" ", confd_attr_value_t\ **" "attr_vals" ", int\ *" "num_vals" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_attrs(int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "attrs" ", int\ " "num_attrs" ", confd_attr_value_t\ **" "attr_vals" ", int\ *" "num_vals" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_set_attr('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ attr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_attr("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int32_t\ " "attr" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_attr(int\ " "sock" ", int\ " "thandle" ", u_int32_t\ " "attr" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_delete_all('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_delete_how\ how);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_delete_all("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_delete_how\ " "how" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_delete_all(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_delete_how\ " "how" ");" \}
.nr wf \w'int\ maapi_revert('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_revert("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_revert(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_set_flags('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_flags("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_flags(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.nr wf \w'int\ maapi_set_delayed_when('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ on);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_delayed_when("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "on" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_delayed_when(int\ " "sock" ", int\ " "thandle" ", int\ " "on" ");" \}
.nr wf \w'int\ maapi_set_label('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *label);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_label("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "label" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_label(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "label" ");" \}
.nr wf \w'int\ maapi_set_comment('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *comment);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_comment("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "comment" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_comment(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "comment" ");" \}
.nr wf \w'int\ maapi_copy('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ from_thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ to_thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy("
.br
.BI "int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy(int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ");" \}
.nr wf \w'int\ maapi_copy_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ from_thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ to_thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy_path("
.br
.BI "int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy_path(int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_copy_tree('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *from,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *tofmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy_tree("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy_tree(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_insert('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_insert("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_insert(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_move('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t*\ tokey,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_move("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_move(int\ " "sock" ", int\ " "thandle" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_move_ordered('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_move_where\ where,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t*\ tokey,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_move_ordered("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_move_where\ " "where" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_move_ordered(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_move_where\ " "where" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_create('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_create("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_create(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_set_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_set_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_set_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_set_elem2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *strval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_set_elem2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_set_elem2(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_set_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_set_values("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_set_values(int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_insert('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_insert("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_insert(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_copy_tree('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *from,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *tofmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_copy_tree("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_copy_tree(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_ncs_apply_template('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *template_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_name_value\ *variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *rootfmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_ncs_apply_template("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_ncs_apply_template(int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_ncs_apply_template('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *template_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_name_value\ *variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *rootfmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_ncs_apply_template("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_ncs_apply_template(int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_ncs_get_templates('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ ***templates,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *num_templates);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_ncs_get_templates("
.br
.BI "int\ " "sock" ", char\ ***" "templates" ", int\ *" "num_templates" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_ncs_get_templates(int\ " "sock" ", char\ ***" "templates" ", int\ *" "num_templates" ");" \}
.nr wf \w'int\ maapi_ncs_write_service_log_entry('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *msg,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *level,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_ncs_write_service_log_entry("
.br
.BI "int\ " "sock" ", const\ char\ *" "msg" ", confd_value_t\ *" "type" ", confd_value_t\ *" "level" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_ncs_write_service_log_entry(int\ " "sock" ", const\ char\ *" "msg" ", confd_value_t\ *" "type" ", confd_value_t\ *" "level" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_authenticate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *user,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *pass,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *groups[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_authenticate("
.br
.BI "int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_authenticate(int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.nr wf \w'int\ maapi_authenticate2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *user,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *pass,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ src_port,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *groups[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_authenticate2("
.br
.BI "int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", const\ char\ *" "context" ", enum\ confd_proto\ " "prot" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_authenticate2(int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", const\ char\ *" "context" ", enum\ confd_proto\ " "prot" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.nr wf \w'int\ maapi_validate_token('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *token,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ src_port,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *groups[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_validate_token("
.br
.BI "int\ " "sock" ", const\ char\ *" "token" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", const\ char\ *" "context" ", enum\ confd_proto\ " "prot" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_validate_token(int\ " "sock" ", const\ char\ *" "token" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", const\ char\ *" "context" ", enum\ confd_proto\ " "prot" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.nr wf \w'int\ maapi_attach('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_trans_ctx\ *ctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_attach("
.br
.BI "int\ " "sock" ", int\ " "hashed_ns" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_attach(int\ " "sock" ", int\ " "hashed_ns" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.nr wf \w'int\ maapi_attach2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_attach2("
.br
.BI "int\ " "sock" ", int\ " "hashed_ns" ", int\ " "usid" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_attach2(int\ " "sock" ", int\ " "hashed_ns" ", int\ " "usid" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_attach_init('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_attach_init("
.br
.BI "int\ " "sock" ", int\ *" "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_attach_init(int\ " "sock" ", int\ *" "thandle" ");" \}
.nr wf \w'int\ maapi_detach('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_trans_ctx\ *ctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_detach("
.br
.BI "int\ " "sock" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_detach(int\ " "sock" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.nr wf \w'int\ maapi_detach2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_detach2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_detach2(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_diff_iterate(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.nr wf \w'int\ maapi_keypath_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_keypath_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_keypath_diff_iterate(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_diff_iterate_resume('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ reply,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *resumestate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_diff_iterate_resume("
.br
.BI "int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_diff_iterate_resume(int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.nr wf \w'int\ maapi_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_attr_value_t\ *attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_iterate("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_iterate(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_iterate_resume('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ reply,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_attr_value_t\ *attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *resumestate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_iterate_resume("
.br
.BI "int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_iterate_resume(int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.nr wf \w'int\ maapi_get_running_db_status('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_running_db_status("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_running_db_status(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_set_running_db_status('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ status);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_running_db_status("
.br
.BI "int\ " "sock" ", int\ " "status" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_running_db_status(int\ " "sock" ", int\ " "status" ");" \}
.nr wf \w'int\ maapi_list_rollbacks('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ maapi_rollback\ *rp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *rp_size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_list_rollbacks("
.br
.BI "int\ " "sock" ", struct\ maapi_rollback\ *" "rp" ", int\ *" "rp_size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_list_rollbacks(int\ " "sock" ", struct\ maapi_rollback\ *" "rp" ", int\ *" "rp_size" ");" \}
.nr wf \w'int\ maapi_load_rollback('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ rollback_num);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_rollback("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "rollback_num" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_rollback(int\ " "sock" ", int\ " "thandle" ", int\ " "rollback_num" ");" \}
.nr wf \w'int\ maapi_request_action('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *params,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nparams,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_request_action("
.br
.BI "int\ " "sock" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", int\ " "hashed_ns" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_request_action(int\ " "sock" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", int\ " "hashed_ns" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_request_action_th('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *params,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nparams,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_request_action_th("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_request_action_th(int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_request_action_str_th('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **output,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cmd_fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *path_fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_request_action_str_th("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ **" "output" ", const\ char\ *" "cmd_fmt" ", const\ char\ *" "path_fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_request_action_str_th(int\ " "sock" ", int\ " "thandle" ", char\ **" "output" ", const\ char\ *" "cmd_fmt" ", const\ char\ *" "path_fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_xpath2kpath('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *xpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **hkp);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_xpath2kpath("
.br
.BI "int\ " "sock" ", const\ char\ *" "xpath" ", confd_hkeypath_t\ **" "hkp" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_xpath2kpath(int\ " "sock" ", const\ char\ *" "xpath" ", confd_hkeypath_t\ **" "hkp" ");" \}
.nr wf \w'int\ maapi_user_message('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *to,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *message,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *sender);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_user_message("
.br
.BI "int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ", const\ char\ *" "sender" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_user_message(int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ", const\ char\ *" "sender" ");" \}
.nr wf \w'int\ maapi_sys_message('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *to,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *message);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_sys_message("
.br
.BI "int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_sys_message(int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.nr wf \w'int\ maapi_prio_message('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *to,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *message);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_prio_message("
.br
.BI "int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_prio_message(int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.nr wf \w'int\ maapi_cli_diff_cmd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle_old,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_diff_cmd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "thandle_old" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_diff_cmd(int\ " "sock" ", int\ " "thandle" ", int\ " "thandle_old" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_cli_accounting('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *user,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cmdstr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_accounting("
.br
.BI "int\ " "sock" ", const\ char\ *" "user" ", const\ int\ " "usid" ", const\ char\ *" "cmdstr" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_accounting(int\ " "sock" ", const\ char\ *" "user" ", const\ int\ " "usid" ", const\ char\ *" "cmdstr" ");" \}
.nr wf \w'int\ maapi_cli_path_cmd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_path_cmd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_path_cmd(int\ " "sock" ", int\ " "thandle" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_cli_cmd_to_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *line,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsize,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *path,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ psize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_to_path("
.br
.BI "int\ " "sock" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_to_path(int\ " "sock" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.nr wf \w'int\ maapi_cli_cmd_to_path2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *line,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsize,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *path,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ psize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_to_path2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_to_path2(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.nr wf \w'int\ maapi_cli_prompt('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_prompt2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_prompt_oneof('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ count,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt_oneof("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt_oneof(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", char\ *" "res" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_prompt_oneof2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ count,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt_oneof2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt_oneof2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_read_eof('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_read_eof("
.br
.BI "int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_read_eof(int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_read_eof2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_read_eof2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_read_eof2(int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_write('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_write("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_write(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_cmd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_cli_cmd2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ");" \}
.nr wf \w'int\ maapi_cli_cmd3('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd3("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd3(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.nr wf \w'int\ maapi_cli_cmd4('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd4("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd4(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.nr wf \w'int\ maapi_cli_cmd_io('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_io("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_io(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.nr wf \w'int\ maapi_cli_cmd_io2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_io2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_io2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.nr wf \w'int\ maapi_cli_cmd_io_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_io_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_io_result(int\ " "sock" ", int\ " "id" ");" \}
.nr wf \w'int\ maapi_cli_printf('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_printf("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_printf(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_cli_vprintf('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_vprintf("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_vprintf(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.nr wf \w'int\ maapi_cli_set('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *opt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *value);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_set("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", const\ char\ *" "value" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_set(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", const\ char\ *" "value" ");" \}
.nr wf \w'int\ maapi_cli_get('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *opt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_get("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_get(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", char\ *" "res" ", int\ " "size" ");" \}
.nr wf \w'int\ maapi_set_readonly_mode('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flag);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_readonly_mode("
.br
.BI "int\ " "sock" ", int\ " "flag" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_readonly_mode(int\ " "sock" ", int\ " "flag" ");" \}
.nr wf \w'int\ maapi_disconnect_remote('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *address);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_disconnect_remote("
.br
.BI "int\ " "sock" ", const\ char\ *" "address" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_disconnect_remote(int\ " "sock" ", const\ char\ *" "address" ");" \}
.nr wf \w'int\ maapi_disconnect_sockets('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *sockets,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsocks);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_disconnect_sockets("
.br
.BI "int\ " "sock" ", int\ *" "sockets" ", int\ " "nsocks" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_disconnect_sockets(int\ " "sock" ", int\ *" "sockets" ", int\ " "nsocks" ");" \}
.nr wf \w'int\ maapi_save_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_save_config("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_save_config(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_save_config_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_save_config_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_save_config_result(int\ " "sock" ", int\ " "id" ");" \}
.nr wf \w'int\ maapi_load_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *filename);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "filename" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "filename" ");" \}
.nr wf \w'int\ maapi_load_config_cmds('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cmds,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config_cmds("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "cmds" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config_cmds(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "cmds" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_load_config_stream('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config_stream("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config_stream(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.nr wf \w'int\ maapi_load_config_stream_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config_stream_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config_stream_result(int\ " "sock" ", int\ " "id" ");" \}
.nr wf \w'int\ maapi_roll_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_roll_config("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_roll_config(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_roll_config_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_roll_config_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_roll_config_result(int\ " "sock" ", int\ " "id" ");" \}
.nr wf \w'int\ maapi_get_stream_progress('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_stream_progress("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_stream_progress(int\ " "sock" ", int\ " "id" ");" \}
.nr wf \w'int\ maapi_xpath_eval('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *expr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ (*result)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ (*trace)(char\ *),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_xpath_eval("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", int\ (*" "result" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", void\ *" "state" "), void\ (*" "trace" ")(char\ *), void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_xpath_eval(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", int\ (*" "result" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", void\ *" "state" "), void\ (*" "trace" ")(char\ *), void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_xpath_eval_expr('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *expr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ (*trace)(char\ *),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_xpath_eval_expr("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", char\ **" "res" ", void\ (*" "trace" ")(char\ *), const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_xpath_eval_expr(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", char\ **" "res" ", void\ (*" "trace" ")(char\ *), const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_query_start('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *expr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context_node,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ chunk_size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ initial_offset,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_query_result_type\ result_as,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nselect,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *select[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsort,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *sort[]);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_start("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", const\ char\ *" "context_node" ", int\ " "chunk_size" ", int\ " "initial_offset" ", enum\ confd_query_result_type\ " "result_as" ", int\ " "nselect" ", const\ char\ *" "select[]" ", int\ " "nsort" ", const\ char\ *" "sort[]" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_start(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", const\ char\ *" "context_node" ", int\ " "chunk_size" ", int\ " "initial_offset" ", enum\ confd_query_result_type\ " "result_as" ", int\ " "nselect" ", const\ char\ *" "select[]" ", int\ " "nsort" ", const\ char\ *" "sort[]" ");" \}
.nr wf \w'int\ maapi_query_startv('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *expr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context_node,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ chunk_size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ initial_offset,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_query_result_type\ result_as,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ select_nparams,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_startv("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", const\ char\ *" "context_node" ", int\ " "chunk_size" ", int\ " "initial_offset" ", enum\ confd_query_result_type\ " "result_as" ", int\ " "select_nparams" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_startv(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", const\ char\ *" "context_node" ", int\ " "chunk_size" ", int\ " "initial_offset" ", enum\ confd_query_result_type\ " "result_as" ", int\ " "select_nparams" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_query_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_query_result\ **qrs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_result("
.br
.BI "int\ " "sock" ", int\ " "qh" ", struct\ confd_query_result\ **" "qrs" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_result(int\ " "sock" ", int\ " "qh" ", struct\ confd_query_result\ **" "qrs" ");" \}
.nr wf \w'int\ maapi_query_result_count('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_result_count("
.br
.BI "int\ " "sock" ", int\ " "qh" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_result_count(int\ " "sock" ", int\ " "qh" ");" \}
.nr wf \w'int\ maapi_query_free_result('
.nr wm 0
.nr wp \w'struct\ confd_query_result\ *qrs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_free_result("
.br
.BI "struct\ confd_query_result\ *" "qrs" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_free_result(struct\ confd_query_result\ *" "qrs" ");" \}
.nr wf \w'int\ maapi_query_reset_to('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ offset);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_reset_to("
.br
.BI "int\ " "sock" ", int\ " "qh" ", int\ " "offset" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_reset_to(int\ " "sock" ", int\ " "qh" ", int\ " "offset" ");" \}
.nr wf \w'int\ maapi_query_reset('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_reset("
.br
.BI "int\ " "sock" ", int\ " "qh" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_reset(int\ " "sock" ", int\ " "qh" ");" \}
.nr wf \w'int\ maapi_query_stop('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_stop("
.br
.BI "int\ " "sock" ", int\ " "qh" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_stop(int\ " "sock" ", int\ " "qh" ");" \}
.nr wf \w'int\ maapi_do_display('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_do_display("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_do_display(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_install_crypto_keys('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_install_crypto_keys("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_install_crypto_keys(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_init_upgrade('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_init_upgrade("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_init_upgrade(int\ " "sock" ", int\ " "timeoutsecs" ", int\ " "flags" ");" \}
.nr wf \w'int\ maapi_perform_upgrade('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **loadpathdirs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_perform_upgrade("
.br
.BI "int\ " "sock" ", const\ char\ **" "loadpathdirs" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_perform_upgrade(int\ " "sock" ", const\ char\ **" "loadpathdirs" ", int\ " "n" ");" \}
.nr wf \w'int\ maapi_commit_upgrade('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_commit_upgrade("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_commit_upgrade(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_abort_upgrade('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_abort_upgrade("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_abort_upgrade(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_aaa_reload('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_aaa_reload("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_aaa_reload(int\ " "sock" ", int\ " "synchronous" ");" \}
.nr wf \w'int\ maapi_aaa_reload_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_aaa_reload_path("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_aaa_reload_path(int\ " "sock" ", int\ " "synchronous" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_snmpa_reload('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_snmpa_reload("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_snmpa_reload(int\ " "sock" ", int\ " "synchronous" ");" \}
.nr wf \w'int\ maapi_start_phase('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ phase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_phase("
.br
.BI "int\ " "sock" ", int\ " "phase" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_phase(int\ " "sock" ", int\ " "phase" ", int\ " "synchronous" ");" \}
.nr wf \w'int\ maapi_wait_start('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ phase);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_wait_start("
.br
.BI "int\ " "sock" ", int\ " "phase" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_wait_start(int\ " "sock" ", int\ " "phase" ");" \}
.nr wf \w'int\ maapi_reload_config('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_reload_config("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_reload_config(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_reopen_logs('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_reopen_logs("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_reopen_logs(int\ " "sock" ");" \}
.nr wf \w'int\ maapi_stop('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_stop("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_stop(int\ " "sock" ", int\ " "synchronous" ");" \}
.nr wf \w'int\ maapi_rebind_listener('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ listener);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_rebind_listener("
.br
.BI "int\ " "sock" ", int\ " "listener" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_rebind_listener(int\ " "sock" ", int\ " "listener" ");" \}
.nr wf \w'int\ maapi_clear_opcache('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_clear_opcache("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_clear_opcache(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.SH "LIBRARY"
.PP
ConfD
Library, (libconfd,
\fB\-lconfd\fR)
.SH "DESCRIPTION"
.PP
The
libconfd
shared library is used to connect to the ConfD transaction manager\&. The API described in this man page has several purposes\&. We can use MAAPI when we wish to implement our own proprietary management agent\&. We also use MAAPI to attach to already existing ConfD transactions, for example when we wish to implement semantic validation of configuration data in C, and also when we wish to implement CLI wizards in C\&.
.SH "PATHS"
.PP
The majority of the functions described here take as their two last arguments a format string and a variable number of extra arguments as in:
\fBchar *\fR\fIfmt\fR,
\fI\&.\&.\&.\fR);
.PP
The paths for MAAPI work like paths for CDB (see
\m[blue]\fBconfd_lib_cdb(3)\fR\m[]) with the exception that the bracket notation \*(Aq[n]\*(Aq is not allowed for MAAPI paths\&.
.PP
All the functions that take a path on this form also have a
\fBva_list\fR
variant, of the same form as
\fBmaapi_vget_elem()\fR
and
\fBmaapi_vset_elem()\fR, which are the only ones explicitly documented below\&. I\&.e\&. they have a prefix "maapi_v" instead of "maapi_", and take a single va_list argument instead of a variable number of arguments\&.
.SH "FUNCTIONS"
.PP
All functions return CONFD_OK (0), CONFD_ERR (\-1) or CONFD_EOF (\-2) unless otherwise stated\&. Whenever CONFD_ERR is returned from any API function in confd_lib_maapi it is possible to obtain additional information on the error through the symbol
\fIconfd_errno\fR, see the ERRORS section of
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.PP
In the case of CONFD_EOF it means that the socket to
ConfD
has been closed\&.
.nr wf \w'int\ maapi_connect('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr*\ srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ srv_sz);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_connect("
.br
.BI "int\ " "sock" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_connect(int\ " "sock" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.PP
The application has to connect to
ConfD
before it can interact with
ConfD
\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If this call fails (i\&.e\&. does not return CONFD_OK), the socket descriptor must be closed and a new socket created before the call is re\-attempted\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_load_schemas('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_schemas("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_schemas(int\ " "sock" ");" \}
.PP
This function dynamically loads schema information from the ConfD daemon into the library, where it is available to all the library components as described in the
\m[blue]\fBconfd_types(3)\fR\m[]
and
\m[blue]\fBconfd_lib_lib(3)\fR\m[]
man pages\&. See also
\fBconfd_load_schemas()\fR
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_load_schemas_list('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ u_int32_t\ *nshash,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ int\ *nsflags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_ns);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_schemas_list("
.br
.BI "int\ " "sock" ", int\ " "flags" ", const\ u_int32_t\ *" "nshash" ", const\ int\ *" "nsflags" ", int\ " "num_ns" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_schemas_list(int\ " "sock" ", int\ " "flags" ", const\ u_int32_t\ *" "nshash" ", const\ int\ *" "nsflags" ", int\ " "num_ns" ");" \}
.PP
A variant of
\fBmaapi_load_schemas()\fR
that allows for loading a subset of the schema information from the ConfD daemon into the library\&. This means that the loading can be significantly faster in the case of a system with many large data models, with the drawback that the functions that use the schema information will have limited functionality or not work at all\&.
.PP
The
\fIflags\fR
parameter can be given as
\fBCONFD_LOAD_SCHEMA_HASH\fR
to request that the global mapping between strings and hash values for the data model nodes should be loaded\&. If
\fIflags\fR
is given as 0, this mapping is not loaded\&. The mapping is required for use of the functions
\fBconfd_hash2str()\fR,
\fBconfd_str2hash()\fR,
\fBconfd_cs_node_cd()\fR, and
\fBconfd_xpath_pp_kpath()\fR\&. Additionally, without the mapping,
\fBconfd_pp_value()\fR,
\fBconfd_pp_kpath()\fR, and
\fBconfd_pp_kpath_len()\fR, as well as the trace printouts from the library, will print nodes as "tag<N>", where N is the hash value, instead of the node name\&.
.PP
The
\fInshash\fR
parameter is a
\fInum_ns\fR
elements long array of namespace hash values, requesting that schema information should be loaded for the listed namespaces according to the corresponding element of the
\fInsflags\fR
array (also
\fInum_ns\fR
elements long)\&. For each namespace, either or both of these flags may be given:
.PP
\fBCONFD_LOAD_SCHEMA_NODES\fR
.RS 4
This flag requests that the
\fBconfd_cs_node\fR
tree (see
\m[blue]\fBconfd_types(3)\fR\m[]) for the namespace should be loaded\&. This tree is required for the use of the functions
\fBconfd_find_cs_root()\fR,
\fBconfd_find_cs_node()\fR,
\fBconfd_find_cs_node_child()\fR,
\fBconfd_cs_node_cd()\fR,
\fBconfd_register_node_type()\fR,
\fBconfd_get_leaf_list_type()\fR, and
\fBconfd_xpath_pp_kpath()\fR
for the namespace\&. Additionally, the above functions that print a
\fBconfd_hkeypath_t\fR, as well as the library trace printouts, will attempt to use this tree and the type information (see below) to find the correct string representation for key values \- if the tree isn\*(Aqt available, key values will be printed as described for
\fBconfd_pp_value()\fR\&.
.RE
.PP
\fBCONFD_LOAD_SCHEMA_TYPES\fR
.RS 4
This flag requests that information about the types defined in the namespace should be loaded\&. The type information is required for use of the functions
\fBconfd_val2str()\fR,
\fBconfd_str2val()\fR,
\fBconfd_find_ns_type()\fR,
\fBconfd_get_leaf_list_type()\fR,
\fBconfd_register_ns_type()\fR, and
\fBconfd_register_node_type()\fR
for the namespace\&. Additionally the
\fBconfd_hkeypath_t\fR\-printing functions and the library trace printouts will also fall back to
\fBconfd_pp_value()\fR
as described above if the type information isn\*(Aqt available\&.
.sp
Type definitions may refer to types defined in other namespaces\&. If the
\fBCONFD_LOAD_SCHEMA_TYPES\fR
flag has been given for a namespace, and the types defined there have such type references to namespaces that are not included in the
\fInshash\fR
array, the referenced type information will also be loaded, if necessary recursively, until the types have a complete definition\&.
.RE
.PP
See also
\fBconfd_load_schemas_list()\fR
in
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_get_schema_file_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **buf);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_schema_file_path("
.br
.BI "int\ " "sock" ", char\ **" "buf" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_schema_file_path(int\ " "sock" ", char\ **" "buf" ");" \}
.PP
If shared memory schema support has been enabled via
/confdConfig/enableSharedMemorySchema in confd\&.conf, this function will return the pathname of the file used for the shared memory mapping, which can then be passed to
\fBconfd_mmap_schemas()\fR
(see
\m[blue]\fBconfd_lib_lib(3)\fR\m[])\&. If the call is successful,
\fIbuf\fR
is set to point to a dynamically allocated string, which must be freed by the application by means of calling
\fBfree(3)\fR\&.
.PP
If creation of the schema file is in progress when the function is called, the call will block until the creation has completed\&. If shared memory schema support has not been enabled, or if the creation of the schema file failed, the function returns CONFD_ERR with
\fIconfd_errno\fR
set to CONFD_ERR_NOEXISTS\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_close('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_close("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_close(int\ " "sock" ");" \}
.PP
Effectively a call to
\fBmaapi_end_user_session()\fR
and also closes the socket\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION
.PP
Even if the call returns an error, the socket will be closed\&.
.SH "SESSION MANAGEMENT"
.nr wf \w'int\ maapi_start_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *username,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **groups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numgroups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_user_session("
.br
.BI "int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", enum\ confd_proto\ " "prot" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_user_session(int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", enum\ confd_proto\ " "prot" ");" \}
.PP
Once we have created a MAAPI socket, we must also establish a user session on the socket\&. It is up to the user of the MAAPI library to authenticate users\&. The library user can ask
ConfD
to perform the actual authentication through a call to
\fBmaapi_authenticate()\fR
but authentication may very well occur through some other external means\&.
.PP
Thus, when we use this function to create a user session, we must provide all relevant information about the user\&. If we wish to execute read/write transactions over the MAAPI interface, we must first have an established user session\&.
.PP
A user session corresponds to a NETCONF manager who has just established an authenticated SSH connection, but not yet sent any NETCONF commands on the SSH connection\&.
.PP
The
\fBstruct confd_ip\fR
is defined in
confd_lib\&.h
and must be properly populated before the call\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_ip ip;
ip\&.af = AF_INET;
inet_aton("10\&.0\&.0\&.33", &ip\&.ip\&.v4);
.fi
.if n \{\
.RE
.\}
.PP
The
\fIcontext\fR
parameter can be any string\&. The string provided here is precisely the context string which will be used to authorize all data access through the AAA system\&. Each AAA rule has a context string which must match in order for a AAA rule to match\&. (See the AAA chapter in the User Guide\&.)
.PP
Using the string "system" for
\fIcontext\fR
has special significance:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The session is exempt from all
maxSessions
limits in confd\&.conf\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
There will be no authorization checks done by the AAA system\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The session is not logged in the audit log\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The session is not shown in \*(Aqshow users\*(Aq in CLI etc\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The session may be started already in
ConfD
start phase 0\&. (However read\-write transactions can not be started until phase 1, i\&.e\&. transactions started in phase 0 must use parameter
\fIreadwrite\fR
==
\fBCONFD_READ\fR)\&.
.RE
.PP
Thus this can be useful e\&.g\&. when we need to create the user session for an "internal" transaction done by an application, without relation to a session from a northbound agent\&. Of course the implications of the above need to be carefully considered in each case\&.
.PP
It is not possible to create new user sessions until ConfD has reached start phase 2 (See
\m[blue]\fBconfd(1)\fR\m[]), with the above exception of a session with the context set to "system"\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_ALREADY_EXISTS, CONFD_ERR_BADSTATE
.nr wf \w'int\ maapi_start_user_session2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *username,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **groups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numgroups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ src_port,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_user_session2("
.br
.BI "int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_user_session2(int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ");" \}
.PP
This function does the same as
\fBmaapi_start_user_session()\fR, but allows for the TCP/UDP source port to be passed to
ConfD
\&. Calling
\fBmaapi_start_user_session()\fR
is equivalent to calling
\fBmaapi_start_user_session2()\fR
with
\fIsrc_port\fR
0\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_ALREADY_EXISTS, CONFD_ERR_BADSTATE
.nr wf \w'int\ maapi_start_user_session3('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *username,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **groups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ numgroups,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ src_port,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *vendor,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *product,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *version,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *client_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_user_session3("
.br
.BI "int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_user_session3(int\ " "sock" ", const\ char\ *" "username" ", const\ char\ *" "context" ", const\ char\ **" "groups" ", int\ " "numgroups" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", enum\ confd_proto\ " "prot" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.PP
This function does the same as
\fBmaapi_start_user_session2()\fR, but allows additional information about the session to be passed to
ConfD
\&. Calling
\fBmaapi_start_user_session2()\fR
is equivalent to calling
\fBmaapi_start_user_session3()\fR
with
\fIvendor\fR,
\fIproduct\fR
and
\fIversion\fR
set to NULL, and
\fIclient_id\fR
set to __MAAPI_CLIENT_ID__\&. The __MAAPI_CLIENT_ID__ macro (defined in confd_maapi\&.h) will expand to a string representation of __FILE__:__LINE__\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_ALREADY_EXISTS, CONFD_ERR_BADSTATE
.nr wf \w'int\ maapi_end_user_session('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_end_user_session("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_end_user_session(int\ " "sock" ");" \}
.PP
Ends our own user session\&. If the MAAPI socket is closed, the user session is automatically ended\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION
.nr wf \w'int\ maapi_kill_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_kill_user_session("
.br
.BI "int\ " "sock" ", int\ " "usessid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_kill_user_session(int\ " "sock" ", int\ " "usessid" ");" \}
.PP
Kill the user session identified by
\fIusessid\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_get_user_sessions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ res[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_sessions("
.br
.BI "int\ " "sock" ", int\ " "res[]" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_sessions(int\ " "sock" ", int\ " "res[]" ", int\ " "n" ");" \}
.PP
Get the usessid for all current user sessions\&. The
\fIres\fR
array is populated with at most
\fIn\fR
usessids, and the total number of user sessions is returned (i\&.e\&. if the return value is larger than
\fIn\fR, the array was too short to hold all usessids)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_get_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_user_info\ *us);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_session("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_info\ *" "us" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_session(int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_info\ *" "us" ");" \}
.PP
Populate the
\fBconfd_user_info\fR
structure with the data for the user session identified by
\fIusessid\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_get_my_user_session_id('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_my_user_session_id("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_my_user_session_id(int\ " "sock" ");" \}
.PP
A user session is identified through an integer index, a usessid\&. This function returns the usessid associated with the MAAPI socket
\fIsock\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_set_user_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_user_session("
.br
.BI "int\ " "sock" ", int\ " "usessid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_user_session(int\ " "sock" ", int\ " "usessid" ");" \}
.PP
Associate the socket with an already existing user session\&. This can be used instead of
\fBmaapi_start_user_session()\fR
when we really do not want to start a new user session, e\&.g\&. if we want to call an action on behalf of a given user session\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_get_user_session_identification('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_user_identification\ *uident);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_session_identification("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_identification\ *" "uident" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_session_identification(int\ " "sock" ", int\ " "usessid" ", struct\ confd_user_identification\ *" "uident" ");" \}
.PP
If the flag
\fBCONFD_USESS_FLAG_HAS_IDENTIFICATION\fR
is set in the
\fIflags\fR
field of the
\fBconfd_user_info\fR
structure, additional identification information has been provided by the northbound client\&. This information can then be retrieved into a
\fBconfd_user_identification\fR
structure (see
confd_lib\&.h) by calling this function\&. The elements of
\fBconfd_user_identification\fR
are either NULL (if the corresponding information was not provided) or point to a string\&. The strings must be freed by the application by means of calling
\fBfree(3)\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_get_user_session_opaque('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **opaque);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_user_session_opaque("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", char\ **" "opaque" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_user_session_opaque(int\ " "sock" ", int\ " "usessid" ", char\ **" "opaque" ");" \}
.PP
If the flag
\fBCONFD_USESS_FLAG_HAS_OPAQUE\fR
is set in the
\fIflags\fR
field of the
\fBconfd_user_info\fR
structure, "opaque" information has been provided by the northbound client (see the
\fB\-O\fR
option in
\m[blue]\fBconfd_cli(1)\fR\m[])\&. The information can then be retrieved by calling this function\&. If the call is successful,
\fIopaque\fR
is set to point to a dynamically allocated string, which must be freed by the application by means of calling
\fBfree(3)\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_get_authorization_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_authorization_info\ **ainfo);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_authorization_info("
.br
.BI "int\ " "sock" ", int\ " "usessid" ", struct\ confd_authorization_info\ **" "ainfo" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_authorization_info(int\ " "sock" ", int\ " "usessid" ", struct\ confd_authorization_info\ **" "ainfo" ");" \}
.PP
This function retrieves authorization info for a user session, i\&.e\&. the groups that the user has been assigned to\&. The
\fBstruct confd_authorization_info\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_authorization_info {
    int ngroups;
    char **groups;
};
.fi
.if n \{\
.RE
.\}
.PP
If the call is successful,
\fIainfo\fR
is set to point to a dynamically allocated structure, which must be freed by the application by means of calling
\fBconfd_free_authorization_info()\fR
(see
\m[blue]\fBconfd_lib_lib(3)\fR\m[]) \&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_set_next_user_session_id('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usessid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_next_user_session_id("
.br
.BI "int\ " "sock" ", int\ " "usessid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_next_user_session_id(int\ " "sock" ", int\ " "usessid" ");" \}
.PP
Set the user session id that will be assigned to the next user session started\&. The given value is silently forced to be in the range 100 \&.\&. 2^31\-1\&. This function can be used to ensure that session ids for user sessions started by northbound agents or via MAAPI are unique across a
ConfD
restart\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.SH "LOCKS"
.nr wf \w'int\ maapi_lock('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_lock("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_lock(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.nr wf \w'int\ maapi_unlock('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_unlock("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_unlock(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.PP
These functions can be used to manipulate locks on the 3 different database types\&. If
\fBmaapi_lock()\fR
is called and the database is already locked, CONFD_ERR is returned, and
\fIconfd_errno\fR
will be set to CONFD_ERR_LOCKED\&. If
\fIconfd_errno\fR
is CONFD_ERR_EXTERNAL it means that a callback has been invoked in an external database to lock/unlock which in its turn returned an error\&. (See
\m[blue]\fBconfd_lib_dp(3)\fR\m[]
for external database callback API)
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_LOCKED, CONFD_ERR_EXTERNAL, CONFD_ERR_NOSESSION
.nr wf \w'int\ maapi_is_lock_set('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_is_lock_set("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_is_lock_set(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.PP
Returns a positive integer being the usid of the current lock owner if the lock is set, and 0 if the lock is not set\&.
.nr wf \w'int\ maapi_lock_partial('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *xpaths[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nxpaths,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *lockid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_lock_partial("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ", char\ *" "xpaths[]" ", int\ " "nxpaths" ", int\ *" "lockid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_lock_partial(int\ " "sock" ", enum\ confd_dbname\ " "name" ", char\ *" "xpaths[]" ", int\ " "nxpaths" ", int\ *" "lockid" ");" \}
.nr wf \w'int\ maapi_unlock_partial('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ lockid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_unlock_partial("
.br
.BI "int\ " "sock" ", int\ " "lockid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_unlock_partial(int\ " "sock" ", int\ " "lockid" ");" \}
.PP
We can also manipulate partial locks on the databases, i\&.e\&. locks on a specified set of leafs and/or subtrees\&. The specification of what to lock is given via the
\fIxpaths\fR
array, which is populated with
\fInxpaths\fR
pointers to XPath expressions\&. If the lock succeeds,
\fBmaapi_lock_partial()\fR
returns CONFD_OK, and a lock identifier to use with
\fBmaapi_unlock_partial()\fR
is stored in
\fI*lockid\fR\&.
.PP
If CONFD_ERR is returned, some values of
\fIconfd_errno\fR
are of particular interest:
.PP
CONFD_ERR_LOCKED
.RS 4
Some of the requested nodes are already locked\&.
.RE
.PP
CONFD_ERR_EXTERNAL
.RS 4
A callback has been invoked in an external database to lock_partial/unlock_partial which in its turn returned an error (see
\m[blue]\fBconfd_lib_dp(3)\fR\m[]
for external database callback API)\&.
.RE
.PP
CONFD_ERR_NOEXISTS
.RS 4
The list of XPath expressions evaluated to an empty set of nodes \- i\&.e\&. there is nothing to lock\&.
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_LOCKED, CONFD_ERR_EXTERNAL, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.SH "CANDIDATE MANIPULATION"
.PP
All the candidate manipulation functions require that the candidate data store is enabled in
confd\&.conf
\- otherwise they will set
\fIconfd_errno\fR
to CONFD_ERR_NOEXISTS\&. If the candidate data store is enabled,
\fIconfd_errno\fR
may be set to CONFD_ERR_NOEXISTS for other reasons, as described below\&.
.PP
All these functions may also set
\fIconfd_errno\fR
to CONFD_ERR_EXTERNAL\&. This value can only be set when the candidate is owned by the external database\&. When
ConfD
owns the candidate, which is the most common configuration scenario, the candidate manipulation function will never set
\fIconfd_errno\fR
to CONFD_ERR_EXTERNAL\&.
.nr wf \w'int\ maapi_candidate_validate('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_validate("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_validate(int\ " "sock" ");" \}
.PP
This function validates the candidate\&. The function should only be used when the candidate is not owned by
ConfD
, i\&.e\&. when the candidate is owned by an external database\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_commit('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_commit("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_commit(int\ " "sock" ");" \}
.PP
This function copies the candidate to running\&. It is also used to confirm a previous call to
\fBmaapi_candidate_confirmed_commit()\fR, i\&.e\&. to prevent the automatic rollback if a confirmed commit is not confirmed\&.
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_INUSE it means that some other user session is doing a confirmed commit or has a lock on the database\&. CONFD_ERR_NOEXISTS means that there is an ongoing persistent confirmed commit (see below) \- i\&.e\&. there is no confirmed commit that this function call can apply to\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_INUSE, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_confirmed_commit('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_confirmed_commit("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_confirmed_commit(int\ " "sock" ", int\ " "timeoutsecs" ");" \}
.PP
This function also copies the candidate into running\&. However if a call to
\fBmaapi_candidate_commit()\fR
is not done within
\fItimeoutsecs\fR
an automatic rollback will occur\&. It can also be used to "extend" a confirmed commit that is already in progress, i\&.e\&. set a new timeout or add changes\&.
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_NOEXISTS it means that there is an ongoing persistent confirmed commit (see below)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_INUSE, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_abort_commit('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_abort_commit("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_abort_commit(int\ " "sock" ");" \}
.PP
This function cancels an ongoing confirmed commit\&.
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_NOEXISTS it means that some other user session initiated the confirmed commit, or that there is an ongoing persistent confirmed commit (see below)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_confirmed_commit_persistent('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_confirmed_commit_persistent("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_confirmed_commit_persistent(int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ");" \}
.PP
This function can be used to start or extend a persistent confirmed commit\&. The
\fIpersist\fR
parameter sets the cookie for the persistent confirmed commit, while the
\fIpersist_id\fR
gives the cookie for an already ongoing persistent confirmed commit\&. This gives the following possibilities:
.PP
\fIpersist\fR = "cookie", \fIpersist_id\fR = NULL
.RS 4
Start a persistent confirmed commit with the cookie "cookie", or extend an already ongoing non\-persistent confirmed commit and turn it into a persistent confirmed commit\&.
.RE
.PP
\fIpersist\fR = "newcookie", \fIpersist_id\fR = "oldcookie"
.RS 4
Extend an ongoing persistent confirmed commit that uses the cookie "oldcookie" and change the cookie to "newcookie"\&.
.RE
.PP
\fIpersist\fR = NULL, \fIpersist_id\fR = "cookie"
.RS 4
Extend an ongoing persistent confirmed commit that uses the cookie "oldcookie" and turn it into a non\-persistent confirmed commit\&.
.RE
.PP
\fIpersist\fR = NULL, \fIpersist_id\fR = NULL
.RS 4
Does the same as
\fBmaapi_candidate_confirmed_commit()\fR\&.
.RE
.PP
Typical usage is to start a persistent confirmed commit with
\fIpersist\fR
= "cookie",
\fIpersist_id\fR
= NULL, and to extend it with
\fIpersist\fR
= "cookie",
\fIpersist_id\fR
= "cookie"\&.
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_NOEXISTS it means that there is an ongoing persistent confirmed commit, but
\fIpersist_id\fR
didn\*(Aqt give the right cookie for it\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_INUSE, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_confirmed_commit_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *label,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *comment);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_confirmed_commit_info("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_confirmed_commit_info(int\ " "sock" ", int\ " "timeoutsecs" ", const\ char\ *" "persist" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.PP
This function does the same as
\fBmaapi_candidate_confirmed_commit_persistent()\fR, but allows for setting the "Label" and/or "Comment" that is stored in the rollback file when the candidate is committed to running\&. To set only the "Label", give
\fIcomment\fR
as NULL, and to set only the "Comment", give
\fIlabel\fR
as NULL\&. If both
\fIlabel\fR
and
\fIcomment\fR
are NULL, the function does exactly the same as
\fBmaapi_candidate_confirmed_commit_persistent()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
To ensure that the "Label" and/or "Comment" are stored in the rollback file in all cases when doing a confirmed commit, they must be given both with the confirmed commit (using this function) and with the confirming commit (using
\fBmaapi_candidate_commit_info()\fR)\&.
.sp .5v
.RE
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_NOEXISTS it means that there is an ongoing persistent confirmed commit, but
\fIpersist_id\fR
didn\*(Aqt give the right cookie for it\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_INUSE, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_commit_persistent('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_commit_persistent("
.br
.BI "int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_commit_persistent(int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.PP
Confirm an ongoing persistent confirmed commit with the cookie given by
\fIpersist_id\fR\&. If
\fIpersist_id\fR
is NULL, it does the same as
\fBmaapi_candidate_commit()\fR\&.
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_NOEXISTS it means that there is an ongoing persistent confirmed commit, but
\fIpersist_id\fR
didn\*(Aqt give the right cookie for it\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_INUSE, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_commit_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *label,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *comment);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_commit_info("
.br
.BI "int\ " "sock" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_commit_info(int\ " "sock" ", const\ char\ *" "persist_id" ", const\ char\ *" "label" ", const\ char\ *" "comment" ");" \}
.PP
This function does the same as
\fBmaapi_candidate_commit_persistent()\fR, but allows for setting the "Label" and/or "Comment" that is stored in the rollback file when the candidate is committed to running\&. To set only the "Label", give
\fIcomment\fR
as NULL, and to set only the "Comment", give
\fIlabel\fR
as NULL\&. If both
\fIlabel\fR
and
\fIcomment\fR
are NULL, the function does exactly the same as
\fBmaapi_candidate_commit_persistent()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
To ensure that the "Label" and/or "Comment" are stored in the rollback file in all cases when doing a confirmed commit, they must be given both with the confirmed commit (using
\fBmaapi_candidate_confirmed_commit_info()\fR) and with the confirming commit (using this function)\&.
.sp .5v
.RE
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_NOEXISTS it means that there is an ongoing persistent confirmed commit, but
\fIpersist_id\fR
didn\*(Aqt give the right cookie for it\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_INUSE, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_abort_commit_persistent('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *persist_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_abort_commit_persistent("
.br
.BI "int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_abort_commit_persistent(int\ " "sock" ", const\ char\ *" "persist_id" ");" \}
.PP
Cancel an ongoing persistent confirmed commit with the cookie given by
\fIpersist_id\fR\&. (If
\fIpersist_id\fR
is NULL, it does the same as
\fBmaapi_candidate_abort_commit()\fR\&.)
.PP
If
\fIconfd_errno\fR
is CONFD_ERR_NOEXISTS it means that there is an ongoing persistent confirmed commit, but
\fIpersist_id\fR
didn\*(Aqt give the right cookie for it\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_INUSE, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_candidate_reset('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_candidate_reset("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_candidate_reset(int\ " "sock" ");" \}
.PP
This function copies running into candidate\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_INUSE, CONFD_ERR_EXTERNAL, CONFD_ERR_NOSESSION
.nr wf \w'int\ maapi_confirmed_commit_in_progress('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_confirmed_commit_in_progress("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_confirmed_commit_in_progress(int\ " "sock" ");" \}
.PP
Checks whether a confirmed commit is ongoing\&. Returns 1 if some user session currently has an ongoing confirmed commit operation and 0 if not\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_copy_running_to_startup('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy_running_to_startup("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy_running_to_startup(int\ " "sock" ");" \}
.PP
This function copies running to startup\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_INUSE, CONFD_ERR_EXTERNAL, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_is_running_modified('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_is_running_modified("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_is_running_modified(int\ " "sock" ");" \}
.PP
Returns 1 if running has been modified since the last copy to startup, 0 if it has not been modified\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_is_candidate_modified('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_is_candidate_modified("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_is_candidate_modified(int\ " "sock" ");" \}
.PP
Returns 1 if candidate has been modified, i\&.e if there are any outstanding non committed changes to the candidate, 0 if no changes are done
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.SH "TRANSACTION CONTROL"
.nr wf \w'int\ maapi_start_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ", enum\ confd_trans_mode\ " "readwrite" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans(int\ " "sock" ", enum\ confd_dbname\ " "name" ", enum\ confd_trans_mode\ " "readwrite" ");" \}
.PP
The main purpose of MAAPI is to provide read and write access into the
ConfD
transaction manager\&. Regardless of whether data is kept in CDB or in some (or several) external data bases, the same API is used to access data\&. ConfD acts as a mediator and multiplexes the different commands to the code which is responsible for each individual data node\&.
.PP
This function creates a new transaction towards the data store specified by
\fIname\fR, which can be one of
\fBCONFD_CANDIDATE\fR,
\fBCONFD_OPERATIONAL\fR,
\fBCONFD_RUNNING\fR, or
\fBCONFD_STARTUP\fR
(however updating the startup data store is better done via
\fBmaapi_copy_running_to_startup()\fR)\&. The
\fIreadwrite\fR
parameter can be either
\fBCONFD_READ\fR, to start a readonly transaction, or
\fBCONFD_READ_WRITE\fR, to start a read\-write transaction\&.
.PP
A readonly transaction will incur less resource usage, thus if no writes will be done (e\&.g\&. the purpose of the transaction is only to read operational data), it is best to use
\fBCONFD_READ\fR\&. There are also some cases where starting a read\-write transaction is not allowed, e\&.g\&. if we start a transaction towards the running data store and
/confdConfig/datastores/running/access
is set to "writable\-through\-candidate" in
confd\&.conf, or if ConfD is running in HA slave mode\&.
.PP
If start of the transaction is successful, the function returns a new transaction handle, a non\-negative integer
\fIthandle\fR
which must be used as a parameter in all API functions which manipulate the transaction\&.
.PP
We will drive this transaction forward through the different states a ConfD transaction goes through\&. See the ascii arts in
\m[blue]\fBconfd_lib_dp(3)\fR\m[]
for a picture of these states\&. If an external database is used, and it has registered callback functions for the different transaction states, those callbacks will be called when we in MAAPI invoke the different MAAPI transaction manipulation functions\&. For example when we call
\fBmaapi_start_trans()\fR
the
\fBinit()\fR
callback will be invoked in all external databases\&. (However ConfD may delay the actual invocation of
\fBinit()\fR
as an optimization, see
\m[blue]\fBconfd_lib_dp(3)\fR\m[]\&.) If data is kept in CDB, ConfD will handle everything internally\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_TOOMANYTRANS, CONFD_ERR_BADSTATE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ maapi_start_trans2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans2("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans2(int\ " "sock" ", enum\ confd_dbname\ " "name" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ");" \}
.PP
If we want to start new transactions inside actions, we can use this function to execute the new transaction within the existing user session\&. It is equivalent to calling
\fBmaapi_set_user_session()\fR
and then
\fBmaapi_start_trans()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_TOOMANYTRANS, CONFD_ERR_BADSTATE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ maapi_start_trans_flags('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans_flags("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans_flags(int\ " "sock" ", enum\ confd_dbname\ " "name" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ");" \}
.PP
This function makes it possible to set the flags that can otherwise be used with
\fBmaapi_set_flags()\fR
already when starting a transaction, as well as setting the
\fBMAAPI_FLAG_HIDE_INACTIVE\fR
and
\fBMAAPI_FLAG_DELAYED_WHEN\fR
flags that can only be used with
\fBmaapi_start_trans_flags()\fR\&. See the description of
\fBmaapi_set_flags()\fR
for the available flags\&. It also incorporates the functionality of
\fBmaapi_start_trans()\fR
and
\fBmaapi_start_trans2()\fR
with respect to user sessions: If
\fIusid\fR
is 0, the transaction will be started within the user session associated with the MAAPI socket (like
\fBmaapi_start_trans()\fR), otherwise it will be started within the user session given by
\fIusid\fR
(like
\fBmaapi_start_trans2()\fR)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_TOOMANYTRANS, CONFD_ERR_BADSTATE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ maapi_start_trans_flags2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ dbname,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *vendor,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *product,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *version,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *client_id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans_flags2("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans_flags2(int\ " "sock" ", enum\ confd_dbname\ " "dbname" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "flags" ", const\ char\ *" "vendor" ", const\ char\ *" "product" ", const\ char\ *" "version" ", const\ char\ *" "client_id" ");" \}
.PP
This function does the same as
\fBmaapi_start_trans_flags()\fR
but allows additional information about the transaction to be passed to
ConfD\&. Calling
\fBmaapi_start_trans_flags()\fR
is equivalent to calling
\fBmaapi_start_trans_flags2()\fR
with
\fIvendor\fR,
\fIproduct\fR
and
\fIversion\fR
set to NULL, and
\fIclient_id\fR
set to __MAAPI_CLIENT_ID__\&. The __MAAPI_CLIENT_ID__ macro (defined in confd_maapi\&.h) will expand to a string representation of __FILE__:__LINE__\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_TOOMANYTRANS, CONFD_ERR_BADSTATE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ maapi_start_trans_in_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_trans_mode\ readwrite,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_trans_in_trans("
.br
.BI "int\ " "sock" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_trans_in_trans(int\ " "sock" ", enum\ confd_trans_mode\ " "readwrite" ", int\ " "usid" ", int\ " "thandle" ");" \}
.PP
This function makes it possible to start a transaction with another transaction as backend, instead of an actual data store\&. This can be useful if we want to make a set of related changes, and then either apply or discard them all based on some criterion, while other changes remain unaffected\&. The
\fIthandle\fR
identifies the backend transaction to use\&. If
\fIusid\fR
is 0, the transaction will be started within the user session associated with the MAAPI socket, otherwise it will be started within the user session given by
\fIusid\fR\&. If we call
\fBmaapi_apply_trans()\fR
for this "transaction in a transaction", the changes (if any) will be applied to the backend transaction\&. To discard the changes, call
\fBmaapi_finish_trans()\fR
without calling
\fBmaapi_apply_trans()\fR
first\&.
.PP
The changes in this transaction can be validated by calling
\fBmaapi_validate_trans()\fR
with a non\-zero value for
\fIforcevalidation\fR, but calling
\fBmaapi_apply_trans()\fR
will not do any validation \- in either case, the resulting configuration will be validated when the backend transaction is committed to the running data store\&. Note though that unlike the case with a transaction directly towards a data store, no transaction lock is taken on the underlying data store when doing validation of this type of transaction \- thus it is possible for the contents of the data store to change (due to commit of another transaction) during the validation\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_TOOMANYTRANS, CONFD_ERR_BADSTATE
.nr wf \w'int\ maapi_finish_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_finish_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_finish_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.PP
This will finish the transaction\&. If the transaction is implemented by an external database, this will invoke the
\fBfinish()\fR
callback\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.PP
The error CONFD_ERR_NOEXISTS is set for all API functions which use a
\fIthandle\fR, the return value from
\fBmaapi_start_trans()\fR, whenever no transaction is started\&.
.nr wf \w'int\ maapi_validate_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ unlock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ forcevalidation);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_validate_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "unlock" ", int\ " "forcevalidation" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_validate_trans(int\ " "sock" ", int\ " "thandle" ", int\ " "unlock" ", int\ " "forcevalidation" ");" \}
.PP
This function validates all data written in the transaction\&. This includes all data model constraints and all defined semantic validation in C, i\&.e\&. user programs that have registered functions under validation points\&. (See the
\m[blue]\fBSemantic Validation chapter in the User Guide\fR\m[]\&.)
.PP
If this function returns CONFD_ERR, the transaction is open for further editing\&. There are two special
\fIconfd_errno\fR
values which are of particular interest here\&.
.PP
CONFD_ERR_EXTERNAL
.RS 4
this means that an external validation program in C returns CONFD_ERR i\&.e\&. that the semantic validation failed\&. The reason for the failure can be found in
\fBconfd_lasterr()\fR
.RE
.PP
CONFD_ERR_VALIDATION_WARNING
.RS 4
This means that an external semantic validation program in C returned CONFD_VALIDATION_WARN\&. The string
\fBconfd_lasterr()\fR
is organized as a series of NUL terminated strings as in
keypath1, reason1, keypath2, reason2 \&.\&.\&.
where the sequence is terminated with an additional NUL
.RE
.PP
If
\fIunlock\fR
is 1, the transaction is open for further editing even if validation succeeds\&. If
\fIunlock\fR
is 0 and the function returns CONFD_OK, the next function to be called MUST be
\fBmaapi_prepare_trans()\fR
or
\fBmaapi_finish_trans()\fR\&.
.PP
\fIunlock\fR
= 1 can be used to implement a \*(Aqvalidate\*(Aq command which can be given in the middle of an editing session\&. The first thing that happens is that a lock is set\&. If
\fIunlock\fR
== 1, the lock is released on success\&. The lock is always released on failure\&.
.PP
The
\fIforcevalidation\fR
parameter should normally be 0\&. It has no effect for a transaction towards the running or startup data stores, validation is always performed\&. For a transaction towards the candidate data store, validation will not be done unless
\fIforcevalidation\fR
is non\-zero\&. Avoiding this validation is preferable if we are going to commit the candidate to running (e\&.g\&. with
\fBmaapi_candidate_commit()\fR), since otherwise the validation will be done twice\&. However if we are implementing a \*(Aqvalidate\*(Aq command, we should give a non\-zero value for
\fIforcevalidation\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS, CONFD_ERR_NOTSET, CONFD_ERR_NON_UNIQUE, CONFD_ERR_BAD_KEYREF, CONFD_ERR_TOO_FEW_ELEMS, CONFD_ERR_TOO_MANY_ELEMS, CONFD_ERR_UNSET_CHOICE, CONFD_ERR_MUST_FAILED, CONFD_ERR_MISSING_INSTANCE, CONFD_ERR_INVALID_INSTANCE, CONFD_ERR_INUSE, CONFD_ERR_BADTYPE, CONFD_ERR_EXTERNAL, CONFD_ERR_BADSTATE
.nr wf \w'int\ maapi_prepare_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_prepare_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_prepare_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.PP
This function must be called as first part of two\-phase commit\&. After this function has been called
\fBmaapi_commit_trans()\fR
or
\fBmaapi_abort_trans()\fR
must be called\&.
.PP
It will invoke the prepare callback in all participants in the transaction\&. If all participants reply with CONFD_OK, the second phase of the two\-phase commit procedure is commenced\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS, CONFD_ERR_EXTERNAL, CONFD_ERR_NOTSET, CONFD_ERR_BADSTATE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_commit_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_commit_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_commit_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.nr wf \w'int\ maapi_abort_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_abort_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_abort_trans(int\ " "sock" ", int\ " "thandle" ");" \}
.PP
Finally at the last stage, either commit or abort must be called\&. A call to one of these functions must also eventually be followed by a call to
\fBmaapi_finish_trans()\fR
which will terminate the transaction\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS, CONFD_ERR_EXTERNAL, CONFD_ERR_BADSTATE
.nr wf \w'int\ maapi_apply_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ keepopen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_apply_trans("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_apply_trans(int\ " "sock" ", int\ " "thandle" ", int\ " "keepopen" ");" \}
.PP
Invoking the above transaction functions in exactly the right order can be a bit complicated\&. The right order to invoke the functions is
\fBmaapi_validate_trans()\fR,
\fBmaapi_prepare_trans()\fR,
\fBmaapi_commit_trans()\fR
(or
\fBmaapi_abort_trans()\fR)\&. Usually we do not require this fine grained control over the two\-phase commit protocol\&. It is easier to use
\fBmaapi_apply_trans()\fR
which validates, prepares and eventually commits or aborts\&.
.PP
A call to
\fBmaapi_apply_trans()\fR
must also eventually be followed by a call to
\fBmaapi_finish_trans()\fR
which will terminate the transaction\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
For a readonly transaction, i\&.e\&. one started with
\fIreadwrite\fR
==
\fBCONFD_READ\fR, or for a read\-write transaction where we haven\*(Aqt actually done any writes, we do not need to call any of the validate/prepare/commit/abort or apply functions, since there is nothing for them to do\&. Calling
\fBmaapi_finish_trans()\fR
to terminate the transaction is sufficient\&.
.sp .5v
.RE
.PP
The parameter
\fIkeepopen\fR
can optionally be set to
\fB1\fR, then the changes to the transaction are not discarded if validation fails\&. This feature is typically used by management applications that wish to present the validation errors to an operator and allow the operator to fix the validation errors and then later retry the apply sequence\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS, CONFD_ERR_NOTSET, CONFD_ERR_NON_UNIQUE, CONFD_ERR_BAD_KEYREF, CONFD_ERR_TOO_FEW_ELEMS, CONFD_ERR_TOO_MANY_ELEMS, CONFD_ERR_UNSET_CHOICE, CONFD_ERR_MUST_FAILED, CONFD_ERR_MISSING_INSTANCE, CONFD_ERR_INVALID_INSTANCE, CONFD_ERR_INUSE, CONFD_ERR_BADTYPE, CONFD_ERR_EXTERNAL, CONFD_ERR_BADSTATE
.SH "READ/WRITE FUNCTIONS"
.nr wf \w'int\ maapi_set_namespace('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_namespace("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "hashed_ns" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_namespace(int\ " "sock" ", int\ " "thandle" ", int\ " "hashed_ns" ");" \}
.PP
If we want to read or write data where the toplevel element name is not unique, we must indicate which namespace we are going to use\&. It is possible to change the namespace several times during a transaction\&.
.PP
The
\fIhashed_ns\fR
integer is the integer which is defined for the namespace in the \&.h file which is generated by the \*(Aqconfdc\*(Aq compiler\&. It is also possible to indicate which namespace to use through the namespace prefix when we read and write data\&. Thus the path
/foo:bar/baz
will get us
/bar/baz
in the namespace with prefix "foo" regardless of what the "set" namespace is\&. And if there is only one toplevel element called "bar" across all namespaces, we can use
/bar/baz
without the prefix and without calling
\fBmaapi_set_namespace()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cd(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function mimics the behavior of the UNIX "cd" command\&. It changes our working position in the data tree\&. If we are worried about performance, it is more efficient to invoke
\fBmaapi_cd()\fR
to some position in the tree and there perform a series of operations using relative paths than it is to perform the equivalent series of operations using absolute paths\&. Note that this function can not be used as an existence test\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_pushd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_pushd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_pushd(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Behaves like
\fBmaapi_cd()\fR
with the exception that we can subsequently call
\fBmaapi_popd()\fR
and returns to the previous position in the data tree\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOSTACK, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_popd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_popd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_popd(int\ " "sock" ", int\ " "thandle" ");" \}
.PP
Pops the top position of the directory stack and changes directory\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOSTACK, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_getcwd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'size_t\ strsz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *curdir);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_getcwd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_getcwd(int\ " "sock" ", int\ " "thandle" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.PP
Returns the current position as previously set by
\fBmaapi_cd()\fR,
\fBmaapi_pushd()\fR, or
\fBmaapi_popd()\fR
as a string\&. Note that what is returned is a pretty\-printed version of the internal representation of the current position, it will be the shortest unique way to print the path but it might not exactly match the string given to
\fBmaapi_cd()\fR\&. The buffer in *curdir will be NULL terminated, and no more characters than strsz\-1 will be written to it\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_getcwd_kpath('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **kp);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_getcwd_kpath("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_hkeypath_t\ **" "kp" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_getcwd_kpath(int\ " "sock" ", int\ " "thandle" ", confd_hkeypath_t\ **" "kp" ");" \}
.PP
Returns the current position like
\fBmaapi_getcwd()\fR, but as a pointer to a hashed keypath instead of as a string\&. The hkeypath is dynamically allocated, and may further contain dynamically allocated elements\&. The caller must free the allocated memory, easiest done by calling
\fBconfd_free_hkeypath()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_exists('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_exists("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_exists(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Boolean function which return 1 if the path refers to an existing node in the data tree, 0 if it does not\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_num_instances('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_num_instances("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_num_instances(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Returns the number of entries for a list in the data tree\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_get_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function reads a value from the path in
\fIfmt\fR
and writes the result into the result parameter
\fBconfd_value_t\fR\&. The path must lead to a leaf node in the data tree\&. Note that for the C_BUF, C_BINARY, C_LIST, C_OBJECTREF, C_OID, C_QNAME, C_HEXSTR, and C_BITBIG
\fBconfd_value_t\fR
types, the buffer(s) pointed to are allocated using malloc(3) \- it is up to the user of this interface to free them using
\fBconfd_free_value()\fR\&.
.PP
The maapi interface also contains a long list of access functions that accompany the
\fBmaapi_get_elem()\fR
function which is a general access function that returns a
\fBconfd_value_t\fR\&. The accompanying functions all have the format
\fBmaapi_get_<type>_elem()\fR
where <type> is one of the actual C types a
\fBconfd_value_t\fR
can have\&. For example the function:
.sp
.if n \{\
.RS 4
.\}
.nf
maapi_get_int64_elem(int sock, int thandle, int64_t *rval,
                                const char *fmt, \&.\&.\&.);
.fi
.if n \{\
.RE
.\}
.PP
is used to read a signed 64 bit integer\&. It fills in the provided
\fBint64_t\fR
parameter\&. This corresponds to the YANG datatype int64, see
\m[blue]\fBconfd_types(3)\fR\m[]\&. Similar access functions are provided for all the different builtin types\&.
.PP
One access function that needs additional explaining is the
\fBmaapi_get_str_elem()\fR\&. This function copies at most
n\-1
characters into a user provided buffer, and terminates the string with a NUL character\&. If the buffer is not sufficiently large CONFD_ERR is returned, and
\fIconfd_errno\fR
is set to CONFD_ERR_PROTOUSAGE\&. Note it is always possible to use maapi_get_elem() to get hold of the
\fBconfd_value_t\fR, which in the case of a string buffer contains the length\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_PROTOUSAGE, CONFD_ERR_BADTYPE
.PP
.nr wf \w'int\ maapi_get_int8_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int8_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_int8_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_int8_elem(int\ " "sock" ", int\ " "thandle" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_int16_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int16_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_int16_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_int16_elem(int\ " "sock" ", int\ " "thandle" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_int32_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int32_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_int32_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_int32_elem(int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_int64_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int64_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_int64_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_int64_elem(int\ " "sock" ", int\ " "thandle" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_u_int8_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'u_int8_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_u_int8_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_u_int8_elem(int\ " "sock" ", int\ " "thandle" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_u_int16_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'u_int16_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_u_int16_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_u_int16_elem(int\ " "sock" ", int\ " "thandle" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_u_int32_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'u_int32_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_u_int32_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_u_int32_elem(int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_u_int64_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'u_int64_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_u_int64_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_u_int64_elem(int\ " "sock" ", int\ " "thandle" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_ipv4_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ in_addr\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_ipv4_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_ipv4_elem(int\ " "sock" ", int\ " "thandle" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_ipv6_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ in6_addr\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_ipv6_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_ipv6_elem(int\ " "sock" ", int\ " "thandle" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_double_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'double\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_double_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_double_elem(int\ " "sock" ", int\ " "thandle" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_bool_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_bool_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_bool_elem(int\ " "sock" ", int\ " "thandle" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_datetime_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_datetime\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_datetime_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_datetime_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_date_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_date\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_date_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_date_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_gyearmonth_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_gYearMonth\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_gyearmonth_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_gYearMonth\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_gyearmonth_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_gYearMonth\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_gyear_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_gYear\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_gyear_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_gYear\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_gyear_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_gYear\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_time_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_time\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_time_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_time_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_gday_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_gDay\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_gday_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_gDay\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_gday_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_gDay\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_gmonthday_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_gMonthDay\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_gmonthday_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_gMonthDay\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_gmonthday_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_gMonthDay\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_month_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_gMonth\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_month_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_gMonth\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_month_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_gMonth\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_duration_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_duration\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_duration_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_duration_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_enum_value_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int32_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_enum_value_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_enum_value_elem(int\ " "sock" ", int\ " "thandle" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_bit32_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ th,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int32_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_bit32_elem(" .br .BI "int\ " "sock" ", int\ " "th" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_bit32_elem(int\ " "sock" ", int\ " "th" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_bit64_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ th,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int64_t\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_bit64_elem(" .br .BI "int\ " "sock" ", int\ " "th" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_bit64_elem(int\ " "sock" ", int\ " "th" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_oid_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ th,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_snmp_oid\ **rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_oid_elem(" .br .BI "int\ " "sock" ", int\ " "th" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_oid_elem(int\ " "sock" ", int\ " "th" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_buf_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'unsigned\ char\ **rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ *bufsiz,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_buf_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_buf_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_str_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ th,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'char\ *buf,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ n,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_str_elem(" .br .BI "int\ " "sock" ", int\ " "th" ", char\ *" "buf" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_str_elem(int\ " "sock" ", int\ " "th" ", char\ *" "buf" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_binary_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'unsigned\ char\ **rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ *bufsiz,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_binary_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_binary_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_qname_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'unsigned\ char\ **prefix,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ *prefixsz,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'unsigned\ char\ **name,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ *namesz,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_qname_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_qname_elem(int\ " "sock" ", int\ " "thandle" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_list_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ th,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'confd_value_t\ **values,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ *n,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_list_elem(" .br .BI "int\ " "sock" ", int\ " "th" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_list_elem(int\ " "sock" ", int\ " "th" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_ipv4prefix_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_ipv4_prefix\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_ipv4prefix_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_ipv4prefix_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}.nr wf \w'int\ maapi_get_ipv6prefix_elem(' .nr wm 0 .nr wp \w'int\ sock,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'int\ thandle,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'struct\ confd_ipv6_prefix\ *rval,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'const\ char\ *fmt,' .if \n(wp>\n(wm 'nr wm \n(wp .nr wp \w'\&.\&.\&.);' .if \n(wp>\n(wm 'nr wm \n(wp .ie \n(IN+\n(wf+\n(wm-\n(LL \{\ .HP \n(LLu-\n(INu-\n(wmu .BI "int maapi_get_ipv6prefix_elem(" .br .BI "int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \} .el \{\ .HP \n(wfu .BI "int maapi_get_ipv6prefix_elem(int\ " "sock" ", int\ " "thandle" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Similar to the CDB API, MAAPI also includes typesafe variants for all the builtin types\&. See
\m[blue]\fBconfd_types(3)\fR\m[]\&.
.nr wf \w'int\ maapi_vget_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_vget_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_vget_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.PP
This function does the same as
\fBmaapi_get_elem()\fR, but takes a single
\fBva_list\fR
argument instead of a variable number of arguments \- i\&.e\&. similar to
\fBvprintf()\fR\&. Corresponding
\fBva_list\fR
variants exist for all the functions that take a path as a variable number of arguments\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_PROTOUSAGE, CONFD_ERR_BADTYPE
.nr wf \w'int\ maapi_init_cursor('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ maapi_cursor\ *mc,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_init_cursor("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", struct\ maapi_cursor\ *" "mc" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_init_cursor(int\ " "sock" ", int\ " "thandle" ", struct\ maapi_cursor\ *" "mc" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Whenever we wish to iterate over the entries in a list in the data tree, we must first initialize a cursor\&. The cursor is subsequently used in a while loop\&.
.PP
For example if we have:
.sp
.if n \{\
.RS 4
.\}
.nf
container servers {
  list server {
    key name;
    max\-elements 64;
    leaf name {
      type string;
    }
    leaf ip {
      type inet:ip\-address;
    }
    leaf port {
      type inet:port\-number;
      mandatory true;
    }
  }
}
.fi
.if n \{\
.RE
.\}
.PP
We can have the following C code which iterates over all
server
entries\&.
.sp
.if n \{\
.RS 4
.\}
.nf
struct maapi_cursor mc;

maapi_init_cursor(sock, th, &mc, "/servers/server");
maapi_get_next(&mc);
while (mc\&.n != 0) {
   \&.\&.\&. do something
   maapi_get_next(&mc);
}
maapi_destroy_cursor(&mc);
.fi
.if n \{\
.RE
.\}
.PP
When a
tailf:secondary\-index
statement is used in the data model (see
\m[blue]\fBtailf_yang_extensions(5)\fR\m[]), we can set the
\fIsecondary_index\fR
element of the
\fBstruct maapi_cursor\fR
to indicate the name of a chosen secondary index \- this must be done after the call to
\fBmaapi_init_cursor()\fR
(which sets
\fIsecondary_index\fR
to NULL) and before any call to
\fBmaapi_get_next()\fR\&. In this case,
\fIsecondary_index\fR
must point to a NUL\-terminated string that is valid throughout the iteration\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_get_next('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_next("
.br
.BI "struct\ maapi_cursor\ *" "mc" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_next(struct\ maapi_cursor\ *" "mc" ");" \}
.PP
Iterates and gets the keys for the next entry in a list\&. The key(s) can be used to retrieve further data\&. The key(s) are stored as
\fBconfd_value_t\fR
structures in an array inside the
\fBstruct maapi_cursor\fR\&. The array of keys will be deallocated by the library\&.
.PP
For example to read the
port
leaf from an entry in the
server
list above, we would do:
.sp
.if n \{\
.RS 4
.\}
.nf
\&.\&.\&.\&.
maapi_init_cursor(sock, th, &mc, "/servers/server");
maapi_get_next(&mc);
while (mc\&.n != 0) {
   confd_value_t v;
   maapi_get_elem(sock, th, &v, "/servers/server{%x}/port", &mc\&.keys[0]);
   \&.\&.\&.\&.
   maapi_get_next(&mc);
}
.fi
.if n \{\
.RE
.\}
.PP
The \*(Aq%*x\*(Aq modifier (see the PATHS section in
\m[blue]\fBconfd_lib_cdb(3)\fR\m[]) is especially useful when working with a maapi cursor\&. The example above assumes that we know that the
/servers/server
list has exactly one key\&. But we can alternatively write
maapi_get_elem(sock, th, &v, "/servers/server{%*x}/port", mc\&.n, mc\&.keys);
\- which works regardless of the number of keys that the list has\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_find_next('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_find_next_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *inkeys,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n_inkeys);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_find_next("
.br
.BI "struct\ maapi_cursor\ *" "mc" ", enum\ confd_find_next_type\ " "type" ", confd_value_t\ *" "inkeys" ", int\ " "n_inkeys" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_find_next(struct\ maapi_cursor\ *" "mc" ", enum\ confd_find_next_type\ " "type" ", confd_value_t\ *" "inkeys" ", int\ " "n_inkeys" ");" \}
.PP
Update the cursor
\fImc\fR
with the key(s) for the list entry designated by the
\fItype\fR
and
\fIinkeys\fR
parameters\&. This function may be used to start a traversal from an arbitrary entry in a list\&. Keys for subsequent entries may be retrieved with the
\fBmaapi_get_next()\fR
function\&.
.PP
The
\fIinkeys\fR
array is populated with
\fIn_inkeys\fR
values that designate the starting point in the list\&. Normally the array is populated with key values for the list, but if the
\fIsecondary_index\fR
element of the cursor has been set, the array must instead be populated with values for the corresponding secondary index\-leafs\&. The
\fItype\fR
can have one of two values:
.PP
\fBCONFD_FIND_NEXT\fR
.RS 4
The keys for the first list entry
\fIafter\fR
the one indicated by the
\fIinkeys\fR
array are requested\&. The
\fIinkeys\fR
array does not have to correspond to an actual existing list entry\&. Furthermore the number of values provided in the array (\fIn_inkeys\fR) may be fewer than the number of keys (or number of index\-leafs for a secondary\-index) in the data model, possibly even zero\&. This indicates that only the first
\fIn_inkeys\fR
values are provided, and the remaining ones should be taken to have a value "earlier" than the value for any existing list entry\&.
.RE
.PP
\fBCONFD_FIND_SAME_OR_NEXT\fR
.RS 4
If the values in the
\fIinkeys\fR
array completely identify an actual existing list entry, the keys for this entry are requested\&. Otherwise the same logic as described for
\fBCONFD_FIND_NEXT\fR
is used\&.
.RE
.PP
The following example will traverse the
server
list starting with the first entry (if any) that has a key value that is after "smtp" in the list order:
.sp
.if n \{\
.RS 4
.\}
.nf
\&.\&.\&.\&.
confd_value_t inkeys[1];

maapi_init_cursor(sock, th, &mc, "/servers/server");
CONFD_SET_STR(&inkeys[0], "smtp");

maapi_find_next(&mc, CONFD_FIND_NEXT, inkeys, 1);
while (mc\&.n != 0) {
   confd_value_t v;
   maapi_get_elem(sock, th, &v, "/servers/server{%x}/port", &mc\&.keys[0]);
   \&.\&.\&.\&.
   maapi_get_next(&mc);
}
.fi
.if n \{\
.RE
.\}
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'void\ maapi_destroy_cursor('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "void maapi_destroy_cursor("
.br
.BI "struct\ maapi_cursor\ *" "mc" ");" \}
.el \{\
.HP \n(wfu
.BI "void maapi_destroy_cursor(struct\ maapi_cursor\ *" "mc" ");" \}
.PP
Deallocates memory which is associated with the cursor\&.
.nr wf \w'int\ maapi_set_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_set_elem2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *strval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_elem2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_elem2(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
We have two different functions to set values\&. One where the value is a string and one where the value to set is a
\fBconfd_value_t\fR\&. The string version is useful when we have implemented a management agent where the user enters values as strings\&. The version with
\fBconfd_value_t\fR
is useful when we are setting values which we have just read\&.
.PP
Another note which might effect users is that if the type we are writing is any of the encrypt or hash types, the
\fBmaapi_set_elem2()\fR
will perform the asymmetric conversion of values whereas the
\fBmaapi_set_elem()\fR
will not\&. See
\m[blue]\fBconfd_types(3)\fR\m[], the types
\fBtailf:md5\-digest\-string\fR,
\fBtailf:des3\-cbc\-encrypted\-string\fR, and
\fBtailf:aes\-cfb\-128\-encrypted\-string\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_vset_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_vset_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_vset_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.PP
This function does the same as
\fBmaapi_set_elem()\fR, but takes a single
\fBva_list\fR
argument instead of a variable number of arguments \- i\&.e\&. similar to
\fBvprintf()\fR\&. Corresponding
\fBva_list\fR
variants exist for all the functions that take a path as a variable number of arguments\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_create('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_create("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_create(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Create a new list entry, a
presence
container, or a leaf of type
empty
in the data tree\&. For example:
maapi_create(sock,th,"/servers/server{www}");
.PP
If we are creating a new server entry as above, we must also populate all other data nodes below, which do not have a default value in the data model\&. Thus we must also do e\&.g\&.:
.PP
maapi_set_elem2(sock, th, "80", "/servers/server{www}/port");
.PP
before we try to commit the data\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOTCREATABLE, CONFD_ERR_INUSE, CONFD_ERR_ALREADY_EXISTS
.nr wf \w'int\ maapi_delete('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_delete("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_delete(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Delete an existing list entry, a
presence
container, or an optional leaf and all its children (if any) from the data tree\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOTDELETABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_get_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_object("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_object(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function reads at most
\fIn\fR
values from the list entry or container specified by the path, and places them in the
\fIvalues\fR
array, which is provided by the caller\&. The array is populated according to the specification of the Value Array format in the
\m[blue]\fBXML STRUCTURES\fR\m[]
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
On success, the function returns the actual number of elements needed\&. I\&.e\&. if the return value is bigger than
\fIn\fR, only the values for the first
\fIn\fR
elements are in the array, and the remaining values have been discarded\&. Note that given the specification of the array contents, there is always a fixed upper bound on the number of actual elements, and if there are no
presence
sub\-containers, the number is constant\&. See the description of
\fBcdb_get_object()\fR
in
\m[blue]\fBconfd_lib_cdb(3)\fR\m[]
for usage examples \- they apply to
\fBmaapi_get_object()\fR
as well\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_get_objects('
.nr wm 0
.nr wp \w'struct\ maapi_cursor\ *mc,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nobj);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_objects("
.br
.BI "struct\ maapi_cursor\ *" "mc" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ *" "nobj" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_objects(struct\ maapi_cursor\ *" "mc" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ *" "nobj" ");" \}
.PP
Similar to
\fBmaapi_get_object()\fR, but reads multiple list entries based on a
\fBstruct maapi_cursor\fR\&. At most
\fIn\fR
values from each of at most
\fI*nobj\fR
list entries, starting at the entry after the one given by
\fI*mc\fR, are read and placed in the
\fIvalues\fR
array\&. The cursor must have been initialized with
\fBmaapi_init_cursor()\fR
at some point before the call, but in principle it is possible to mix calls to
\fBmaapi_get_next()\fR
and
\fBmaapi_get_objects()\fR
using the same cursor\&.
.PP
The array must be at least
n * *nobj
elements long, and the values for entry
i
start at element
array[i * n]
(i\&.e\&. the first entry read starts at
array[0], the second at
array[n], and so on)\&. On success, the highest actual number of values in any of the entries read is returned\&. If we attempt to read more entries than actually exist (i\&.e\&. if there are less than
\fI*nobj\fR
entries after the entry indicated by
\fI*mc\fR),
\fI*nobj\fR
is updated with the actual number (possibly 0) of entries read\&. In this case the
\fIn\fR
element of the cursor is set to 0 as for
\fBmaapi_get_next()\fR\&. Example \- read the data for all entries in the "server" list above, in chunks of 10:
.sp
.if n \{\
.RS 4
.\}
.nf
#define VALUES_PER_ENTRY 3
#define ENTRIES_PER_REQUEST 10

struct maapi_cursor mc;
confd_value_t v[ENTRIES_PER_REQUEST*VALUES_PER_ENTRY];
int nobj, ret, i;

maapi_init_cursor(sock, th, &mc, "/servers/server");
do {
    nobj = ENTRIES_PER_REQUEST;
    ret = maapi_get_objects(&mc, v, VALUES_PER_ENTRY, &nobj);
    if (ret >= 0) {
        for (i = 0; i < nobj; i++) {
            \&.\&.\&. process entry starting at v[i*VALUES_PER_ENTRY] \&.\&.\&.
        }
    } else {
        \&.\&.\&. handle error \&.\&.\&.
    }
} while (ret >= 0 && mc\&.n != 0);
maapi_destroy_cursor(&mc);
.fi
.if n \{\
.RE
.\}
.PP
See also the description of
\fBcdb_get_object()\fR
in
\m[blue]\fBconfd_lib_cdb(3)\fR\m[]
for examples on how to use loaded schema information to avoid "hardwiring" constants like VALUES_PER_ENTRY above, and the relative position of individual leaf values in the value array\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_PROTOUSAGE, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_get_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_values("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_values(int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Read an arbitrary set of sub\-elements of a container or list entry\&. The
\fIvalues\fR
array must be pre\-populated with
\fIn\fR
values based on the specification of the
\fITagged Value Array\fR
format in the
\fIXML STRUCTURES\fR
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page, where the
\fBconfd_value_t\fR
value element is given as follows:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C_NOEXISTS means that the value should be read from the transaction and stored in the array\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C_PTR also means that the value should be read from the transaction, but instead gives the expected type and a pointer to the type\-specific variable where the value should be stored\&. Thus this gives a functionality similar to the type safe
\fBmaapi_get_xxx_elem()\fR
functions\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C_XMLBEGIN and C_XMLEND are used as per the specification\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Keys to select list entries can be given with their values\&.
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
When we use C_PTR, we need to take special care to free any allocated memory\&. When we use C_NOEXISTS and the value is stored in the array, we can just use
\fBconfd_free_value()\fR
regardless of the type, since the
\fBconfd_value_t\fR
has the type information\&. But with C_PTR, only the actual value is stored in the pointed\-to variable, just as for
\fBmaapi_get_buf_elem()\fR,
\fBmaapi_get_binary_elem()\fR, etc, and we need to free the memory specifically allocated for the types listed in the description of
\fBmaapi_get_elem()\fR
above\&. The details of how to do this are not given for the
\fBmaapi_get_xxx_elem()\fR
functions here, but it is the same as for the corresponding
\fBcdb_get_xxx()\fR
functions, see
\m[blue]\fBconfd_lib_cdb(3)\fR\m[]\&.
.sp .5v
.RE
.PP
All elements have the same position in the array after the call, in order to simplify extraction of the values \- this means that optional elements that were requested but didn\*(Aqt exist will have C_NOEXISTS rather than being omitted from the array\&. However requesting a list entry that doesn\*(Aqt exist is an error\&. Note that when using C_PTR, the only indication of a non\-existing value is that the destination variable has not been modified \- it\*(Aqs up to the application to set it to some "impossible" value before the call when optional leafs are read\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Selection of a list entry by its "instance integer", which can be done with
\fBcdb_get_values()\fR
by using C_CDBBEGIN, can
\fInot\fR
be done with
\fBmaapi_get_values()\fR
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_set_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_object("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_object(int\ " "sock" ", int\ " "thandle" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Set all leafs corresponding to the complete contents of a list entry or container, excluding for sub\-lists\&. The
\fIvalues\fR
array must be populated with
\fIn\fR
values according to the specification of the Value Array format in the
\m[blue]\fBXML STRUCTURES\fR\m[]
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&. Additionally, since operational data cannot be written, array elements corresponding to operational data leafs or containers must have the value C_NOEXISTS\&.
.PP
If the node specified by the path, or any sub\-nodes that are specified as existing, do not exist before this call, they will be created, otherwise the existing values will be updated\&. Nodes that can be deleted and are specified as not existing in the array, i\&.e\&. with value C_NOEXISTS, will be deleted if they existed before the call\&.
.PP
For a list entry, since the key values must be present in the array, it is not required that the key values are included in the path given by
\fIfmt\fR\&. If the key values
\fIare\fR
included in the path, the key values in the array are ignored\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_set_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_values("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_values(int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Set arbitrary sub\-elements of a container or list entry\&. The
\fIvalues\fR
array must be populated with
\fIn\fR
values according to the specification of the
\fITagged Value Array\fR
format in the
\fIXML STRUCTURES\fR
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
If the container or list entry itself, or any sub\-elements that are specified as existing, do not exist before this call, they will be created, otherwise the existing values will be updated\&. Both mandatory and optional elements may be omitted from the array, and all omitted elements are left unchanged\&. To actually delete a non\-mandatory leaf or presence container as described for
\fBmaapi_set_object()\fR, it may (as an extension of the format) be specified as C_NOEXISTS instead of being omitted\&.
.PP
For a list entry, the key values can be specified either in the path or via key elements in the array \- if the values are in the path, the key elements can be omitted from the array\&. For sub\-lists present in the array, the key elements must of course always also be present though, immediately following the C_XMLBEGIN element and in the order defined by the data model\&. It is also possible to delete a list entry by using a C_XMLBEGINDEL element, followed by the keys in data model order, followed by a C_XMLEND element\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_get_case('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *rcase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_case("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_case(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
When we use the YANG
choice
statement in the data model, this function can be used to find the currently selected
case, avoiding useless
\fBmaapi_get_elem()\fR
etc requests for nodes that belong to other cases\&. The
\fIfmt, \&.\&.\&.\fR
arguments give the path to the list entry or container where the choice is defined, and
\fIchoice\fR
is the name of the choice\&. The case value is returned to the
\fBconfd_value_t\fR
that
\fIrcase\fR
points to, as type C_XMLTAG \- i\&.e\&. we can use the
\fBCONFD_GET_XMLTAG()\fR
macro to retrieve the hashed tag value\&.
.PP
If we have "nested" choices, i\&.e\&. multiple levels of
choice
statements without intervening
container
or
list
statements in the data model, the
\fIchoice\fR
argument must give a \*(Aq/\*(Aq\-separated path with alternating choice and case names, from the data node given by the
\fIfmt, \&.\&.\&.\fR
arguments to the specific choice that the request pertains to\&.
.PP
For a choice without a
mandatory true
statement where no case is currently selected, the function will fail with CONFD_ERR_NOEXISTS if the choice doesn\*(Aqt have a default case\&. If it has a default case, it will be returned unless the MAAPI_FLAG_NO_DEFAULTS flag is in effect (see
\fBmaapi_set_flags()\fR
below) \- if the flag is set, the value returned via
\fIrcase\fR
will have type C_DEFAULT\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED
.nr wf \w'int\ maapi_get_attrs('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *attrs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attrs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_attr_value_t\ **attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *num_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_attrs("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "attrs" ", int\ " "num_attrs" ", confd_attr_value_t\ **" "attr_vals" ", int\ *" "num_vals" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_attrs(int\ " "sock" ", int\ " "thandle" ", u_int32_t\ *" "attrs" ", int\ " "num_attrs" ", confd_attr_value_t\ **" "attr_vals" ", int\ *" "num_vals" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Retrieve attributes for a configuration node\&. These attributes are currently supported:
.sp
.if n \{\
.RS 4
.\}
.nf
/* CONFD_ATTR_TAGS: value is C_LIST of C_BUF/C_STR */
#define CONFD_ATTR_TAGS       0x80000000
/* CONFD_ATTR_ANNOTATION: value is C_BUF/C_STR */
#define CONFD_ATTR_ANNOTATION 0x80000001
/* CONFD_ATTR_INACTIVE: value is C_BOOL 1 (i\&.e\&. "true") */
#define CONFD_ATTR_INACTIVE   0x00000000
/* CONFD_ATTR_BACKPOINTER: value is C?LIST of C_BUF/C_STR */
#define CONFD_ATTR_BACKPOINTER 0x80000003

.fi
.if n \{\
.RE
.\}
.PP
The
\fIattrs\fR
parameter is an array of attributes of length
\fInum_attrs\fR, specifying the wanted attributes \- if
\fInum_attrs\fR
is 0, all attributes are retrieved\&. If no attributes are found,
\fI*num_vals\fR
is set to 0, otherwise an array of
\fBconfd_attr_value_t\fR
elements is allocated and populated, its address stored in
\fI*attr_vals\fR, and
\fI*num_vals\fR
is set to the number of elements in the array\&. The
\fBconfd_attr_value_t\fR
struct is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
typedef struct confd_attr_value {
    u_int32_t attr;
    confd_value_t v;
} confd_attr_value_t;
.fi
.if n \{\
.RE
.\}
.PP
If any attribute values are returned (\fI*num_vals\fR
> 0), the caller must free the allocated memory by calling
\fBconfd_free_value()\fR
for each of the
\fBconfd_value_t\fR
elements, and
\fBfree(3)\fR
for the
\fI*attr_vals\fR
array itself\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_UNAVAILABLE
.nr wf \w'int\ maapi_set_attr('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ attr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_attr("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", u_int32_t\ " "attr" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_attr(int\ " "sock" ", int\ " "thandle" ", u_int32_t\ " "attr" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Set an attribute for a configuration node\&. See
\fBmaapi_get_attrs()\fR
above for the supported attributes\&. To delete an attribute, call the function with a value of type C_NOEXISTS\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOEXISTS, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_UNAVAILABLE
.nr wf \w'int\ maapi_delete_all('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_delete_how\ how);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_delete_all("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_delete_how\ " "how" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_delete_all(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_delete_how\ " "how" ");" \}
.PP
This function can be used to delete "all" the configuration data within a transaction\&. The
\fIhow\fR
argument specifies the extent of "all":
.PP
\fBMAAPI_DEL_SAFE\fR
.RS 4
Delete everything except namespaces that were exported to none (with
tailf:export none)\&. Toplevel nodes that cannot be deleted due to AAA rules are silently left in place, but descendant nodes will still be deleted if the AAA rules allow it\&.
.RE
.PP
\fBMAAPI_DEL_EXPORTED\fR
.RS 4
Delete everything except namespaces that were exported to none (with
tailf:export none)\&. AAA rules are ignored, i\&.e\&. nodes are deleted even if the AAA rules don\*(Aqt allow it\&.
.RE
.PP
\fBMAAPI_DEL_ALL\fR
.RS 4
Delete everything\&. AAA rules are ignored\&.
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_revert('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_revert("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_revert(int\ " "sock" ", int\ " "thandle" ");" \}
.PP
This function removes all changes done to the transaction\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_set_flags('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_flags("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_flags(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.PP
We can modify some aspects of the read/write session by calling this function \- these values can be used for the
\fIflags\fR
argument (ORed together if more than one) with this function and/or with
\fBmaapi_start_trans_flags()\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
#define MAAPI_FLAG_HINT_BULK     (1 << 0)
#define MAAPI_FLAG_NO_DEFAULTS   (1 << 1)
#define MAAPI_FLAG_CONFIG_ONLY   (1 << 2)
#define MAAPI_FLAG_HIDE_INACTIVE (1 << 3) /* maapi_start_trans_flags() only */
#define MAAPI_FLAG_DELAYED_WHEN  (1 << 6) /* maapi_start_trans_flags() only */
.fi
.if n \{\
.RE
.\}
.PP
MAAPI_FLAG_HINT_BULK tells the ConfD backplane that we will be reading substantial amounts of data\&. This has the effect that the
\fBget_object()\fR
and
\fBget_next_object()\fR
callbacks (if available) are used towards external data providers when we call
\fBmaapi_get_elem()\fR
etc and
\fBmaapi_get_next()\fR\&. The
\fBmaapi_get_object()\fR
function always operates as if this flag was set\&.
.PP
MAAPI_FLAG_NO_DEFAULTS says that we want to be informed when we read leafs with default values that have not had a value set\&. This is indicated by the returned value being of type C_DEFAULT instead of the actual value\&. The default value for such leafs can be obtained from the
\fBconfd_cs_node\fR
tree provided by the library (see
\m[blue]\fBconfd_types(3)\fR\m[])\&.
.PP
MAAPI_FLAG_CONFIG_ONLY will make the maapi_get_xxx() functions return config nodes only \- if we attempt to read operational data, it will be treated as if the nodes did not exist\&. This is mainly useful in conjunction with
\fBmaapi_get_object()\fR
and list entries or containers that have both config and operational data (the operational data nodes in the returned array will have the "value" C_NOEXISTS), but the other functions also obey the flag\&.
.PP
MAAPI_FLAG_HIDE_INACTIVE can only be used with
\fBmaapi_start_trans_flags()\fR, and only when starting a readonly transaction (parameter
\fIreadwrite\fR
==
\fBCONFD_READ\fR)\&. It will hide configuration data that has the
\fBCONFD_ATTR_INACTIVE\fR
attribute set, i\&.e\&. it will appear as if that data does not exist\&.
.PP
MAAPI_FLAG_DELAYED_WHEN can also only be used with
\fBmaapi_start_trans_flags()\fR, but regardless of whether the flag is used or not, the "delayed when" mode can subsequently be changed with
\fBmaapi_set_delayed_when()\fR\&. The flag is only meaningful when starting a read\-write transaction (parameter
\fIreadwrite\fR
==
\fBCONFD_READ_WRITE\fR), and will cause "delayed when" mode to be enabled from the beginning of the transaction\&. See the description of
\fBmaapi_set_delayed_when()\fR
for information about the "delayed when" mode\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_set_delayed_when('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ on);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_delayed_when("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "on" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_delayed_when(int\ " "sock" ", int\ " "thandle" ", int\ " "on" ");" \}
.PP
This function enables (\fIon\fR
non\-zero) or disables (\fIon\fR
== 0) the "delayed when" mode of a transaction\&. When successful, it returns 1 or 0 as indication of whether "delayed when" was enabled or disabled before the call\&. See also the
\fBMAAPI_FLAG_DELAYED_WHEN\fR
flag for
\fBmaapi_start_trans_flags()\fR\&.
.PP
The YANG
when
statement makes its parent data definition statement conditional\&. This can be problematic in cases where we don\*(Aqt have control over the order of writing different data nodes\&. E\&.g\&. when loading configuration from a file, the data that will satisfy the
when
condition may occur after the data that the
when
applies to, making it impossible to actually write the latter data into the transaction \- since the
when
isn\*(Aqt satisfied, the data nodes effectively do not exist in the schema\&.
.PP
This is addressed by the "delayed when" mode for a transaction\&. When "delayed when" is enabled, it is possible to write to data nodes even though they are conditional on a
when
that isn\*(Aqt satisfied\&. It has no effect on reading though \- trying to read data that is conditional on an unsatisfied
when
will always result in CONFD_ERR_NOEXISTS or equivalent\&. When disabling "delayed when", any "delayed"
when
statements will take effect immediately \- i\&.e\&. if the
when
isn\*(Aqt satisfied at that point, the conditional nodes and any data values for them will be deleted\&. If we don\*(Aqt explicitly disable "delayed when" by calling this function, it will be automatically disabled when the transaction enters the VALIDATE state (e\&.g\&. due to call of
\fBmaapi_apply_trans()\fR)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_set_label('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *label);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_label("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "label" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_label(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "label" ");" \}
.PP
Set the "Label" that is stored in the rollback file when a transaction towards running is committed\&. Setting the "Label" for transactions via candidate can be done when the candidate is committed to running, by using the
\fBmaapi_candidate_commit_info()\fR
function\&. For a confirmed commit, the "Label" must also be given via the
\fBmaapi_candidate_confirmed_commit_info()\fR
function\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_set_comment('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *comment);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_comment("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "comment" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_comment(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "comment" ");" \}
.PP
Set the "Comment" that is stored in the rollback file when a transaction towards running is committed\&. Setting the "Comment" for transactions via candidate can be done when the candidate is committed to running, by using the
\fBmaapi_candidate_commit_info()\fR
function\&. For a confirmed commit, the "Comment" must also be given via the
\fBmaapi_candidate_confirmed_commit_info()\fR
function\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_NOEXISTS
.SH "NCS SPECIFIC FUNCTIONS"
.PP
The functions in this sections can only be used with NCS, and specifically the maapi_shared_xxx() functions must be used for NCS FASTMAP, i\&.e\&. in the service
\fBcreate()\fR
callback\&. Those functions maintain attributes that are necessary when multiple service instances modify the same data\&.
.nr wf \w'int\ maapi_shared_create('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_create("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_create(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
FASTMAP version of
\fBmaapi_create()\fR\&. Normally the
\fIflags\fR
parameter should be given as 0, but it is possible to suppress the creation of backpointer attributes by passing
\fBMAAPI_SHARED_NO_BACKPOINTER\fR
for
\fIflags\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOTCREATABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_shared_set_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_set_elem("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_set_elem(int\ " "sock" ", int\ " "thandle" ", confd_value_t\ *" "v" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ maapi_shared_set_elem2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *strval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_set_elem2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_set_elem2(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "strval" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
FASTMAP versions of
\fBmaapi_set_elem()\fR
and
\fBmaapi_set_elem2()\fR\&. The
\fIflags\fR
parameter is currently unused and should be given as 0\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_shared_insert('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_insert("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_insert(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
FASTMAP version of
\fBmaapi_insert()\fR\&. Normally the
\fIflags\fR
parameter should be given as 0, but it is possible to suppress the creation of backpointer attributes by passing
\fBMAAPI_SHARED_NO_BACKPOINTER\fR
for
\fIflags\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_BADTYPE, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOEXISTS, CONFD_ERR_NOTDELETABLE
.nr wf \w'int\ maapi_shared_set_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_set_values("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_set_values(int\ " "sock" ", int\ " "thandle" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
FASTMAP version of
\fBmaapi_set_values()\fR\&. Normally the
\fIflags\fR
parameter should be given as 0, but it is possible to suppress the creation of backpointer attributes by passing
\fBMAAPI_SHARED_NO_BACKPOINTER\fR
for
\fIflags\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_INUSE
.nr wf \w'int\ maapi_shared_copy_tree('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *from,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *tofmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_copy_tree("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_copy_tree(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.PP
FASTMAP version of
\fBmaapi_copy_tree()\fR\&. Normally the
\fIflags\fR
parameter should be given as 0, but it is possible to suppress the creation of backpointer attributes by passing
\fBMAAPI_SHARED_NO_BACKPOINTER\fR
for
\fIflags\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_BADPATH
.nr wf \w'int\ maapi_ncs_apply_template('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *template_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_name_value\ *variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *rootfmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_ncs_apply_template("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_ncs_apply_template(int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.PP
Apply a template that has been loaded into NCS\&. The
\fItemplate_name\fR
parameter gives the name of the template\&. The
\fIvariables\fR
parameter is an
\fInum_variables\fR
long array of variables and names for substitution into the template\&. The
\fBstruct ncs_name_value\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct ncs_name_value {
    char *name;
    char *value;
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fIflags\fR
parameter is currently unused and should be given as 0\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If this function is called under FASTMAP it will have the same behavior as the corresponding FASTMAP function
\fBmaapi_shared_ncs_apply_template()\fR\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_XPATH
.nr wf \w'int\ maapi_shared_ncs_apply_template('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *template_name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ ncs_name_value\ *variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_variables,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *rootfmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_shared_ncs_apply_template("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_shared_ncs_apply_template(int\ " "sock" ", int\ " "thandle" ", char\ *" "template_name" ", const\ struct\ ncs_name_value\ *" "variables" ", int\ " "num_variables" ", int\ " "flags" ", const\ char\ *" "rootfmt" ", \&.\&.\&.);" \}
.PP
FASTMAP version of
\fBmaapi_ncs_apply_template()\fR\&. Normally the
\fIflags\fR
parameter should be given as 0\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_XPATH
.nr wf \w'int\ maapi_ncs_get_templates('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ ***templates,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *num_templates);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_ncs_get_templates("
.br
.BI "int\ " "sock" ", char\ ***" "templates" ", int\ *" "num_templates" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_ncs_get_templates(int\ " "sock" ", char\ ***" "templates" ", int\ *" "num_templates" ");" \}
.PP
Retrieve a list of the templates currently loaded into NCS\&. On success, a pointer to an array of template names is stored in
\fItemplates\fR
and the length of the array is stored in
\fInum_templates\fR\&. The library allocates memory for the result, and the caller is responsible for freeing it\&. This can in all cases be done with code like this:
.sp
.if n \{\
.RS 4
.\}
.nf
char **templates;
int num_templates, i;

if (maapi_ncs_get_templates(sock, &templates, &num_templates) == CONFD_OK) {
    \&.\&.\&.
    for (i = 0; i < num_templates; i++) {
        free(templates[i]);
    }
    if (num_templates > 0) {
        free(templates);
    }
}
.fi
.if n \{\
.RE
.\}
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.SH "MISCELLANEOUS FUNCTIONS"
.nr wf \w'int\ maapi_delete_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_dbname\ name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_delete_config("
.br
.BI "int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_delete_config(int\ " "sock" ", enum\ confd_dbname\ " "name" ");" \}
.PP
This function empties a data store\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_copy('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ from_thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ to_thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy("
.br
.BI "int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy(int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ");" \}
.PP
If we open two transactions from the same user session but towards different data stores, such as one transaction towards startup and one towards running, we can copy all data from one data store to the other with this function\&. This is a replace operation \- any configuration that exists in the transaction given by
\fIto_handle\fR
but not in the one given by
\fIfrom_handle\fR
will be deleted from the
\fIto_handle\fR
transaction\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ maapi_copy_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ from_thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ to_thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy_path("
.br
.BI "int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy_path(int\ " "sock" ", int\ " "from_thandle" ", int\ " "to_thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Similar to
\fBmaapi_copy()\fR, but does a replacing copy only of the subtree rooted at the path given by
\fIfmt\fR
and remaining arguments\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ maapi_copy_tree('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *from,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *tofmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_copy_tree("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_copy_tree(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "from" ", const\ char\ *" "tofmt" ", \&.\&.\&.);" \}
.PP
This function copies the entire configuration tree rooted at
\fIfrom\fR
to
\fItofmt\fR\&. List entries are created accordingly\&. If the destination already exists,
\fIfrom\fR
is copied on top of the destination\&. This function is typically used inside actions where we for example could use
\fBmaapi_copy_tree()\fR
to copy a template configuration into a new list entry\&. The
\fIfrom\fR
path must be pre\-formatted, e\&.g\&. using
\fBconfd_format_keypath()\fR, whereas the destination path is formatted by this function\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
The data models for the source and destination trees must match \- i\&.e\&. they must either be identical, or the data model for the source tree must be a proper subset of the data model for the destination tree\&. This is always fulfilled when copying from one entry to another in a list, or if both source and destination tree have been defined via YANG
uses
statements referencing the same
grouping
definition\&. If a data model mismatch is detected, e\&.g\&. an existing data node in the source tree does not exist in the destination data model, or an existing leaf in the source tree has a value that is incompatible with the type of the leaf in the destination data model,
\fBmaapi_copy_tree()\fR
will return CONFD_ERR with
\fIconfd_errno\fR
set to CONFD_ERR_BADPATH\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_BADPATH
.nr wf \w'int\ maapi_insert('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_insert("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_insert(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function inserts a new entry in a list that uses the
tailf:indexed\-view
statement\&. The key must be of type integer\&. If the inserted entry already exists, the existing and subsequent entries will be renumbered as needed, unless renumbering would require an entry to have a key value that is outside the range of the type for the key\&. In that case, the function returns CONFD_ERR with
\fIconfd_errno\fR
set to CONFD_ERR_BADTYPE\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_BADTYPE, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOEXISTS, CONFD_ERR_NOTDELETABLE
.nr wf \w'int\ maapi_move('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t*\ tokey,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_move("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_move(int\ " "sock" ", int\ " "thandle" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function moves an existing list entry, i\&.e\&. renames the entry using the
\fItokey\fR
parameter, which is an array containing
\fIn\fR
keys\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOEXISTS, CONFD_ERR_NOTMOVABLE, CONFD_ERR_ALREADY_EXISTS
.nr wf \w'int\ maapi_move_ordered('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_move_where\ where,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t*\ tokey,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_move_ordered("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_move_where\ " "where" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_move_ordered(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_move_where\ " "where" ", confd_value_t*\ " "tokey" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
For a list with the YANG
ordered\-by user
statement, this function can be used to change the order of entries, by moving one entry to a new position\&. When new entries in such a list are created with
\fBmaapi_create()\fR, they are always placed last in the list\&. The path given by
\fIfmt\fR
and the remaining arguments identifies the entry to move, and the new position is given by the
\fIwhere\fR
argument:
.PP
MAAPI_MOVE_FIRST
.RS 4
Move the entry first in the list\&. The
\fItokey\fR
and
\fIn\fR
arguments are ignored, and can be given as NULL and 0\&.
.RE
.PP
MAAPI_MOVE_LAST
.RS 4
Move the entry last in the list\&. The
\fItokey\fR
and
\fIn\fR
arguments are ignored, and can be given as NULL and 0\&.
.RE
.PP
MAAPI_MOVE_BEFORE
.RS 4
Move the entry to the position before the entry given by the
\fItokey\fR
argument, which is an array of key values with length
\fIn\fR\&.
.RE
.PP
MAAPI_MOVE_AFTER
.RS 4
Move the entry to the position after the entry given by the
\fItokey\fR
argument, which is an array of key values with length
\fIn\fR\&.
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOEXISTS, CONFD_ERR_NOTMOVABLE
.nr wf \w'int\ maapi_authenticate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *user,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *pass,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *groups[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_authenticate("
.br
.BI "int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_authenticate(int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.PP
If we are implementing a proprietary management agent with MAAPI API, the function
\fBmaapi_start_user_session()\fR
requires the application to tell ConfD which groups the user are member of\&. ConfD itself has the capability to authenticate users\&. A MAAPI application can use
\fBmaapi_authenticate()\fR
to let ConfD authenticate the user, as per the AAA configuration in confd\&.conf
.PP
If the authentication is successful, the function returns
\fB1\fR, and the
\fIgroups[]\fR
array is populated with at most
\fIn\-1\fR
NUL\-terminated strings containing the group names, followed by a NULL pointer that indicates the end of the group list\&. The strings are dynamically allocated, and it is up to the caller to free the memory by calling
\fBfree(3)\fR
for each string\&. If the function is used in a context where the group names are not needed, pass
\fB1\fR
for the
\fIn\fR
parameter\&.
.PP
If the authentication fails, the function returns
\fB0\fR, and
\fBconfd_lasterr()\fR
(see
\m[blue]\fBconfd_lib_lib(3)\fR\m[]) will return a message describing the reason for the failure\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION
.nr wf \w'int\ maapi_authenticate2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *user,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *pass,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ confd_ip\ *src_addr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ src_port,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_proto\ prot,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *groups[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_authenticate2("
.br
.BI "int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", const\ char\ *" "context" ", enum\ confd_proto\ " "prot" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_authenticate2(int\ " "sock" ", const\ char\ *" "user" ", const\ char\ *" "pass" ", const\ struct\ confd_ip\ *" "src_addr" ", int\ " "src_port" ", const\ char\ *" "context" ", enum\ confd_proto\ " "prot" ", char\ *" "groups[]" ", int\ " "n" ");" \}
.PP
This function does the same thing as
\fBmaapi_authenticate()\fR, but allows for passing of the additional parameters
\fIsrc_addr\fR,
\fIsrc_port\fR,
\fIcontext\fR, and
\fIprot\fR, which otherwise are passed only to
\fBmaapi_start_user_session()\fR/\fBmaapi_start_user_session2()\fR\&. These parameters are not used when ConfD performs the authentication, but they will be passed to an external authentication executable (see the
\m[blue]\fBExternal authentication\fR\m[]
section of the AAA chapter in the User Guide) if
/confdConfig/aaa/externalAuthentication/includeExtra
is set to "true" in
confd\&.conf, see
\m[blue]\fBconfd\&.conf(5)\fR\m[]\&. They will also be made available to the authentication callback that can be registered by an application (see
\m[blue]\fBconfd_lib_dp(3)\fR\m[])\&.
.PP
\fIErrors\fR: CONFD_ERR_PROTOUSAGE, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION
.nr wf \w'int\ maapi_attach('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_trans_ctx\ *ctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_attach("
.br
.BI "int\ " "sock" ", int\ " "hashed_ns" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_attach(int\ " "sock" ", int\ " "hashed_ns" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.PP
While ConfD is executing a transaction, we have a number of situations where we wish to invoke user C code which can interact in the transaction\&. One such situation is when we wish to write semantic validation code which is invoked in the validation phase of a ConfD transaction\&. This code needs to execute within the context of the executing transaction, it must thus have access to the "shadow" storage where all not\-yet\-committed data is kept\&.
.PP
This function attaches to a existing transaction\&. See the
\m[blue]\fBSemantic Validation chapter in the User Guide\fR\m[]
for example code\&.
.PP
Another situation where we wish to attach to the executing transaction is when we are using the notifications API and subscribe to notification of type CONFD_NOTIF_COMMIT_DIFF and wish to read the committed diffs from the transaction\&.
.PP
The
\fIhashed_ns\fR
parameter is basically just there to save a call to
\fBmaapi_set_namespace()\fR\&. We can call
\fBmaapi_set_namespace()\fR
any number of times to change from the one we passed to
\fBmaapi_attach()\fR, and we can also give the namespace in prefix form in the path parameter to the read/write functions \- see the
\fBmaapi_set_namespace()\fR
description\&.
.PP
If we do not want to give a specific namespace when invoking
\fBmaapi_attach()\fR, we can give 0 for the
\fIhashed_ns\fR
parameter (\-1 works too but is deprecated)\&. We can still call the read/write functions as long as the toplevel element in the path is unique, but otherwise we must call
\fBmaapi_set_namespace()\fR, or use a prefix in the path\&.
.nr wf \w'int\ maapi_attach2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_attach2("
.br
.BI "int\ " "sock" ", int\ " "hashed_ns" ", int\ " "usid" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_attach2(int\ " "sock" ", int\ " "hashed_ns" ", int\ " "usid" ", int\ " "thandle" ");" \}
.PP
When we write proprietary CLI commands in C and we wish those CLI commands to be able to use MAAPI to read and write data inside the same transaction the CLI command was invoked in, we do not have an initialized transaction structure available\&. Then we must use this function\&. CLI commands get the
\fIusid\fR
passed in UNIX environment variable
\fICONFD_MAAPI_USID\fR
and the
\fIthandle\fR
passed in environment variable
\fICONFD_MAAPI_THANDLE\fR\&. We also need to use this function when implementing such CLI commands via action
\fBcommand()\fR
callbacks, see the
\m[blue]\fBconfd_lib_dp(3)\fR\m[]
man page\&. In this case the
\fIusid\fR
is provided via
\fIuinfo\->usid\fR
and the
\fIthandle\fR
via
\fIuinfo\->actx\&.thandle\fR\&. To use the user session id that is the owner of the transaction, set
\fIusid\fR
to 0\&. If the namespace does not matter set
\fIhashed_ns\fR
to 0, see
\fBmaapi_attach()\fR\&.
.nr wf \w'int\ maapi_attach_init('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_attach_init("
.br
.BI "int\ " "sock" ", int\ *" "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_attach_init(int\ " "sock" ", int\ *" "thandle" ");" \}
.PP
This function is used to attach the MAAPI socket to the special transaction available in phase0 used for CDB initialization and upgrade\&. The function is also used if we need to modify CDB data during in\-service data model upgrade (see the
\m[blue]\fB"In\-service Data Model Upgrade" chapter in the User Guide\fR\m[])\&. The transaction handle, which is used in subsequent calls to MAAPI, is filled in by the function upon successful return\&. See the
\m[blue]\fBCDB chapter in the User Guide\fR\m[]\&.
.nr wf \w'int\ maapi_detach('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_trans_ctx\ *ctx);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_detach("
.br
.BI "int\ " "sock" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_detach(int\ " "sock" ", struct\ confd_trans_ctx\ *" "ctx" ");" \}
.PP
Detaches an attached MAAPI socket\&. This function is typically called in the
\fBstop()\fR
callback in validation code\&. An attached MAAPI socket will be automatically detached when the ConfD transaction terminates\&. This function performs an explicit detach\&.
.nr wf \w'int\ maapi_detach2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_detach2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_detach2(int\ " "sock" ", int\ " "thandle" ");" \}
.PP
Detaches an attached MAAPI socket when we do not have an initialized transaction structure available, see
\fBmaapi_attach2()\fR
above\&. This is mainly useful in an action
\fBcommand()\fR
callback\&.
.nr wf \w'int\ maapi_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_diff_iterate(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.PP
This function can be called from an attached MAAPI session\&. The purpose of the function is to iterate through the transaction diff\&. It can typically be used in conjunction with the notification API when we subscribe to CONFD_NOTIF_COMMIT_DIFF events\&. It can also be used inside validation callbacks\&.
.PP
For all diffs in the transaction the supplied callback function
\fBiter()\fR
will be called\&. The
\fBiter()\fR
callback receives the
\fIconfd_hkeypath_t kp\fR
which uniquely identifies which node in the data tree that is affected, the operation, and an optional value\&. The
\fIop\fR
parameter gives the modification as:
.PP
MOP_CREATED
.RS 4
The list entry,
presence
container, or leaf of type
empty
given by
\fIkp\fR
has been created\&.
.RE
.PP
MOP_DELETED
.RS 4
The list entry,
presence
container, or optional leaf given by
\fIkp\fR
has been deleted\&.
.RE
.PP
MOP_MODIFIED
.RS 4
A descendant of the list entry given by
\fIkp\fR
has been modified\&.
.RE
.PP
MOP_VALUE_SET
.RS 4
The value of the leaf given by
\fIkp\fR
has been set to
\fInewv\fR\&. If the MAAPI_FLAG_NO_DEFAULTS flag has been set and the default value for the leaf has come into effect,
\fInewv\fR
will be of type C_DEFAULT instead of giving the default value\&.
.RE
.PP
MOP_MOVED_AFTER
.RS 4
The list entry given by
\fIkp\fR, in an
ordered\-by user
list, has been moved\&. If
\fInewv\fR
is NULL, the entry has been moved first in the list, otherwise it has been moved after the entry given by
\fInewv\fR\&. In this case
\fInewv\fR
is a pointer to an array of key values identifying an entry in the list\&. The array is terminated with an element that has type C_NOEXISTS\&.
.RE
.PP
MOP_ATTR_SET
.RS 4
An attribute for the node given by
\fIkp\fR
has been modified (see the description of
\fBmaapi_get_attrs()\fR
for the supported attributes)\&. The
\fBiter()\fR
callback will only get this invocation when attributes are enabled in
confd\&.conf
(/confdConfig/enableAttributes, see
\m[blue]\fBconfd\&.conf(5)\fR\m[])
\fIand\fR
the flag
\fBITER_WANT_ATTR\fR
has been passed to
\fBmaapi_diff_iterate()\fR\&. The
\fInewv\fR
parameter is a pointer to a 2\-element array, where the first element is the attribute represented as a
\fBconfd_value_t\fR
of type
\fBC_UINT32\fR
and the second element is the value the attribute was set to\&. If the attribute has been deleted, the second element is of type
\fBC_NOEXISTS\fR\&.
.RE
.PP
The
\fIoldv\fR
parameter passed to
\fBiter()\fR
is always NULL\&.
.PP
If
\fBiter()\fR
returns ITER_STOP, no more iteration is done, and CONFD_OK is returned\&. If
\fBiter()\fR
returns ITER_RECURSE iteration continues with all children to the node\&. If
\fBiter()\fR
returns ITER_CONTINUE iteration ignores the children to the node (if any), and continues with the node\*(Aqs sibling\&. If, for some reason, the
\fBiter()\fR
function wants to return control to the caller of
\fBmaapi_diff_iterate()\fR\fIbefore\fR
all the changes have been iterated over it can return ITER_SUSPEND\&. The caller then has to call
\fBmaapi_diff_iterate_resume()\fR
to continue/finish the iteration\&.
.PP
The
\fIflags\fR
parameter is a bitmask with the following bits:
.PP
ITER_WANT_ATTR
.RS 4
Enable
\fBMOP_ATTR_SET\fR
invocations of the
\fBiter()\fR
function\&.
.RE
.PP
ITER_WANT_P_CONTAINER
.RS 4
Invoke
\fBiter()\fR
for modified presence\-containers\&.
.RE
.PP
ITER_WANT_LEAF_LIST_AS_LEAF
.RS 4
Changes to leaf\-lists will cause invocations of
\fBiter()\fR
as for leafs and not as for lists, e\&.g\&. with MOP_VALUE_SET rather than MOP_CREATED / MOP_DELETED\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This flag is deprecated, and only present for temporary backward compatibility \- it will be removed in a future release\&.
.sp .5v
.RE
.RE
.PP
The
\fIstate\fR
parameter can be used for any user supplied state (i\&.e\&. whatever is supplied as
\fIinit_state\fR
is passed as
\fIstate\fR
to
\fBiter()\fR
in each invocation)\&.
.PP
The
\fBiter()\fR
invocations are not subjected to AAA checks, i\&.e\&. regardless of which path we have and which context was used to create the MAAPI socket, all changes are provided\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE\&.
.PP
CONFD_ERR_BADSTATE is returned when we try to iterate on a transaction which is in the wrong state and not attached\&.
.nr wf \w'int\ maapi_keypath_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_keypath_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_keypath_diff_iterate(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.PP
This function behaves precisely like the
\fBmaapi_diff_iterate()\fR
function except that it takes an additional format path argument\&. This path prunes the diff and only changes below the provided path are considered\&.
.nr wf \w'int\ maapi_diff_iterate_resume('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ reply,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *resumestate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_diff_iterate_resume("
.br
.BI "int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_diff_iterate_resume(int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ maapi_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.PP
The application
\fImust\fR
call this function to finish up the iteration whenever an iterator function for
\fBmaapi_diff_iterate()\fR
or
\fBmaapi_keypath_diff_iterate()\fR
has returned ITER_SUSPEND\&. If the application does not wish to continue iteration, it must at least call
maapi_diff_iterate_resume(s, ITER_STOP, NULL, NULL);
to clean up the state\&. The
\fIreply\fR
parameter is what the iterator function would have returned (i\&.e\&. normally ITER_RECURSE or ITER_CONTINUE) if it hadn\*(Aqt returned ITER_SUSPEND\&. Note that it is up to the iterator function to somehow communicate that it has returned ITER_SUSPEND to the caller of
\fBmaapi_diff_iterate()\fR
or
\fBmaapi_keypath_diff_iterate()\fR, this can for example be a field in a struct for which a pointer can be passed back and forth via the
\fIstate\fR/\fIresumestate\fR
parameters\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE\&.
.nr wf \w'int\ maapi_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_attr_value_t\ *attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_iterate("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_iterate(int\ " "sock" ", int\ " "thandle" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.PP
This function can be used to iterate over all the data in a transaction and the underlying data store, as opposed to iterating over only the changes like
\fBmaapi_diff_iterate()\fR
and
\fBmaapi_keypath_diff_iterate()\fR
do\&. The
\fIfmtpath\fR
parameter can be used to prune the iteration to cover only the subtree below the given path, similar to
\fBmaapi_keypath_diff_iterate()\fR
\- if
\fIfmtpath\fR
is given as
\fB"/"\fR, there will not be any such pruning\&. Additionally, if the flag
\fBMAAPI_FLAG_CONFIG_ONLY\fR
is in effect (see
\fBmaapi_set_flags()\fR), all operational data subtrees will be excluded from the iteration\&.
.PP
The supplied callback function
\fBiter()\fR
will be called for each node in the data tree included in the iteration\&. It receives the
\fIkp\fR
parameter which uniquely identifies the node, and if the node is a leaf with a type, also the value of the leaf as the
\fIv\fR
parameter \- otherwise
\fIv\fR
is NULL\&.
.PP
The
\fIflags\fR
parameter is a bitmask with the following bits:
.PP
ITER_WANT_ATTR
.RS 4
If this flag is given and the node has any attributes set, the
\fIattr_vals\fR
parameter will point to a
\fInum_attr_vals\fR
long array of attributes and values (see
\fBmaapi_get_attrs()\fR), otherwise
\fIattr_vals\fR
is NULL\&.
.RE
.PP
ITER_WANT_LEAF_LIST_AS_LEAF
.RS 4
If this flag is given, leaf\-lists will cause invocations of
\fBiter()\fR
as for leafs and not as for lists, i\&.e\&. a single invocation with the
\fIv\fR
parameter giving the complete leaf\-list, rather than an invocation for each leaf\-list element with the value in the
\fIkp\fR
parameter\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This flag is deprecated, and only present for temporary backward compatibility \- it will be removed in a future release\&.
.sp .5v
.RE
.RE
.PP
The return value from
\fBiter()\fR
has the same effect as for
\fBmaapi_diff_iterate()\fR, except that if ITER_SUSPEND is returned, the caller then has to call
\fBmaapi_iterate_resume()\fR
to continue/finish the iteration\&.
.nr wf \w'int\ maapi_iterate_resume('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ reply,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ maapi_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_attr_value_t\ *attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ num_attr_vals,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *resumestate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_iterate_resume("
.br
.BI "int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_iterate_resume(int\ " "sock" ", enum\ maapi_iter_ret\ " "reply" ", enum\ maapi_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", confd_attr_value_t\ *" "attr_vals" ", int\ " "num_attr_vals" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.PP
The application
\fImust\fR
call this function to finish up the iteration whenever an iterator function for
\fBmaapi_iterate()\fR
has returned ITER_SUSPEND\&. If the application does not wish to continue iteration, it must at least call
maapi_iterate_resume(s, ITER_STOP, NULL, NULL);
to clean up the state\&. The
\fIreply\fR
parameter is what the iterator function would have returned (i\&.e\&. normally ITER_RECURSE or ITER_CONTINUE) if it hadn\*(Aqt returned ITER_SUSPEND\&. Note that it is up to the iterator function to somehow communicate that it has returned ITER_SUSPEND to the caller of
\fBmaapi_iterate()\fR, this can for example be a field in a struct for which a pointer can be passed back and forth via the
\fIstate\fR/\fIresumestate\fR
parameters\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE\&.
.nr wf \w'int\ maapi_get_running_db_status('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_running_db_status("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_running_db_status(int\ " "sock" ");" \}
.PP
If a transaction fails in the commit() phase, the configuration database is in in a possibly inconsistent state\&. This function queries ConfD on the consistency state\&. Returns 1 if the configuration is consistent and 0 otherwise\&.
.nr wf \w'int\ maapi_set_running_db_status('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ status);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_running_db_status("
.br
.BI "int\ " "sock" ", int\ " "status" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_running_db_status(int\ " "sock" ", int\ " "status" ");" \}
.PP
This function explicitly sets ConfDs notion of the consistency state\&.
.nr wf \w'int\ maapi_list_rollbacks('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ maapi_rollback\ *rp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *rp_size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_list_rollbacks("
.br
.BI "int\ " "sock" ", struct\ maapi_rollback\ *" "rp" ", int\ *" "rp_size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_list_rollbacks(int\ " "sock" ", struct\ maapi_rollback\ *" "rp" ", int\ *" "rp_size" ");" \}
.PP
List at most
\fB*rp_size\fR
number of rollback files\&. The number of existing rollback files is reported in *rp_size as well\&. The function will populate an array of maapi_rollback structs\&.
.nr wf \w'int\ maapi_load_rollback('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ rollback_num);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_rollback("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "rollback_num" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_rollback(int\ " "sock" ", int\ " "thandle" ", int\ " "rollback_num" ");" \}
.PP
Install a rollback file\&.
.nr wf \w'int\ maapi_request_action('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *params,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nparams,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_request_action("
.br
.BI "int\ " "sock" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", int\ " "hashed_ns" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_request_action(int\ " "sock" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", int\ " "hashed_ns" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Invoke an action defined in the data model\&. The
\fIparams\fR
and
\fIvalues\fR
arrays are the parameters for and results from the action, respectively, and use the Tagged Value Array format described in the
\m[blue]\fBXML STRUCTURES\fR\m[]
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&. The library allocates memory for the result values, and the caller is responsible for freeing it\&. This can in all cases be done with code like this:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_tag_value_t *values;
int nvalues = 0, i;

if (maapi_request_action(sock, params, nparams,
                         &values, &nvalues, myprefix__ns,
                         "/path/to/action") == CONFD_OK) {
    \&.\&.\&.
    for (i = 0; i < nvalues; i++)
        confd_free_value(CONFD_GET_TAG_VALUE(&values[i]));
    if (nvalues > 0)
        free(values);
}
.fi
.if n \{\
.RE
.\}
.PP
However if the value array is known not to include types that require memory allocation (see
\fBmaapi_get_elem()\fR
above), only the array itself needs to be freed\&.
.PP
The socket must have an established user session\&. The path given by
\fIfmt\fR
and the varargs list is the full path to the action, i\&.e\&. the final element must be the name of the action in the data model\&. Since actions are not associated with ConfD transactions, the namespace must be provided and the path must be absolute \- but see
\fBmaapi_request_action_th()\fR
below\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_request_action_th('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *params,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nparams,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_request_action_th("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_request_action_th(int\ " "sock" ", int\ " "thandle" ", confd_tag_value_t\ *" "params" ", int\ " "nparams" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Does the same thing as
\fBmaapi_request_action()\fR, but uses the current namespace, the path position, and the user session from the transaction indicated by
\fIthandle\fR, and makes the transaction handle available to the action() callback, see
\m[blue]\fBconfd_lib_dp(3)\fR\m[]
(this is the only relation to the transaction, and the transaction is not affected in any way by the call itself)\&. This function may be convenient in some cases where actions are invoked in conjunction with a transaction, and it must be used if the action needs to access the transaction store\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_request_action_str_th('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **output,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cmd_fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *path_fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_request_action_str_th("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ **" "output" ", const\ char\ *" "cmd_fmt" ", const\ char\ *" "path_fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_request_action_str_th(int\ " "sock" ", int\ " "thandle" ", char\ **" "output" ", const\ char\ *" "cmd_fmt" ", const\ char\ *" "path_fmt" ", \&.\&.\&.);" \}
.PP
Does the same thing as
\fBmaapi_request_action_th()\fR, but takes the parameters as a string and returns the result as a string\&. The library allocates memory for the result string, and the caller is responsible for freeing it\&. This can in all cases be done with code like this:
.sp
.if n \{\
.RS 4
.\}
.nf
char *output = NULL;

if (maapi_request_action_str_th(sock, th, &output,
    "test reverse listint [ 1 2 3 4 ]", "/path/to/action") == CONFD_OK) {
    \&.\&.\&.
    free(output);
}
.fi
.if n \{\
.RE
.\}
.PP
The varargs in the end of the function must contain all values listed in both format strings (that is
\fIcmd_fmt\fR
and
\fIpath_fmt\fR) in the same order as they occur in the strings\&. Here follows an equivalent example which uses the format strings:
.sp
.if n \{\
.RS 4
.\}
.nf
char *output = NULL;

if (maapi_request_action_str_th(sock, th, &output,
    "test %s [ 1 2 3 %d ]", "%s/action",
    "reverse listint", 4, "/path/to") == CONFD_OK) {
    \&.\&.\&.
    free(output);
}
.fi
.if n \{\
.RE
.\}
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSESSION, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS, CONFD_ERR_BADTYPE, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_xpath2kpath('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *xpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **hkp);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_xpath2kpath("
.br
.BI "int\ " "sock" ", const\ char\ *" "xpath" ", confd_hkeypath_t\ **" "hkp" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_xpath2kpath(int\ " "sock" ", const\ char\ *" "xpath" ", confd_hkeypath_t\ **" "hkp" ");" \}
.PP
Convert a XPath path to a hashed keypath\&. The XPath expression must be an "instance identifier", i\&.e\&. all elements and keys must be fully specified\&. Namespace prefixes are optional, unless required to resolve ambiguities (e\&.g\&. when multiple namespaces have the same root element)\&.
.PP
The returned keypath is dynamically allocated, and may further contain dynamically allocated elements\&. The caller must free the allocated memory, easiest done by calling
\fBconfd_free_hkeypath()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.nr wf \w'int\ maapi_user_message('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *to,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *message,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *sender);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_user_message("
.br
.BI "int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ", const\ char\ *" "sender" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_user_message(int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ", const\ char\ *" "sender" ");" \}
.PP
Send a message to a specific user, a specific user session or all users depending on the
\fIto\fR
parameter\&. If set to a user name, then
\fImessage\fR
will be delivered to all CLI and Web UI sessions by that user\&. If set to an integer string, eg "10", then
\fImessage\fR
will be delivered to that specific user session, CLI or Web UI\&. If set to "all" then all users will get the
\fImessage\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_sys_message('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *to,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *message);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_sys_message("
.br
.BI "int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_sys_message(int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.PP
Send a message to a specific user, a specific user session or all users depending on the
\fIto\fR
parameter\&. If set to a user name, then
\fImessage\fR
will be delivered to all CLI and Web UI sessions by that user\&. If set to an integer string, eg "10", then
\fImessage\fR
will be delivered to that specific user session, CLI or Web UI\&. If set to "all" then all users will get the
\fImessage\fR\&. No formatting of the message is performed as opposed to the user message where a timestamp and sender information is added to the message\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_prio_message('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *to,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *message);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_prio_message("
.br
.BI "int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_prio_message(int\ " "sock" ", const\ char\ *" "to" ", const\ char\ *" "message" ");" \}
.PP
Send a high priority message to a specific user, a specific user session or all users depending on the
\fIto\fR
parameter\&. If set to a user name, then
\fImessage\fR
will be delivered to all CLI and Web UI sessions by that user\&. If set to an integer string, eg "10", then
\fImessage\fR
will be delivered to that specific user session, CLI or Web UI\&. If set to "all" then all users will get the
\fImessage\fR\&. No formatting of the message is performed as opposed to the user message where a timestamp and sender information is added to the message\&.
.PP
The message will not be delayed until the user terminates any ongoing command but will be output directly to the terminal without delay\&. Messages sent using the maapi_sys_message and maapi_user_message, on the other hand, are not displayed in the middle of some other output but delayed until the any ongoing commands have terminated\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_prompt('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.PP
Prompt user for a string\&. The
\fIecho\fR
parameter is used to control if the input should be echoed or not\&. If set to CONFD_ECHO all input will be visible and if set to CONFD_NOECHO only stars will be shown instead of the actual characters entered by the user\&. The resulting string will be stored in
\fIres\fR
and it will be NUL terminated\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_prompt2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.PP
This function does the same as
\fBmaapi_cli_prompt()\fR, but also takes a
\fItimeout\fR
parameter, which controls how long (in seconds) to wait for input before aborting\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_prompt_oneof('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ count,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt_oneof("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt_oneof(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", char\ *" "res" ", int\ " "size" ");" \}
.PP
Prompt user for one of the strings given in the
\fIchoice\fR
parameter\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
int res;
char buf[BUFSIZ];
char *choice[] = {"yes","no"};

\&.\&.\&.

res = maapi_cli_prompt_oneof(sock, uinfo\->usid,
                             "Do you want to proceed (yes/no): ",
                             choice, 2, buf, BUFSIZ);
.fi
.if n \{\
.RE
.\}
.PP
The user can enter a unique prefix of the choice but the value returned in buf will always be one of the strings provided in the
\fIchoice\fR
parameter\&. The result string stored in buf is NUL terminated\&. If the user enters a value not in
\fIchoice\fR
he will automatically be re\-prompted\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
Do you want to proceed (yes/no): maybe
The value must be one of: yes,no\&.
Do you want to proceed (yes/no):
.fi
.if n \{\
.RE
.\}
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_prompt_oneof2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *prompt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ count,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_prompt_oneof2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_prompt_oneof2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "prompt" ", char\ **" "choice" ", int\ " "count" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.PP
This function does the same as
\fBmaapi_cli_promt_oneof()\fR, but also takes a
\fItimeout\fR
parameter\&. If no activity is seen for
\fItimeout\fR
seconds an error is returned\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_read_eof('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_read_eof("
.br
.BI "int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_read_eof(int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", char\ *" "res" ", int\ " "size" ");" \}
.PP
Read a multi line string from the CLI\&. The user has to end the input using ctrl\-D\&. The entered characters will be stored NUL terminated in res\&. The
\fIecho\fR
parameters controls if the entered characters should be echoed or not\&. If set to CONFD_ECHO they will be visible and if set to CONFD_NOECHO stars will be echoed instead\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_read_eof2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ echo,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_read_eof2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_read_eof2(int\ " "sock" ", int\ " "usess" ", int\ " "echo" ", int\ " "timeout" ", char\ *" "res" ", int\ " "size" ");" \}
.PP
This function does the same as
\fBmaapi_cli_read_eof()\fR, but also takes a
\fItimeout\fR
parameter, which indicates how long the user may be idle (in seconds) before the reading is aborted\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_write('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_write("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_write(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.PP
Write to the CLI\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_printf('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_printf("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_printf(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Write to the CLI using printf formatting\&. This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_vprintf('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_vprintf("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_vprintf(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.PP
Does the same as
\fBmaapi_cli_printf()\fR, but takes a single
\fBva_list\fR
argument instead of a variable number of arguments, like
\fBvprintf()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_accounting('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *user,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ int\ usid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cmdstr);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_accounting("
.br
.BI "int\ " "sock" ", const\ char\ *" "user" ", const\ int\ " "usid" ", const\ char\ *" "cmdstr" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_accounting(int\ " "sock" ", const\ char\ *" "user" ", const\ int\ " "usid" ", const\ char\ *" "cmdstr" ");" \}
.PP
Generate an audit log entry in the CLI audit log\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_diff_cmd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle_old,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_diff_cmd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "thandle_old" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_diff_cmd(int\ " "sock" ", int\ " "thandle" ", int\ " "thandle_old" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Get the diff between two sessions as C\-/I\-style CLI commands\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_path_cmd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_path_cmd("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_path_cmd(int\ " "sock" ", int\ " "thandle" ", char\ *" "res" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function tries to determine which C\-/I\-style CLI command can be associated with a given path in the data model in context of a given transaction\&. This is determined by running the formatting code used by the \*(Aqshow running\-config\*(Aq command for the subtree given by the path, and the looking for text lines associated with the given path\&. Consequentcly, if the path does not exist in the transaction no output will be generated, or if tailf:cli\- annotations have been used to suppress the \*(Aqshow running\-config\*(Aq text for a path then no such command can be derived\&.
.PP
The
\fIflags\fR
can be given as
\fBMAAPI_FLAG_EMIT_PARENTS\fR
to enable the commands to reach the submode for the path to be emitted\&.
.PP
The
\fIflags\fR
can be given as
\fBMAAPI_FLAG_DELETE\fR
to emit the command to delete the given path\&.
.PP
The
\fIflags\fR
can be given as
\fBMAAPI_FLAG_NON_RECURSIVE\fR
to prevent that all children to a container or list item are displayed\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd_to_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *line,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsize,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *path,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ psize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_to_path("
.br
.BI "int\ " "sock" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_to_path(int\ " "sock" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.PP
Given a data model path formatted as a C\- and I\-style command, try to determine the corresponding namespace and path\&. If the string cannot be interpreted as a path an error message is given indicating that the string is either an operational mode command, a configuration mode command, or just badly formatted\&. The string is interpreted in the context of the current running configuration, ie all xpath expressions in the data model are evaluated in the context of the running config\&. Note that the same input may result in a correct answer when invoked with one state of the running config, and an error if the running config has another state due to different list elements being present, or xpath (when and display\-when) expressions are being evaluated differently\&.
.PP
This function requires that the socket has an established user session\&.
.PP
The
\fIline\fR
is the NUL terminated string of command tokens to be interpreted\&.
.PP
The
\fIns\fR
and
\fIpath\fR
parameters are used for storing the resulting namespace and path\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd_to_path2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *line,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsize,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *path,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ psize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_to_path2("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_to_path2(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "line" ", char\ *" "ns" ", int\ " "nsize" ", char\ *" "path" ", int\ " "psize" ");" \}
.PP
Given a data model path formatted as a C\- and I\-style command, try to determine the corresponding namespace and path\&. If the string cannot be interpreted as a path an error message is given indicating that the string is either an operational mode command, a configuration mode command, or just badly formatted\&. The string is interpreted in the context of the provided transaction handler, ie all xpath expressions in the data model are evaluated in the context of the transaction\&. Note that the same input may result in a correct answer when invoked with one state of one config, and an error when given another config due to different list elements being present, or xpath (when and display\-when) expressions are being evaluated differently\&.
.PP
This function requires that the socket has an established user session\&.
.PP
The
\fIth\fR
is a transaction handler\&.
.PP
The
\fIline\fR
is the NUL terminated string of command tokens to be interpreted\&.
.PP
The
\fIns\fR
and
\fIpath\fR
parameters are used for storing the resulting namespace and path\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ");" \}
.PP
Execute CLI command in ongoing CLI session\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ");" \}
.PP
Execute CLI command in ongoing CLI session\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&. The flags field is used to disable certain checks during the execution\&. The value is a bitmask\&.
.PP
MAAPI_CMD_NO_FULLPATH
.RS 4
Do not perform the fullpath check on show commands\&.
.RE
.PP
MAAPI_CMD_NO_HIDDEN
.RS 4
Allows execution of hidden CLI commands\&.
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd3('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd3("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd3(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.PP
Execute CLI command in ongoing CLI session\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&. The flags field is used to disable certain checks during the execution\&. The value is a bitmask\&.
.PP
MAAPI_CMD_NO_FULLPATH
.RS 4
Do not perform the fullpath check on show commands\&.
.RE
.PP
MAAPI_CMD_NO_HIDDEN
.RS 4
Allows execution of hidden CLI commands\&.
.RE
.PP
The unhide parameter is used for passing a hide group which is unhidden during the execution of the command\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd4('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd4("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd4(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.PP
Execute CLI command in ongoing CLI session\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&. The flags field is used to disable certain checks during the execution\&. The value is a bitmask\&.
.PP
MAAPI_CMD_NO_FULLPATH
.RS 4
Do not perform the fullpath check on show commands\&.
.RE
.PP
MAAPI_CMD_NO_HIDDEN
.RS 4
Allows execution of hidden CLI commands\&.
.RE
.PP
The unhide parameter is used for passing hide groups which are unhidden during the execution of the command\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd_io('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_io("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_io(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", const\ char\ *" "unhide" ", int\ " "usize" ");" \}
.PP
Execute CLI command in ongoing CLI session and output result on socket\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&. The flags field is used to disable certain checks during the execution\&. The value is a bitmask\&.
.PP
MAAPI_CMD_NO_FULLPATH
.RS 4
Do not perform the fullpath check on show commands\&.
.RE
.PP
MAAPI_CMD_NO_HIDDEN
.RS 4
Allows execution of hidden CLI commands\&.
.RE
.PP
The unhide parameter is used for passing a hide group which is unhidden during the execution of the command\&.
.PP
The function returns
\fBCONFD_ERR\fR
on error or a positive integer id that can subsequently be used together with
\fBconfd_stream_connect()\fR\&. ConfD will write all data in a stream on that socket and when done, ConfD will close its end of the socket\&.
.PP
Once the stream socket is connected we can read the output from the cli command data on the socket\&. We need to continue reading until we receive EOF on the socket\&. To check if the command was successful we use the function\&.
\fBmaapi_cli_cmd_io_result()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd_io2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *buf,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **unhide,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usize);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_io2("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_io2(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "buf" ", int\ " "size" ", int\ " "flags" ", char\ **" "unhide" ", int\ " "usize" ");" \}
.PP
Execute CLI command in ongoing CLI session and output result on socket\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&. The flags field is used to disable certain checks during the execution\&. The value is a bitmask\&.
.PP
MAAPI_CMD_NO_FULLPATH
.RS 4
Do not perform the fullpath check on show commands\&.
.RE
.PP
MAAPI_CMD_NO_HIDDEN
.RS 4
Allows execution of hidden CLI commands\&.
.RE
.PP
The unhide parameter is used for passing hide groups which are unhidden during the execution of the command\&.
.PP
The function returns
\fBCONFD_ERR\fR
on error or a positive integer id that can subsequently be used together with
\fBconfd_stream_connect()\fR\&. ConfD will write all data in a stream on that socket and when done, ConfD will close its end of the socket\&.
.PP
Once the stream socket is connected we can read the output from the cli command data on the socket\&. We need to continue reading until we receive EOF on the socket\&. To check if the command was successful we use the function\&.
\fBmaapi_cli_cmd_io_result()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_cmd_io_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_cmd_io_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_cmd_io_result(int\ " "sock" ", int\ " "id" ");" \}
.PP
We use this function to read the status of executing a cli command and streaming the result over a socket\&. The
\fIsock\fR
parameter must be the same maapi socket we used for
\fBmaapi_cli_cmd_io()\fR
and the
\fIid\fR
parameter is the
\fIid\fR
returned by
\fBmaapi_cli_cmd_io()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_cli_get('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *opt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ size);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_get("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", char\ *" "res" ", int\ " "size" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_get(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", char\ *" "res" ", int\ " "size" ");" \}
.PP
Read CLI session parameter or attribute\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
Possible params are
for C and I\-style: complete\-on\-space, idle\-timeout, ignore\-leading\-space, paginate, output\-file, screen\-length, screen\-width, history, terminal, autowizard, "service prompt config" , show\-defaults, and if enabled, display\-level\&. And for J\-style:
complete\-on\-space, idle\-timeout, ignore\-leading\-space, paginate, "output file", "screen length", "screen width", terminal, history, autowizard, "show defaults", and if enabled, display\-level\&. In addition to this the attributes called annotation, tags and inactive can be read\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_cli_set('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ usess,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *opt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *value);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_cli_set("
.br
.BI "int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", const\ char\ *" "value" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_cli_set(int\ " "sock" ", int\ " "usess" ", const\ char\ *" "opt" ", const\ char\ *" "value" ");" \}
.PP
Set CLI session parameter\&.
.PP
This function is intended to be called from inside an action callback when invoked from the CLI\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_set_readonly_mode('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flag);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_set_readonly_mode("
.br
.BI "int\ " "sock" ", int\ " "flag" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_set_readonly_mode(int\ " "sock" ", int\ " "flag" ");" \}
.PP
There are certain situations where we want to explicitly control if a ConfD instance should be able to handle write operations from the northbound agents\&. In certain high\-availability scenarios we may want to ensure that a node is a true readonly node, i\&.e\&. it should not be possible to initiate new write transactions on that node\&.
.PP
It can also be interesting in upgrade scenarios where we are interested in making sure that no configuration changes can occur during some interval\&.
.PP
This function toggles the readonly mode of a ConfD instance\&. If the
\fIflag\fR
parameter is non\-zero, ConfD will be set in readonly mode, if it is zero, ConfD will be taken out of readonly mode\&. It is also worth to note that when a ConfD HA node is in slave mode as instructed by the application, no write transactions can occur regardless of the value of the flag set by this function\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_disconnect_remote('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *address);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_disconnect_remote("
.br
.BI "int\ " "sock" ", const\ char\ *" "address" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_disconnect_remote(int\ " "sock" ", const\ char\ *" "address" ");" \}
.PP
Disconnect all remote connections between
\fBCONFD_IPC_PORT\fR
(see the
\m[blue]\fBConfD IPC section in the Advanced Topics chapter in the User Guide\fR\m[]) and
\fIaddress\fR\&.
.PP
Since ConfD clients, e\&.g\&. CDB readers/subscribers, are connected using TCP it is also possible to do this remotely over a network\&. However since TCP doesn\*(Aqt offer a fast and reliable way of detecting that the other end has disappeared ConfD can get stuck waiting for a reply from such a disconnected client\&.
.PP
In some environments there will be an alternative supervision method that can detect when a remote host is unavailable, and in that situation this function can be used to instruct ConfD to drop all remote connections to a particular host\&. The address parameter is an IP address as a string, and the socket is a maapi socket obtained using
\fBmaapi_connect()\fR\&. On success, the function returns the number of connections that were closed\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
ConfD will close all its sockets with remote address
\fIaddress\fR,
\fIexcept\fR
HA connections\&. For HA use
\fBconfd_ha_slave_dead()\fR
or an HA state transition\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE, CONFD_ERR_UNAVAILABLE
.nr wf \w'int\ maapi_disconnect_sockets('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *sockets,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsocks);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_disconnect_sockets("
.br
.BI "int\ " "sock" ", int\ *" "sockets" ", int\ " "nsocks" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_disconnect_sockets(int\ " "sock" ", int\ *" "sockets" ", int\ " "nsocks" ");" \}
.PP
This function is an alternative to
\fBmaapi_disconnect_remote()\fR
that can be useful in particular when using the "External IPC" functionality (see "Using a different IPC mechanism" in the
\m[blue]\fBConfD IPC section in the Advanced Topics chapter in the User Guide\fR\m[])\&. In this case ConfD does not have any knowledge of the remote address of the IPC connections, and thus
\fBmaapi_disconnect_remote()\fR
is not applicable\&. The
\fBmaapi_disconnect_sockets()\fR
instead takes an array of
\fInsocks\fR
socket file descriptor numbers for the
\fIsockets\fR
parameter\&.
.PP
ConfD will close all connected sockets whose local file descriptor number is included the
\fIsockets\fR
array\&. The file descriptor numbers can be obtained e\&.g\&. via the
\fBlsof(8)\fR
command, or some similar tool in case
\fBlsof\fR
does not support the IPC mechanism that is being used\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE
.nr wf \w'int\ maapi_save_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_save_config("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_save_config(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.PP
This function can be used to save the entire config (or a subset thereof) in different formats\&. The
\fIflags\fR
parameter controls the saving as follows\&. The value is a bitmask\&.
.PP
\fBMAAPI_CONFIG_XML\fR
.RS 4
The configuration format is XML\&.
.RE
.PP
\fBMAAPI_CONFIG_XML_PRETTY\fR
.RS 4
The configuration format is pretty printed XML\&.
.RE
.PP
\fBMAAPI_CONFIG_JSON\fR
.RS 4
The configuration is in JSON format\&.
.RE
.PP
\fBMAAPI_CONFIG_J\fR
.RS 4
The configuration is in curly bracket Juniper CLI format\&.
.RE
.PP
\fBMAAPI_CONFIG_C\fR
.RS 4
The configuration is in Cisco XR style format\&.
.RE
.PP
\fBMAAPI_CONFIG_C_IOS\fR
.RS 4
The configuration is in Cisco IOS style format\&.
.RE
.PP
\fBMAAPI_CONFIG_XPATH\fR
.RS 4
The
\fIfmtpath\fR
and remaining arguments give an XPath filter instead of a keypath\&. Can only be used with
\fBMAAPI_CONFIG_XML\fR
and
\fBMAAPI_CONFIG_XML_PRETTY\fR\&.
.RE
.PP
\fBMAAPI_CONFIG_WITH_DEFAULTS\fR
.RS 4
Default values are part of the configuration dump\&.
.RE
.PP
\fBMAAPI_CONFIG_SHOW_DEFAULTS\fR
.RS 4
Default values are also shown next to the real configuration value\&. Applies only to the CLI formats\&.
.RE
.PP
\fBMAAPI_CONFIG_WITH_OPER\fR
.RS 4
Include operational data in the dump\&.
.RE
.PP
\fBMAAPI_CONFIG_HIDE_ALL\fR
.RS 4
Hide all hidden nodes (see below)\&.
.RE
.PP
\fBMAAPI_CONFIG_UNHIDE_ALL\fR
.RS 4
Unhide all hidden nodes (see below)\&.
.RE
.PP
\fBMAAPI_CONFIG_WITH_SERVICE_META\fR
.RS 4
Include NCS service\-meta\-data attributes (refcounter, backpointer, and original\-value) in the dump\&.
.RE
.PP
\fBMAAPI_CONFIG_NO_PARENTS\fR
.RS 4
When a path is provided its parent nodes are by default included\&. With this option the output will begin immediately at path \- skipping any parents\&.
.RE
.PP
\fBMAAPI_CONFIG_OPER_ONLY\fR
.RS 4
Include
\fIonly\fR
operational data, and ancestors to operational data nodes, in the dump\&.
.RE
.PP
The provided path indicates which part(s) of the configuration to save\&. By default it is interpreted as a keypath as for other MAAPI functions, and thus identifies the root of a subtree to save\&. However it is possible to indicate wildcarding of list keys by completely omitting key elements \- i\&.e\&. this requests save of a subtree for each entry of the corresponding list\&. For
\fBMAAPI_CONFIG_XML\fR
and
\fBMAAPI_CONFIG_XML_PRETTY\fR
it is alternatively possible to give an XPath filter, by including the flag
\fBMAAPI_CONFIG_XPATH\fR\&.
.PP
If for example
\fIfmtpath\fR
is
"/aaa:aaa/authentication/users"
we dump a subtree of the AAA data, while if it is
"/aaa:aaa/authentication/users/user/homedir", we dump only the
homedir
leaf for each user in the AAA data\&. If
\fIfmtpath\fR
is NULL, the entire configuration is dumped, except that namespaces with restricted export (from
tailf:export) are treated as follows:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
When the
\fBMAAPI_CONFIG_XML\fR
or
\fBMAAPI_CONFIG_XML_PRETTY\fR
formats are used, the context of the user session that started the transaction is used to select namespaces with restricted export\&. If the "system" context is used, all namespaces are selected, regardless of export restriction\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
When one of the CLI formats is used, the context used to select namespaces with restricted export is always "cli"\&.
.RE
.PP
By default, the treatment of nodes with a
tailf:hidden
statement depends on the state of the transaction\&. For a transaction started via MAAPI, no nodes are hidden, while for a transaction started by another northbound agent (e\&.g\&. CLI) and attached to, the nodes that are hidden are the same as in that agent session\&. The default can be overridden by using one of the flags
\fBMAAPI_CONFIG_HIDE_ALL\fR
and
\fBMAAPI_CONFIG_UNHIDE_ALL\fR\&.
.PP
The function returns
\fBCONFD_ERR\fR
on error or a positive integer id that can subsequently be used together with
\fBconfd_stream_connect()\fR\&. Thus this function doesn\*(Aqt save the configuration to a file, but rather it returns an integer than is used together with a ConfD stream socket\&. ConfD will write all data in a stream on that socket and when done, ConfD will close its end of the socket\&. Thus the following code snippet indicates the usage pattern of this function\&.
.sp
.if n \{\
.RS 4
.\}
.nf
int id;
int streamsock;
struct sockaddr_in addr;

id = maapi_save_config(sock, th, flags, path);
if (id < 0) {
    \&.\&.\&. handle error \&.\&.\&.
}

addr\&.sin_addr\&.s_addr = inet_addr("127\&.0\&.0\&.1");
addr\&.sin_family = AF_INET;
addr\&.sin_port = htons(CONFD_PORT);

streamsock = socket(PF_INET, SOCK_STREAM, 0);
confd_stream_connect(streamsock, (struct sockaddr*)&addr,
                      sizeof(struct sockaddr_in), id, 0);
.fi
.if n \{\
.RE
.\}
.PP
Once the stream socket is connected we can read the configuration data on the socket\&. We need to continue reading until we receive EOF on the socket\&. To check if the configuration retrieval was successful we use the function
\fBmaapi_save_config_result()\fR\&.
.PP
The stream socket must be connected within 10 seconds after the id is received\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BAD_TYPE
.nr wf \w'int\ maapi_save_config_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_save_config_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_save_config_result(int\ " "sock" ", int\ " "id" ");" \}
.PP
We use this function to verify that we received the entire configuration over the stream socket\&. The
\fIsock\fR
parameter must be the same maapi socket we used for
\fBmaapi_save_config()\fR
and the
\fIid\fR
parameter is the
\fIid\fR
returned by
\fBmaapi_save_config()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_load_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *filename);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "filename" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "filename" ");" \}
.PP
This function loads a configuration from
\fIfilename\fR
into ConfD\&. The
\fIth\fR
parameter is a transaction handle\&. This can be either for a transaction created by the application, in which case the application must also apply the transaction, or for an attached transaction (which must not be applied by the application)\&. The format of the file can be either XML, curly bracket Juniper CLI format, Cisco XR style format, or Cisco IOS style format\&. The caller of the function has to indicate which it is by using one of the
\fBMAAPI_CONFIG_XML\fR,
\fBMAAPI_CONFIG_J\fR,
\fBMAAPI_CONFIG_C\fR, or
\fBMAAPI_CONFIG_C_IOS\fR
flags, with the same meanings as for
\fBmaapi_save_config()\fR\&. If the name of the file ends in \&.gz (or \&.Z) then the file is assumed to be gzipped, and will be uncompressed as it is loaded\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If you use a relative pathname for
\fIfilename\fR, it is taken as relative to the working directory of the ConfD daemon, i\&.e\&. the directory where the daemon was started\&.
.sp .5v
.RE
.PP
By default the complete configuration (as allowed by the user of the current transaction) is deleted before the file is loaded\&. To merge the contents of the file use the
\fBMAAPI_CONFIG_MERGE\fR
flag\&. To replace only the part of the configuration that is present in the file, use the
\fBMAAPI_CONFIG_REPLACE\fR
flag\&.
.PP
If the transaction
\fIth\fR
is started against the data store
\fBCONFD_OPERATIONAL\fR
config false data is loaded\&. The existing config false data is not deleted before the file is loaded\&. Rather it is the responsibility of the client\&.
.PP
The only supported format for loading \*(Aqconfig false\*(Aq data is
\fBMAAPI_CONFIG_XML\fR\&.
.PP
Additional flags for
\fBMAAPI_CONFIG_XML\fR:
.PP
\fBMAAPI_CONFIG_WITH_OPER\fR
.RS 4
Any operational data in the file should be ignored (instead of producing an error)\&.
.RE
.PP
\fBMAAPI_CONFIG_XML_LOAD_LAX\fR
.RS 4
Lax loading\&. Ignore unknown namespaces, elements, and attributes\&.
.RE
.PP
\fBMAAPI_CONFIG_OPER_ONLY\fR
.RS 4
Load
\fIonly\fR
operational data, and ancestors to operational data nodes\&.
.RE
.PP
Additional flag for
\fBMAAPI_CONFIG_C\fR
and
\fBMAAPI_CONFIG_C_IOS\fR:
.PP
\fBMAAPI_CONFIG_AUTOCOMMIT\fR
.RS 4
A commit should be performed after each line\&. In this case the transaction identified by
\fIth\fR
is not used for the loading\&.
.RE
.PP
Additional flags for all CLI formats, i\&.e\&.
\fBMAAPI_CONFIG_J\fR,
\fBMAAPI_CONFIG_C\fR, and
\fBMAAPI_CONFIG_C_IOS\fR:
.PP
\fBMAAPI_CONFIG_CONTINUE_ON_ERROR\fR
.RS 4
Do not abort the load when an error is encountered\&.
.RE
.PP
\fBMAAPI_CONFIG_SUPPRESS_ERRORS\fR
.RS 4
Do not display the long error message but instead a oneline error with the line number\&.
.RE
.PP
The other
\fIflags\fR
parameters are the same as for
\fBmaapi_save_config()\fR, however the flags
\fBMAAPI_CONFIG_WITH_SERVICE_META\fR\fBMAAPI_CONFIG_NO_PARENTS\fR
are ignored\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE, CONFD_ERR_BADPATH, CONFD_ERR_BAD_CONFIG, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_PROTOUSAGE, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_load_config_cmds('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *cmds,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config_cmds("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "cmds" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config_cmds(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ", const\ char\ *" "cmds" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function loads a configuration like
\fBmaapi_load_config()\fR, but reads the configuration from the string
\fIcmds\fR
instead of from a file\&. The
\fIth\fR
and
\fIflags\fR
parameters are the same as for
\fBmaapi_load_config()\fR\&.
.PP
An optional
\fIchroot\fR
path can be given\&. This is only used with the
\fBMAAPI_CONFIG_C\fR
flag set\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE, CONFD_ERR_BADPATH, CONFD_ERR_BAD_CONFIG, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_PROTOUSAGE, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_load_config_stream('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config_stream("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config_stream(int\ " "sock" ", int\ " "thandle" ", int\ " "flags" ");" \}
.PP
This function loads a configuration like
\fBmaapi_load_config()\fR, but reads the configuration from a ConfD stream socket instead of from a file\&. The
\fIth\fR
and
\fIflags\fR
parameters are the same as for
\fBmaapi_load_config()\fR\&.
.PP
The function returns
\fBCONFD_ERR\fR
on error or a positive integer id that can subsequently be used together with
\fBconfd_stream_connect()\fR\&. ConfD will read all data from the stream socket until it receives EOF\&. Thus the following code snippet indicates the usage pattern of this function\&.
.sp
.if n \{\
.RS 4
.\}
.nf
int id;
int streamsock;
struct sockaddr_in addr;

id = maapi_load_config_stream(sock, th, flags);
if (id < 0) {
    \&.\&.\&. handle error \&.\&.\&.
}

addr\&.sin_addr\&.s_addr = inet_addr("127\&.0\&.0\&.1");
addr\&.sin_family = AF_INET;
addr\&.sin_port = htons(CONFD_PORT);

streamsock = socket(PF_INET, SOCK_STREAM, 0);
confd_stream_connect(streamsock, (struct sockaddr*)&addr,
                      sizeof(struct sockaddr_in), id, 0);
.fi
.if n \{\
.RE
.\}
.PP
Once the stream socket is connected we can write the configuration data on the socket\&. When we have written the complete configuration, we must close the socket, to make ConfD receive EOF\&. To check if the configuration load was successful we use the function
\fBmaapi_load_config_stream_result()\fR\&.
.PP
The stream socket must be connected within 10 seconds after the id is received\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE, CONFD_ERR_PROTOUSAGE, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_load_config_stream_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_load_config_stream_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_load_config_stream_result(int\ " "sock" ", int\ " "id" ");" \}
.PP
We use this function to verify that the configuration we wrote on the stream socket was successfully loaded\&. The
\fIsock\fR
parameter must be the same maapi socket we used for
\fBmaapi_load_config_stream()\fR
and the
\fIid\fR
parameter is the
\fIid\fR
returned by
\fBmaapi_load_config_stream()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE, CONFD_ERR_BADPATH, CONFD_ERR_BAD_CONFIG, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_roll_config('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_roll_config("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_roll_config(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.PP
This function can be used to save the equivalent of a rollback file for a given configuration before it is committed (or a subtree thereof) in curly bracket format\&.
.PP
The provided path indicates where we want the configuration to be rooted\&. It must be a prefix prepended keypath\&. If
\fIfmtpath\fR
is NULL, a rollback config for the entire configuration is dumped\&. If for example
\fIfmtpath\fR
is
"/aaa:aaa/authentication/users"
we create a rollback config for a part of the AAA data\&. It is not possible to extract non\-config data using this function\&.
.PP
The function returns
\fBCONFD_ERR\fR
on error or a positive integer id that can subsequently be used together with
\fBconfd_stream_connect()\fR\&. Thus this function doesn\*(Aqt save the rollback configuration to a file, but rather it returns an integer that is used together with a ConfD stream socket\&. ConfD will write all data in a stream on that socket and when done, ConfD will close its end of the socket\&. Thus the following code snippet indicates the usage pattern of this function\&.
.sp
.if n \{\
.RS 4
.\}
.nf
int id;
int streamsock;
struct sockaddr_in addr;

id = maapi_roll_config(sock, tid, path);
addr\&.sin_addr\&.s_addr = inet_addr("127\&.0\&.0\&.1");
addr\&.sin_family = AF_INET;
addr\&.sin_port = htons(CONFD_PORT);

streamsock = socket(PF_INET, SOCK_STREAM, 0);
confd_stream_connect(streamsock, (struct sockaddr*)&addr,
                      sizeof (struct sockaddr_in), id,0);
.fi
.if n \{\
.RE
.\}
.PP
Once the stream socket is connected we can read the configuration data on the socket\&. We need to continue reading until we receive EOF on the socket\&. To check if the configuration retrieval was successful we use the function
\fBmaapi_roll_config_result()\fR\&.
.PP
The stream socket must be connected within 10 seconds after the id is received\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BAD_TYPE
.nr wf \w'int\ maapi_roll_config_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_roll_config_result("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_roll_config_result(int\ " "sock" ", int\ " "id" ");" \}
.PP
We use this function to assert that we received the entire rollback configuration over a stream socket\&. The
\fIsock\fR
parameter must be the same maapi socket we used for
\fBmaapi_roll_config()\fR
and the
\fIid\fR
parameter is the
\fIid\fR
returned by
\fBmaapi_roll_config()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_ACCESS_DENIED, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_get_stream_progress('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ id);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_get_stream_progress("
.br
.BI "int\ " "sock" ", int\ " "id" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_get_stream_progress(int\ " "sock" ", int\ " "id" ");" \}
.PP
In some cases (e\&.g\&. an action or custom command that can be interrupted by the user) it may be useful to be able to terminate ConfD\*(Aqs reading of data from a stream socket (by closing the socket) without waiting for a potentially large amount of data written to the socket to be consumed by ConfD\&. This function allows us to limit the amount of data "in flight" between the application and ConfD, by reporting the amount of data read by ConfD so far\&.
.PP
The
\fIsock\fR
parameter must be the maapi socket used for a function call that required a stream socket for writing to ConfD (currently the only such function is
\fBmaapi_load_config_stream()\fR), and the
\fIid\fR
parameter is the
\fIid\fR
returned by that function\&.
\fBmaapi_get_stream_progress()\fR
returns the number of bytes that ConfD has read from the stream socket\&. If
\fIid\fR
does not identify a stream socket that is currently being read by ConfD, the function returns CONFD_ERR with
\fIconfd_errno\fR
set to CONFD_ERR_NOEXISTS\&. This can be due to e\&.g\&. that the socket has been closed, or that an error has occurred \- but also that ConfD has determined that all the data has been read (e\&.g\&. the end of an XML document has been read)\&. To avoid the latter case, the function should only be called when we have more data to write, and before the writing of that data\&. The following code shows a possible way to use this function\&.
.sp
.if n \{\
.RS 4
.\}
.nf
#define MAX_IN_FLIGHT 4096

char buf[BUFSIZ];
int sock, streamsock, id;
int n, n_written = 0, n_read = 0;
int result;
\&.\&.\&.

while (!do_abort() && (n = get_data(buf, sizeof(buf))) > 0) {
    while (n_written \- n_read > MAX_IN_FLIGHT) {
        if ((n_read = maapi_get_stream_progress(sock, id)) < 0) {
            \&.\&.\&. handle error \&.\&.\&.
        }
    }
    if (write(streamsock, buf, n) != n) {
        \&.\&.\&. handle error \&.\&.\&.
    }
    n_written += n;
}
close(streamsock);
result = maapi_load_config_stream_result(sock, id);
.fi
.if n \{\
.RE
.\}
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
A call to
\fBmaapi_get_stream_progress()\fR
does not return until the number of bytes read has increased from the previous call (or if there is an error)\&. This means that the above code does not imply busy\-looping, but also that if the code was to call
\fBmaapi_get_stream_progress()\fR
when
\fIn_read\fR
==
\fIn_written\fR, the result would be a deadlock\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ maapi_xpath_eval('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *expr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ (*result)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ (*trace)(char\ *),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_xpath_eval("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", int\ (*" "result" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", void\ *" "state" "), void\ (*" "trace" ")(char\ *), void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_xpath_eval(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", int\ (*" "result" ")(confd_hkeypath_t\ *" "kp" ", confd_value_t\ *" "v" ", void\ *" "state" "), void\ (*" "trace" ")(char\ *), void\ *" "initstate" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.PP
This function evaluates the XPath Path expression as supplied in
\fIexpr\fR\&. For each node in the resulting node set the function
\fIresult\fR
is called with the keypath to the resulting node as the first argument, and, if the node is a leaf and has a value, the value of that node as the second argument\&. The expression will be evaluated using the root node as the context node, unless a path to an existing node is given as the last argument\&. For each invocation the
\fBresult()\fR
function should return
\fBITER_CONTINUE\fR
to tell the XPath evaluator to continue with the next resulting node\&. To stop the evaluation the
\fBresult()\fR
can return
\fBITER_STOP\fR
instead\&.
.PP
The
\fItrace\fR
is a pointer to a function that takes a single string as argument\&. If supplied it will be invoked when the xpath implementation has trace output for the current expression\&. (For an easy start, for example the
\fBputs(3)\fR
will print the trace output to stdout)\&. If no trace is wanted
\fBNULL\fR
can be given\&.
.PP
The
\fIinitstate\fR
parameter can be used for any user supplied opaque data (i\&.e\&. whatever is supplied as
\fIinitstate\fR
is passed as
\fIstate\fR
to the
\fBresult()\fR
function for each invocation)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_XPATH
.nr wf \w'int\ maapi_xpath_eval_expr('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *expr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **res,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ (*trace)(char\ *),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_xpath_eval_expr("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", char\ **" "res" ", void\ (*" "trace" ")(char\ *), const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_xpath_eval_expr(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", char\ **" "res" ", void\ (*" "trace" ")(char\ *), const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.PP
Evaluate the XPath expression given in
\fIexpr\fR
and return the result as a string, pointed to by
\fIres\fR\&. If the call succeeds,
\fIres\fR
will point to a malloc:ed string that the caller needs to free\&. If the call fails
\fIres\fR
will be set to
\fBNULL\fR\&.
.PP
It is possible to supply a path which will be treated as the initial context node when evaluating
\fIexpr\fR
(i\&.e\&. if the path is relative, this is treated as the starting point, and this is also the node that
\fBcurrent()\fR
will return when used in the XPath expression)\&. If NULL is given, the current maapi position is used\&.
.PP
The
\fItrace\fR
is a pointer to a function that takes a single string as argument\&. If supplied it will be invoked when the xpath implementation has trace output for the current expression\&. (For an easy start, for example the
\fBputs(3)\fR
will print the trace output to stdout)\&. If no trace is wanted
\fBNULL\fR
can be given\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_XPATH
.nr wf \w'int\ maapi_query_start('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *expr,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *context_node,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ chunk_size,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ initial_offset,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_query_result_type\ result_as,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nselect,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *select[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nsort,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *sort[]);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_start("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", const\ char\ *" "context_node" ", int\ " "chunk_size" ", int\ " "initial_offset" ", enum\ confd_query_result_type\ " "result_as" ", int\ " "nselect" ", const\ char\ *" "select[]" ", int\ " "nsort" ", const\ char\ *" "sort[]" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_start(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "expr" ", const\ char\ *" "context_node" ", int\ " "chunk_size" ", int\ " "initial_offset" ", enum\ confd_query_result_type\ " "result_as" ", int\ " "nselect" ", const\ char\ *" "select[]" ", int\ " "nsort" ", const\ char\ *" "sort[]" ");" \}
.PP
Start a new query attached to the transaction given in
\fIth\fR\&. If successful a query handle is returned (the query handle is then used in subsequent calls to
\fBmaapi_query_result()\fR
etc)\&. Brief summary of all parameters:
.PP
\fIsock\fR
.RS 4
A previously opened maapi socket\&.
.RE
.PP
\fIth\fR
.RS 4
A transaction handle to a previously started transaction\&.
.RE
.PP
\fIexpr\fR
.RS 4
The primary XPath expression\&.
.RE
.PP
\fIcontext_node\fR
.RS 4
The context node (an ikeypath) for the primary expression\&.
NULL
is legal, and means that the context node will be
/\&.
.RE
.PP
\fIchunk_size\fR
.RS 4
How many results to return at a time\&. If set to 0 a default number will be used\&.
.RE
.PP
\fIinitial_offset\fR
.RS 4
Which result in line to begin with (1 means to start from the begining)\&.
.RE
.PP
\fIresult_as\fR
.RS 4
The format the results will be returned in\&.
.RE
.PP
\fInselect\fR
.RS 4
The number of expressions in the
\fIselect\fR
parameter\&.
.RE
.PP
\fIselect\fR
.RS 4
An array of XPath "select" expressions, of length
\fInselect\fR\&.
.RE
.PP
\fInsort\fR
.RS 4
The number of expressions in the
\fIsort\fR
parameter\&.
.RE
.PP
\fIsort\fR
.RS 4
An array of XPath expressions which will be used for sorting, of length
\fInselect\fR\&.
.RE
.PP
A query is a way of evaluating an XPath expression and returning the results in chunks\&. The usage pattern is as follows: a primary expression in provided in the
\fIexpr\fR
argument, which must evaluate to a node\-set, the "results"\&. For each node in the results node\-set every "select" expression is evaluated with the result node as its context node\&. For example, given the YANG snippet:
.sp
.if n \{\
.RS 4
.\}
.nf
  list interface {
    key name;
    unique number;
    leaf name {
      type string;
    }
    leaf number {
      type uint32;
      mandatory true;
    }
    leaf enabled {
      type boolean;
      default true;
    }
  \&.\&.\&.
  }
.fi
.if n \{\
.RE
.\}
.PP
and given that we want to find the name and number of all enabled interfaces \- the
\fIexpr\fR
could be
"/interface[enabled=\*(Aqtrue\*(Aq]", and the select expressions would be
{ "name", "number" }\&. Note that the select expressions can have any valid XPath expression, so if you wanted to find out an interfaces name, and whether its number is even or not, the expressions would be:
{ "name", "(number mod 2) == 0" }\&.
.PP
The results are then fetched using the
\fBmaapi_query_result()\fR
function, which returns the results on the format specified by the
\fIresult_as\fR
parameter\&. There are four different types of result, as defined by the type
\fBenum confd_query_result_type\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
enum confd_query_result_type {
    CONFD_QUERY_STRING = 0,
    CONFD_QUERY_HKEYPATH = 1,
    CONFD_QUERY_HKEYPATH_VALUE = 2,
    CONFD_QUERY_TAG_VALUE = 3
};
.fi
.if n \{\
.RE
.\}
.PP
I\&.e\&. the results can be returned as strings, hkeypaths, hkeypaths and values, or tags and values\&. The string is just the resulting string of evaluating the select XPath expression\&. For hkeypaths, tags, and values it is the path/tag/value of the
\fInode that the select XPath expression evaluates to\fR\&. This means that care must be taken so that the combination of select expression and return types actually yield sensible results (for example "1 + 2" is a valid select XPath expression, and would result in the string "3" when setting the result type to
\fBCONFD_QUERY_STRING\fR
\- but it is not a node, and thus have no hkeypath, tag, or value)\&. A complete example:
.sp
.if n \{\
.RS 4
.\}
.nf
  qh = maapi_query_start(s, th, "/interface[enabled=\*(Aqtrue\*(Aq]", NULL,
                         1000, 1, CONFD_QUERY_TAG_VALUE,
                         2, (char *[]){ "name", "number" }, 0, NULL);
  n = 0;
  do {
    maapi_query_result(s, qh, &qr);
    n = qr\->nresults;
    for (i=0; i<n; i++) {
      printf("result %d:\en", i + qr\->offset);
      for (j=0; j<qr\->nelements; j++) {
        // We know the type is tag\-value
        char *tag = confd_hash2str(qr\->results[i]\&.tv[j]\&.tag\&.tag);
        confd_pp_value(tmpbuf, BUFSIZ, &qr\->results[i]\&.tv[j]\&.v);
        printf("  %s: %s\en", tag, tmpbuf);
      }
    }
    maapi_query_free_result(qr);
  } while (n > 0);
  maapi_query_stop(s, qh);
     
.fi
.if n \{\
.RE
.\}
.PP
It is possible to sort the results using the built\-in XPath function
\fBsort\-by()\fR
(see the
\m[blue]\fBtailf_yang_extensions(5)\fR\m[]
man page)
.PP
It is also possible to sort the result using any expressions passed in the
\fIsort\fR
array\&. These array will be used to construct a temporary index which will live as long as the query is active\&. For example to start a query sorting first on the enabled leaf, and then on number one would call:
.sp
.if n \{\
.RS 4
.\}
.nf
qh = maapi_query_start(s, th, "/interface[enabled=\*(Aqtrue\*(Aq]", NULL,
                       1000, 1, CONFD_QUERY_TAG_VALUE,
                       3, (char *[]){ "name", "number", "enabled" },
                       2, (char *[]){ "enabled", "number" });
\&.\&.\&.
     
.fi
.if n \{\
.RE
.\}
.PP
Note that the index the query constructs is kept in memory, which will be released when the query is stopped\&.
.nr wf \w'int\ maapi_query_result('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_query_result\ **qrs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_result("
.br
.BI "int\ " "sock" ", int\ " "qh" ", struct\ confd_query_result\ **" "qrs" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_result(int\ " "sock" ", int\ " "qh" ", struct\ confd_query_result\ **" "qrs" ");" \}
.PP
Fetch the next available chunk of results associated with query handle
\fIqh\fR\&. The results are returned in a
\fBstruct confd_query_result\fR, which is allocated by the library\&. The structure is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct confd_query_result {
    enum confd_query_result_type type;
    int offset;
    int nresults;
    int nelements;
    union {
        char **str;
        confd_hkeypath_t *hkp;
        struct {
            confd_hkeypath_t hkp;
            confd_value_t    val;
        } *kv;
        confd_tag_value_t *tv;
    } *results;
    void *__internal;           /* confd_lib internal housekeeping */
};
.fi
.if n \{\
.RE
.\}
.PP
The
\fItype\fR
will always be the same as was requested in the call to
\fBmaapi_query_start()\fR, it is there to indicate which of the pointers in the union to use\&. The
\fIoffset\fR
is the number of the first result in this chunk (i\&.e\&. for the first chunk it will be 1)\&. How many results that are in this chunk is indicated in
\fInresults\fR, when there are no more available results it will be set to 0\&. Each result consists of
\fInelements\fR
elements (this number is the same as the number of select parameters given in the call to
\fBmaapi_query_start()\fR\&.
.PP
All data pointed to in the result struct (as well as the struct itself) is allocated by the library \- and when finished processing the result the user must call
\fBmaapi_query_free_result()\fR
to free this data\&.
.nr wf \w'int\ maapi_query_free_result('
.nr wm 0
.nr wp \w'struct\ confd_query_result\ *qrs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_free_result("
.br
.BI "struct\ confd_query_result\ *" "qrs" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_free_result(struct\ confd_query_result\ *" "qrs" ");" \}
.PP
The
\fBstruct confd_query_result\fR
returned by
\fBmaapi_query_result()\fR
is dynamically allocated (and it also contains pointers to other dynamically allocated data) and so it needs to be freed when the result has been processed\&. Use this function to free the
\fBstruct confd_query_result\fR
(and its accompanying data) returned by
\fBmaapi_query_result()\fR\&.
.nr wf \w'int\ maapi_query_reset('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_reset("
.br
.BI "int\ " "sock" ", int\ " "qh" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_reset(int\ " "sock" ", int\ " "qh" ");" \}
.PP
Reset / rewind a running query so that it starts from the beginning again\&. Next call to
\fBmaapi_query_result()\fR
will then return the first chunk of results\&. The function can be called at any time (i\&.e\&. both after all results have been returned to essentially run the same query again, as well as after fetching just one or a couple of results)\&.
.nr wf \w'int\ maapi_query_reset_to('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ offset);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_reset_to("
.br
.BI "int\ " "sock" ", int\ " "qh" ", int\ " "offset" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_reset_to(int\ " "sock" ", int\ " "qh" ", int\ " "offset" ");" \}
.PP
Like
\fBmaapi_query_reset()\fR, except after the query has been reset it is restarted with the initial offset set to
\fIoffset\fR\&. Next call to
\fBmaapi_query_result()\fR
will then return the first chunk of results at that offset\&. The function can be called at any time (i\&.e\&. both after all results have been returned to essentially run the same query again, as well as after fetching just one or a couple of results)\&.
.nr wf \w'int\ maapi_query_stop('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ qh);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_query_stop("
.br
.BI "int\ " "sock" ", int\ " "qh" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_query_stop(int\ " "sock" ", int\ " "qh" ");" \}
.PP
Stops the running query identified by
\fIqh\fR, and makes ConfD free up any internal resources associated with the query\&. If a query isn\*(Aqt explicitly closed using this call it will be cleaned up when the transaction the query is linked to ends\&.
.nr wf \w'int\ maapi_install_crypto_keys('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_install_crypto_keys("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_install_crypto_keys(int\ " "sock" ");" \}
.PP
It is possible to define DES3 and AES keys inside confd\&.conf\&. These keys are used by ConfD to encrypt data which is entered into the system which has either of the two builtin types
\fBtailf:des3\-cbc\-encrypted\-string\fR
or
\fBtailf:aes\-cfb\-128\-encrypted\-string\fR\&. See
\m[blue]\fBconfd_types(3)\fR\m[]\&.
.PP
This function will copy those keys from ConfD (which reads confd\&.conf) into memory in the library\&. To decrypt data of these types, use the function
\fBconfd_decrypt()\fR, see
\m[blue]\fBconfd_lib_lib(3)\fR\m[]\&.
.nr wf \w'int\ maapi_do_display('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ thandle,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmtpath,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_do_display("
.br
.BI "int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_do_display(int\ " "sock" ", int\ " "thandle" ", const\ char\ *" "fmtpath" ", \&.\&.\&.);" \}
.PP
If the data model uses the YANG
when
or
tailf:display\-when
statement, this function can be used to determine if the item given by
\fIfmtpath, \&.\&.\&.\fR
should be displayed or not\&.
.nr wf \w'int\ maapi_init_upgrade('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeoutsecs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_init_upgrade("
.br
.BI "int\ " "sock" ", int\ " "timeoutsecs" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_init_upgrade(int\ " "sock" ", int\ " "timeoutsecs" ", int\ " "flags" ");" \}
.PP
This is the first of three functions that must be called in sequence to perform an in\-service data model upgrade, i\&.e\&. replace fxs files etc without restarting the ConfD daemon\&. See the
\m[blue]\fBIn\-service Data Model Upgrade chapter in the User Guide\fR\m[]
for a detailed description of this procedure\&.
.PP
This function initializes the upgrade procedure\&. The
\fItimeoutsecs\fR
parameter specifies a maximum time to wait for users to voluntarily exit from "configure mode" sessions in CLI and Web UI\&. If transactions are still active when the timeout expires, the function will by default fail with CONFD_ERR_TIMEOUT\&. If the flag MAAPI_UPGRADE_KILL_ON_TIMEOUT was given via the
\fIflags\fR
parameter, such transactions will instead be forcibly terminated, allowing the initialization to complete successfully\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_LOCKED, CONFD_ERR_BADSTATE, CONFD_ERR_HA_WITH_UPGRADE, CONFD_ERR_TIMEOUT, CONFD_ERR_ABORTED
.nr wf \w'int\ maapi_perform_upgrade('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ **loadpathdirs,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_perform_upgrade("
.br
.BI "int\ " "sock" ", const\ char\ **" "loadpathdirs" ", int\ " "n" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_perform_upgrade(int\ " "sock" ", const\ char\ **" "loadpathdirs" ", int\ " "n" ");" \}
.PP
When
\fBmaapi_init_upgrade()\fR
has completed successfully, this function must be called to instruct ConfD to load the new data model files\&. The
\fIloadpathdirs\fR
parameter is an array of
\fIn\fR
strings that specify the directories to load from, corresponding to the
/confdConfig/loadPath/dir
elements in
confd\&.conf
(see
\m[blue]\fBconfd\&.conf(5)\fR\m[])\&.
.PP
These directories will also be searched for CDB "init files" (see the
\m[blue]\fBCDB chapter in the User Guide\fR\m[])\&. I\&.e\&. if the upgrade needs such files, we can place them in one of the new load path directories \- or we can include directories that are used
\fIonly\fR
for CDB "init files" in the
\fIloadpathdirs\fR
array, corresponding to the
/confdConfig/cdb/initPath/dir
elements that can be specified in
confd\&.conf\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADSTATE, CONFD_ERR_BAD_CONFIG
.nr wf \w'int\ maapi_commit_upgrade('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_commit_upgrade("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_commit_upgrade(int\ " "sock" ");" \}
.PP
When also
\fBmaapi_perform_upgrade()\fR
has completed successfully, this function must be called to make the upgrade permanent\&. This includes committing the CDB upgrade transaction when CDB is used, and we can thus get all the different validation errors that can otherwise result from
\fBmaapi_apply_trans()\fR\&.
.PP
When
\fBmaapi_commit_upgrade()\fR
has completed successfully, the program driving the upgrade must also make sure that the
/confdConfig/loadPath/dir
elements in
confd\&.conf
reference the new directories\&. If CDB "init files" are used in the upgrade as described for
\fBmaapi_commit_upgrade()\fR
above, the program should also make sure that the
/confdConfig/cdb/initPath/dir
elements reference the directories where those files are located\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADSTATE, CONFD_ERR_NOTSET, CONFD_ERR_NON_UNIQUE, CONFD_ERR_BAD_KEYREF, CONFD_ERR_TOO_FEW_ELEMS, CONFD_ERR_TOO_MANY_ELEMS, CONFD_ERR_UNSET_CHOICE, CONFD_ERR_MUST_FAILED, CONFD_ERR_MISSING_INSTANCE, CONFD_ERR_INVALID_INSTANCE, CONFD_ERR_BADTYPE, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_abort_upgrade('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_abort_upgrade("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_abort_upgrade(int\ " "sock" ");" \}
.PP
Calling this function at any point before the call of
\fBmaapi_commit_upgrade()\fR
will abort the upgrade\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
\fBmaapi_abort_upgrade()\fR
should
\fInot\fR
be called if any of the three previous functions fail \- in that case, ConfD will do an internal abort of the upgrade\&.
.sp .5v
.RE
.SH "CONFD DAEMON CONTROL"
.nr wf \w'int\ maapi_aaa_reload('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_aaa_reload("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_aaa_reload(int\ " "sock" ", int\ " "synchronous" ");" \}
.PP
When the ConfD AAA tree is populated by an external data provider (see the
\m[blue]\fBAAA chapter in the User Guide\fR\m[]), this function can be used by the data provider to notify ConfD when there is a change to the AAA data\&. I\&.e\&. it is an alternative to executing the command
\fBconfd \-\-clear\-aaa\-cache\fR\&.
.PP
If the
\fIsynchronous\fR
parameter is 0, the function will only initiate the loading of the AAA data, just like
\fBconfd \-\-clear\-aaa\-cache\fR
does, and return CONFD_OK as long as the communication with ConfD succeeded\&. Otherwise it will wait for the loading to complete, and return CONFD_OK only if the loading was successful\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_aaa_reload_path('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_aaa_reload_path("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_aaa_reload_path(int\ " "sock" ", int\ " "synchronous" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
A variant of
\fBmaapi_aaa_reload()\fR
that causes only the AAA subtree given by the path in
\fIfmt\fR
to be loaded\&. This may be useful to load changes to the AAA data when loading the complete AAA tree from an external data provider takes a long time\&. Obviously care must be taken to make sure that all changes actually get loaded, and a complete load using e\&.g\&.
\fBmaapi_aaa_reload()\fR
should be done at least when ConfD is started\&. The path may specify a container or list entry, but not a specific leaf\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_snmpa_reload('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_snmpa_reload("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_snmpa_reload(int\ " "sock" ", int\ " "synchronous" ");" \}
.PP
When the ConfD SNMP Agent config is implemented by an external data provider (see the
\m[blue]\fBSNMP Agent chapter in the User Guide\fR\m[]), this function must be used by the data provider to notify ConfD when there is a change to the data\&.
.PP
If the
\fIsynchronous\fR
parameter is 0, the function will only initiate the loading of the data, and return CONFD_OK as long as the communication with ConfD succeeded\&. Otherwise it will wait for the loading to complete, and return CONFD_OK only if the loading was successful\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_EXTERNAL
.nr wf \w'int\ maapi_start_phase('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ phase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_start_phase("
.br
.BI "int\ " "sock" ", int\ " "phase" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_start_phase(int\ " "sock" ", int\ " "phase" ", int\ " "synchronous" ");" \}
.PP
Once the ConfD daemon has been started in phase0 it is possible to use this function to tell the daemon to proceed to startphase 1 or 2 (as indicated in the
\fIphase\fR
parameter)\&. If
\fIsynchronous\fR
is non\-zero the call does not return until the daemon has completed the transition to the requested start phase\&.
.PP
Note that start\-phase1 can fail, (see documentation of
\fB\-\-start\-phase1\fR
in
\m[blue]\fBconfd(1)\fR\m[]) in particular if CDB fails\&. In that case
\fBmaapi_start_phase()\fR
will return CONFD_ERR, with confderrno set to CONFD_ERR_START_FAILED\&. However if ConfD stops before it has a chance to send back the error CONFD_EOF might be returned\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_START_FAILED
.nr wf \w'int\ maapi_wait_start('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ phase);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_wait_start("
.br
.BI "int\ " "sock" ", int\ " "phase" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_wait_start(int\ " "sock" ", int\ " "phase" ");" \}
.PP
To synchronize startup with ConfD this function can be used to wait for ConfD to reach a particular start phase (0, 1, or 2)\&. Note that to implement an equivalent of
\m[blue]\fB\fBconfd \-\-wait\-started\fR\fR\m[]
or
\m[blue]\fB\fBconfd \-\-wait\-phase0\fR\fR\m[]
case must also be taken to retry
\fBmaapi_connect()\fR, which will fail until ConfD has started enough to accept connections to its IPC port\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_PROTOUSAGE
.nr wf \w'int\ maapi_stop('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ synchronous);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_stop("
.br
.BI "int\ " "sock" ", int\ " "synchronous" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_stop(int\ " "sock" ", int\ " "synchronous" ");" \}
.PP
Request the ConfD daemon to stop, if
\fIsynchronous\fR
is non\-zero the call will wait until ConfD has come to a complete halt\&. Note that since the daemon exits, the socket won\*(Aqt be re\-usable after this call\&. Equivalent to
\m[blue]\fB\fBconfd \-\-stop\fR\fR\m[]\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_reload_config('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_reload_config("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_reload_config(int\ " "sock" ");" \}
.PP
Request that the ConfD daemon reloads its configuration files\&. The daemon will also close and re\-open its log files\&. Equivalent to
\m[blue]\fB\fBconfd \-\-reload\fR\fR\m[]\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_reopen_logs('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_reopen_logs("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_reopen_logs(int\ " "sock" ");" \}
.PP
Request that the ConfD daemon closes and re\-opens its log files, useful for logrotate(8)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ maapi_rebind_listener('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ listener);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_rebind_listener("
.br
.BI "int\ " "sock" ", int\ " "listener" ");" \}
.el \{\
.HP \n(wfu
.BI "int maapi_rebind_listener(int\ " "sock" ", int\ " "listener" ");" \}
.PP
Request that the subsystem(s) specified by
\fIlistener\fR
rebinds its listener socket(s)\&. Currently open sockets (if any) will be closed, and new sockets created and bound via
\fBbind(2)\fR
and
\fBlisten(2)\fR\&. This is useful e\&.g\&. if
/confdConfig/ignoreBindErrors/enabled
is set to "true" in
confd\&.conf, and some bindings have failed due to a problem that subsequently has been fixed\&. Calling this function then avoids the disable/enable config change that would otherwise be required to cause a rebind\&.
.PP
The following values can be used for the
\fIlistener\fR
parameter, ORed together if more than one:
.sp
.if n \{\
.RS 4
.\}
.nf
#define CONFD_LISTENER_IPC     (1 << 0)
#define CONFD_LISTENER_NETCONF (1 << 1)
#define CONFD_LISTENER_SNMP    (1 << 2)
#define CONFD_LISTENER_CLI     (1 << 3)
#define CONFD_LISTENER_WEBUI   (1 << 4)
.fi
.if n \{\
.RE
.\}
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
It is not possible to rebind sockets for northbound listeners during the transition from start phase 1 to start phase 2\&. If this is attempted, the call will fail (and do nothing) with
\fIconfd_errno\fR
set to CONFD_ERR_BADSTATE\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADSTATE
.nr wf \w'int\ maapi_clear_opcache('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int maapi_clear_opcache("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int maapi_clear_opcache(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Request clearing of the operational data cache (see the
\m[blue]\fBOperational Data\fR\m[]
chapter in the User Guide)\&. A path can be given via the
\fIfmt\fR
and subsequent parameters, to clear only the cached data for the subtree designated by that path\&. To clear the whole cache, pass NULL or "/" for
\fIfmt\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.SH "SEE ALSO"
.PP
\fBconfd_lib\fR(3)
\- Confd lib
.PP
\fBconfd_types\fR(3)
\- ConfD C data types
.PP
The ConfD User Guide
.SH "AUTHOR"
.PP
 <\&support@tail\-f\&.com\&>
.RS 4
.RE
.SH "COPYRIGHT"
.br
Copyright \(co 2018 Tail-f Systems AB
.br
