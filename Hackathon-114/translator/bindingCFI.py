# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_event_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_event(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/event. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents an event (i.e., a security event), for
which a security rule is made.
  """
  __slots__ = ('_path_helper', '_extmethods', '__system_event','__system_alarm',)

  _yang_name = 'event'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__system_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    self.__system_alarm = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'event']

  def _get_system_event(self):
    """
    Getter method for system_event, mapped from YANG variable /i2nsf_cfi_policy/rules/event/system_event (identityref)

    YANG Description: The security policy rule according to
system events.
    """
    return self.__system_event
      
  def _set_system_event(self, v, load=False):
    """
    Setter method for system_event, mapped from YANG variable /i2nsf_cfi_policy/rules/event/system_event (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_event() directly.

    YANG Description: The security policy rule according to
system events.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_event must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__system_event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_event(self):
    self.__system_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:access-violation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:configuration-change': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)


  def _get_system_alarm(self):
    """
    Getter method for system_alarm, mapped from YANG variable /i2nsf_cfi_policy/rules/event/system_alarm (identityref)

    YANG Description: The security policy rule according to
system alarms.
    """
    return self.__system_alarm
      
  def _set_system_alarm(self, v, load=False):
    """
    Setter method for system_alarm, mapped from YANG variable /i2nsf_cfi_policy/rules/event/system_alarm (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_alarm() directly.

    YANG Description: The security policy rule according to
system alarms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_alarm must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__system_alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_alarm(self):
    self.__system_alarm = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:memory-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:cpu-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:disk-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:hardware-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:interface-alarm': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  system_event = __builtin__.property(_get_system_event, _set_system_event)
  system_alarm = __builtin__.property(_get_system_alarm, _set_system_alarm)


  _pyangbind_elements = OrderedDict([('system_event', system_event), ('system_alarm', system_alarm), ])


class yc_range_port_number_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_range_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/firewall/range-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A range match for transport-layer port number. Note
that the start port number value must be lower than
the end port  number value
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_port_number','__end_port_number',)

  _yang_name = 'range-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_port_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)
    self.__end_port_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'firewall', 'range-port-number']

  def _get_start_port_number(self):
    """
    Getter method for start_port_number, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/range_port_number/start_port_number (inet:port-number)

    YANG Description: A start port number for range match.
    """
    return self.__start_port_number
      
  def _set_start_port_number(self, v, load=False):
    """
    Setter method for start_port_number, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/range_port_number/start_port_number (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_port_number() directly.

    YANG Description: A start port number for range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_port_number must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_port_number(self):
    self.__start_port_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)


  def _get_end_port_number(self):
    """
    Getter method for end_port_number, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/range_port_number/end_port_number (inet:port-number)

    YANG Description: An end port number for range match.
    """
    return self.__end_port_number
      
  def _set_end_port_number(self, v, load=False):
    """
    Setter method for end_port_number, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/range_port_number/end_port_number (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_port_number() directly.

    YANG Description: An end port number for range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_port_number must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_port_number(self):
    self.__end_port_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:port-number', is_config=True)

  start_port_number = __builtin__.property(_get_start_port_number, _set_start_port_number)
  end_port_number = __builtin__.property(_get_end_port_number, _set_end_port_number)


  _pyangbind_elements = OrderedDict([('start_port_number', start_port_number), ('end_port_number', end_port_number), ])


class yc_icmp_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_icmp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/firewall/icmp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents the ICMPv4 and ICMPv6 packet header
information to determine if the set of policy
actions in this ECA policy rule should be executed
or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__message',)

  _yang_name = 'icmp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__message = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="message", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'firewall', 'icmp']

  def _get_message(self):
    """
    Getter method for message, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/icmp/message (identityref)

    YANG Description: The security policy rule according to
ICMP message. The type is representing the
ICMP message corresponds to the ICMP type and
code.
    """
    return self.__message
      
  def _set_message(self, v, load=False):
    """
    Setter method for message, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/icmp/message (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_message is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_message() directly.

    YANG Description: The security policy rule according to
ICMP message. The type is representing the
ICMP message corresponds to the ICMP type and
code.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="message", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """message must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="message", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__message = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_message(self):
    self.__message = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:destination-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:port-unreachable': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:redirect': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:echo': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-advertisement': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:router-solicitation': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:time-exceeded': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:parameter-problem': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:experimental-mobility-protocols': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-request': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:request-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:extended-echo-reply': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:reply-no-error': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:malformed-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-interface': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:no-such-table-entry': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:multiple-interfaces-satisfy-query': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="message", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  message = __builtin__.property(_get_message, _set_message)


  _pyangbind_elements = OrderedDict([('message', message), ])


class yc_firewall_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/firewall. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A general firewall condition based on the packet
header.
  """
  __slots__ = ('_path_helper', '_extmethods', '__source','__destination','__transport_layer_protocol','__range_port_number','__icmp',)

  _yang_name = 'firewall'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source = YANGDynClass(unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)
    self.__destination = YANGDynClass(unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)
    self.__transport_layer_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), is_leaf=True, yang_name="transport-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    self.__range_port_number = YANGDynClass(base=yc_range_port_number_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_range_port_number, is_container='container', yang_name="range-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__icmp = YANGDynClass(base=yc_icmp_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_icmp, is_container='container', yang_name="icmp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'firewall']

  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/source (union)

    YANG Description: This describes the path of the source.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/source (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: This describes the path of the source.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with union""",
          'defined-type': "ietf-i2nsf-cfi-policy:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)


  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/destination (union)

    YANG Description: This describes the path to the destinations.
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/destination (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: This describes the path to the destinations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with union""",
          'defined-type': "ietf-i2nsf-cfi-policy:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(unique=True, base=TypedListType(allowed_type=[six.text_type,six.text_type,]), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='union', is_config=True)


  def _get_transport_layer_protocol(self):
    """
    Getter method for transport_layer_protocol, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/transport_layer_protocol (identityref)

    YANG Description: The transport-layer protocol to be matched.
    """
    return self.__transport_layer_protocol
      
  def _set_transport_layer_protocol(self, v, load=False):
    """
    Setter method for transport_layer_protocol, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/transport_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport_layer_protocol() directly.

    YANG Description: The transport-layer protocol to be matched.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), is_leaf=True, yang_name="transport-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport_layer_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), is_leaf=True, yang_name="transport-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__transport_layer_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport_layer_protocol(self):
    self.__transport_layer_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tcp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:udp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:sctp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:dccp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), is_leaf=True, yang_name="transport-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)


  def _get_range_port_number(self):
    """
    Getter method for range_port_number, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/range_port_number (container)

    YANG Description: A range match for transport-layer port number. Note
that the start port number value must be lower than
the end port  number value
    """
    return self.__range_port_number
      
  def _set_range_port_number(self, v, load=False):
    """
    Setter method for range_port_number, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/range_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range_port_number() directly.

    YANG Description: A range match for transport-layer port number. Note
that the start port number value must be lower than
the end port  number value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_range_port_number_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_range_port_number, is_container='container', yang_name="range-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """range_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_range_port_number_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_range_port_number, is_container='container', yang_name="range-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__range_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_range_port_number(self):
    self.__range_port_number = YANGDynClass(base=yc_range_port_number_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_range_port_number, is_container='container', yang_name="range-port-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_icmp(self):
    """
    Getter method for icmp, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/icmp (container)

    YANG Description: Represents the ICMPv4 and ICMPv6 packet header
information to determine if the set of policy
actions in this ECA policy rule should be executed
or not.
    """
    return self.__icmp
      
  def _set_icmp(self, v, load=False):
    """
    Setter method for icmp, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall/icmp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_icmp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_icmp() directly.

    YANG Description: Represents the ICMPv4 and ICMPv6 packet header
information to determine if the set of policy
actions in this ECA policy rule should be executed
or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_icmp_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_icmp, is_container='container', yang_name="icmp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """icmp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_icmp_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_icmp, is_container='container', yang_name="icmp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__icmp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_icmp(self):
    self.__icmp = YANGDynClass(base=yc_icmp_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall_icmp, is_container='container', yang_name="icmp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  source = __builtin__.property(_get_source, _set_source)
  destination = __builtin__.property(_get_destination, _set_destination)
  transport_layer_protocol = __builtin__.property(_get_transport_layer_protocol, _set_transport_layer_protocol)
  range_port_number = __builtin__.property(_get_range_port_number, _set_range_port_number)
  icmp = __builtin__.property(_get_icmp, _set_icmp)


  _pyangbind_elements = OrderedDict([('source', source), ('destination', destination), ('transport_layer_protocol', transport_layer_protocol), ('range_port_number', range_port_number), ('icmp', icmp), ])


class yc_rate_limit_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos_rate_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/ddos/rate-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This describes the rate-limit.
  """
  __slots__ = ('_path_helper', '_extmethods', '__packet_rate_threshold','__byte_rate_threshold','__flow_rate_threshold',)

  _yang_name = 'rate-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__packet_rate_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)
    self.__byte_rate_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)
    self.__flow_rate_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="flow-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'ddos', 'rate-limit']

  def _get_packet_rate_threshold(self):
    """
    Getter method for packet_rate_threshold, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit/packet_rate_threshold (uint64)

    YANG Description: This is a trigger value for a rate limit of packet
rate for a DDoS-attack mitigation.
    """
    return self.__packet_rate_threshold
      
  def _set_packet_rate_threshold(self, v, load=False):
    """
    Setter method for packet_rate_threshold, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit/packet_rate_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_rate_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_rate_threshold() directly.

    YANG Description: This is a trigger value for a rate limit of packet
rate for a DDoS-attack mitigation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_rate_threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)""",
        })

    self.__packet_rate_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_rate_threshold(self):
    self.__packet_rate_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)


  def _get_byte_rate_threshold(self):
    """
    Getter method for byte_rate_threshold, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit/byte_rate_threshold (uint64)

    YANG Description: This is a trigger value for a rate limit of byte
rate for a DDoS-attack mitigation.
    """
    return self.__byte_rate_threshold
      
  def _set_byte_rate_threshold(self, v, load=False):
    """
    Setter method for byte_rate_threshold, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit/byte_rate_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_byte_rate_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_byte_rate_threshold() directly.

    YANG Description: This is a trigger value for a rate limit of byte
rate for a DDoS-attack mitigation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """byte_rate_threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)""",
        })

    self.__byte_rate_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_byte_rate_threshold(self):
    self.__byte_rate_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="byte-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)


  def _get_flow_rate_threshold(self):
    """
    Getter method for flow_rate_threshold, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit/flow_rate_threshold (uint64)

    YANG Description: This is a trigger value for a rate limit of flow
rate for a DDoS-attack mitigation.
    """
    return self.__flow_rate_threshold
      
  def _set_flow_rate_threshold(self, v, load=False):
    """
    Setter method for flow_rate_threshold, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit/flow_rate_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_rate_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_rate_threshold() directly.

    YANG Description: This is a trigger value for a rate limit of flow
rate for a DDoS-attack mitigation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="flow-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_rate_threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="flow-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)""",
        })

    self.__flow_rate_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_rate_threshold(self):
    self.__flow_rate_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="flow-rate-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint64', is_config=True)

  packet_rate_threshold = __builtin__.property(_get_packet_rate_threshold, _set_packet_rate_threshold)
  byte_rate_threshold = __builtin__.property(_get_byte_rate_threshold, _set_byte_rate_threshold)
  flow_rate_threshold = __builtin__.property(_get_flow_rate_threshold, _set_flow_rate_threshold)


  _pyangbind_elements = OrderedDict([('packet_rate_threshold', packet_rate_threshold), ('byte_rate_threshold', byte_rate_threshold), ('flow_rate_threshold', flow_rate_threshold), ])


class yc_ddos_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/ddos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A condition for a DDoS attack.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rate_limit',)

  _yang_name = 'ddos'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rate_limit = YANGDynClass(base=yc_rate_limit_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos_rate_limit, is_container='container', yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'ddos']

  def _get_rate_limit(self):
    """
    Getter method for rate_limit, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit (container)

    YANG Description: This describes the rate-limit.
    """
    return self.__rate_limit
      
  def _set_rate_limit(self, v, load=False):
    """
    Setter method for rate_limit, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos/rate_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_limit() directly.

    YANG Description: This describes the rate-limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rate_limit_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos_rate_limit, is_container='container', yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rate_limit_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos_rate_limit, is_container='container', yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__rate_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_limit(self):
    self.__rate_limit = YANGDynClass(base=yc_rate_limit_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos_rate_limit, is_container='container', yang_name="rate-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  rate_limit = __builtin__.property(_get_rate_limit, _set_rate_limit)


  _pyangbind_elements = OrderedDict([('rate_limit', rate_limit), ])


class yc_anti_virus_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_anti_virus(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/anti-virus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A condition for anti-virus
  """
  __slots__ = ('_path_helper', '_extmethods', '__exception_files',)

  _yang_name = 'anti-virus'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__exception_files = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'anti-virus']

  def _get_exception_files(self):
    """
    Getter method for exception_files, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/anti_virus/exception_files (string)

    YANG Description: The type or name of the files to be excluded by the
antivirus. This can be used to keep the known
harmless files.
If the value starts with a regular expression (e.g.,
'*.exe'), the antivirus should interpret it as a
file pattern/type to be excluded.
If the value does not start with a dot (e.g.,
'example.exe'), the antivirus should interpret it as
a file name/path to be excluded.
    """
    return self.__exception_files
      
  def _set_exception_files(self, v, load=False):
    """
    Setter method for exception_files, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/anti_virus/exception_files (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exception_files is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exception_files() directly.

    YANG Description: The type or name of the files to be excluded by the
antivirus. This can be used to keep the known
harmless files.
If the value starts with a regular expression (e.g.,
'*.exe'), the antivirus should interpret it as a
file pattern/type to be excluded.
If the value does not start with a dot (e.g.,
'example.exe'), the antivirus should interpret it as
a file name/path to be excluded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exception_files must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__exception_files = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exception_files(self):
    self.__exception_files = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

  exception_files = __builtin__.property(_get_exception_files, _set_exception_files)


  _pyangbind_elements = OrderedDict([('exception_files', exception_files), ])


class yc_payload_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_payload(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/payload. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A condition based on a packet's content.
  """
  __slots__ = ('_path_helper', '_extmethods', '__content',)

  _yang_name = 'payload'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__content = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'payload']

  def _get_content(self):
    """
    Getter method for content, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/payload/content (leafref)

    YANG Description: This describes the paths to a packet content's
    """
    return self.__content
      
  def _set_content(self, v, load=False):
    """
    Setter method for content, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/payload/content (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_content is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_content() directly.

    YANG Description: This describes the paths to a packet content's
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """content must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)""",
        })

    self.__content = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_content(self):
    self.__content = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

  content = __builtin__.property(_get_content, _set_content)


  _pyangbind_elements = OrderedDict([('content', content), ])


class yc_url_category_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_url_category(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/url-category. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for url category
  """
  __slots__ = ('_path_helper', '_extmethods', '__url_name',)

  _yang_name = 'url-category'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__url_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'url-category']

  def _get_url_name(self):
    """
    Getter method for url_name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/url_category/url_name (leafref)

    YANG Description: This is description for the condition of a URL's
category such as SNS sites, game sites, ecommerce
sites, company sites, and university sites.
    """
    return self.__url_name
      
  def _set_url_name(self, v, load=False):
    """
    Setter method for url_name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/url_category/url_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url_name() directly.

    YANG Description: This is description for the condition of a URL's
category such as SNS sites, game sites, ecommerce
sites, company sites, and university sites.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="url-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)""",
        })

    self.__url_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url_name(self):
    self.__url_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

  url_name = __builtin__.property(_get_url_name, _set_url_name)


  _pyangbind_elements = OrderedDict([('url_name', url_name), ])


class yc_voice_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_voice(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/voice. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: For the VoIP/VoCN security system, a VoIP/
VoCN security system can monitor each
VoIP/VoCN flow and manage VoIP/VoCN
security rules controlled by a centralized
server for VoIP/VoCN security service
(called VoIP IPS). The VoIP/VoCN security
system controls each switch for the
VoIP/VoCN call flow management by
manipulating the rules that can be added,
deleted, or modified dynamically.
Note that VoIP is Voice over Internet Protocol
and VoCN is Voice over Cellular Network such as
Voice over LTE or 5G
  """
  __slots__ = ('_path_helper', '_extmethods', '__source_id','__destination_id','__user_agent',)

  _yang_name = 'voice'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__destination_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__user_agent = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'voice']

  def _get_source_id(self):
    """
    Getter method for source_id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice/source_id (string)

    YANG Description: The security policy rule according to
a source voice ID for VoIP and VoCN.
    """
    return self.__source_id
      
  def _set_source_id(self, v, load=False):
    """
    Setter method for source_id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice/source_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_id() directly.

    YANG Description: The security policy rule according to
a source voice ID for VoIP and VoCN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__source_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_id(self):
    self.__source_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_destination_id(self):
    """
    Getter method for destination_id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice/destination_id (string)

    YANG Description: The security policy rule according to
a destination voice ID for VoIP and VoCN.
    """
    return self.__destination_id
      
  def _set_destination_id(self, v, load=False):
    """
    Setter method for destination_id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice/destination_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_id() directly.

    YANG Description: The security policy rule according to
a destination voice ID for VoIP and VoCN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__destination_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_id(self):
    self.__destination_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_user_agent(self):
    """
    Getter method for user_agent, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice/user_agent (string)

    YANG Description: The security policy rule according to
an user agent for VoIP and VoCN.
    """
    return self.__user_agent
      
  def _set_user_agent(self, v, load=False):
    """
    Setter method for user_agent, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice/user_agent (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_agent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_agent() directly.

    YANG Description: The security policy rule according to
an user agent for VoIP and VoCN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_agent must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__user_agent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_agent(self):
    self.__user_agent = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

  source_id = __builtin__.property(_get_source_id, _set_source_id)
  destination_id = __builtin__.property(_get_destination_id, _set_destination_id)
  user_agent = __builtin__.property(_get_user_agent, _set_user_agent)


  _pyangbind_elements = OrderedDict([('source_id', source_id), ('destination_id', destination_id), ('user_agent', user_agent), ])


class yc_period_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time_period(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/time/period. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents the repetition time.  In the case
where the frequency is weekly, the days can be
set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_time','__end_time','__day','__date','__month',)

  _yang_name = 'period'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)
    self.__end_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)
    self.__day = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='day', is_config=True)
    self.__date = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='int8', is_config=True)
    self.__month = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'time', 'period']

  def _get_start_time(self):
    """
    Getter method for start_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/start_time (time)

    YANG Description: This is a period's start time for an event.
    """
    return self.__start_time
      
  def _set_start_time(self, v, load=False):
    """
    Setter method for start_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/start_time (time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_time() directly.

    YANG Description: This is a period's start time for an event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_time must be of a type compatible with time""",
          'defined-type': "ietf-i2nsf-cfi-policy:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)""",
        })

    self.__start_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_time(self):
    self.__start_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)


  def _get_end_time(self):
    """
    Getter method for end_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/end_time (time)

    YANG Description: This is a period's end time for an event.
    """
    return self.__end_time
      
  def _set_end_time(self, v, load=False):
    """
    Setter method for end_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/end_time (time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_time() directly.

    YANG Description: This is a period's end time for an event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_time must be of a type compatible with time""",
          'defined-type': "ietf-i2nsf-cfi-policy:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)""",
        })

    self.__end_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_time(self):
    self.__end_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='time', is_config=True)


  def _get_day(self):
    """
    Getter method for day, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/day (day)

    YANG Description: This represents the repeated day of every week
(e.g., Monday and Tuesday).  More than one day can
be specified.
    """
    return self.__day
      
  def _set_day(self, v, load=False):
    """
    Setter method for day, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/day (day)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_day is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_day() directly.

    YANG Description: This represents the repeated day of every week
(e.g., Monday and Tuesday).  More than one day can
be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='day', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """day must be of a type compatible with day""",
          'defined-type': "ietf-i2nsf-cfi-policy:day",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='day', is_config=True)""",
        })

    self.__day = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_day(self):
    self.__day = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='day', is_config=True)


  def _get_date(self):
    """
    Getter method for date, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/date (int8)

    YANG Description: This represents the repeated date of every month.
More than one date can be specified.
    """
    return self.__date
      
  def _set_date(self, v, load=False):
    """
    Setter method for date, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/date (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_date is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_date() directly.

    YANG Description: This represents the repeated date of every month.
More than one date can be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """date must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='int8', is_config=True)""",
        })

    self.__date = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_date(self):
    self.__date = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='int8', is_config=True)


  def _get_month(self):
    """
    Getter method for month, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/month (string)

    YANG Description: This represents the repeated date and month of
every year.  More than one can be specified.
A pattern used here is Month and Date (MM-DD).
    """
    return self.__month
      
  def _set_month(self, v, load=False):
    """
    Setter method for month, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period/month (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_month is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_month() directly.

    YANG Description: This represents the repeated date and month of
every year.  More than one can be specified.
A pattern used here is Month and Date (MM-DD).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """month must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__month = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_month(self):
    self.__month = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

  start_time = __builtin__.property(_get_start_time, _set_start_time)
  end_time = __builtin__.property(_get_end_time, _set_end_time)
  day = __builtin__.property(_get_day, _set_day)
  date = __builtin__.property(_get_date, _set_date)
  month = __builtin__.property(_get_month, _set_month)


  _pyangbind_elements = OrderedDict([('start_time', start_time), ('end_time', end_time), ('day', day), ('date', date), ('month', month), ])


class yc_time_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/time. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The time when a security policy rule should be
applied.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_date_time','__end_date_time','__period','__frequency',)

  _yang_name = 'time'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)
    self.__end_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)
    self.__period = YANGDynClass(base=yc_period_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'time']

  def _get_start_date_time(self):
    """
    Getter method for start_date_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/start_date_time (yang:date-and-time)

    YANG Description: This is the start date and time for a security
policy rule.
    """
    return self.__start_date_time
      
  def _set_start_date_time(self, v, load=False):
    """
    Setter method for start_date_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/start_date_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_date_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_date_time() directly.

    YANG Description: This is the start date and time for a security
policy rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_date_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__start_date_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_date_time(self):
    self.__start_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)


  def _get_end_date_time(self):
    """
    Getter method for end_date_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/end_date_time (yang:date-and-time)

    YANG Description: This is the end date and time for a security policy
rule.  The policy rule will stop working after the
specified end date and time.
    """
    return self.__end_date_time
      
  def _set_end_date_time(self, v, load=False):
    """
    Setter method for end_date_time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/end_date_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_date_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_date_time() directly.

    YANG Description: This is the end date and time for a security policy
rule.  The policy rule will stop working after the
specified end date and time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_date_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__end_date_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_date_time(self):
    self.__end_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:date-and-time', is_config=True)


  def _get_period(self):
    """
    Getter method for period, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period (container)

    YANG Description: This represents the repetition time.  In the case
where the frequency is weekly, the days can be
set.
    """
    return self.__period
      
  def _set_period(self, v, load=False):
    """
    Setter method for period, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/period (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_period() directly.

    YANG Description: This represents the repetition time.  In the case
where the frequency is weekly, the days can be
set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_period_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """period must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_period_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_period(self):
    self.__period = YANGDynClass(base=yc_period_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/frequency (enumeration)

    YANG Description: This represents how frequently the rule should be
enforced.
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time/frequency (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: This represents how frequently the rule should be
enforced.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with enumeration""",
          'defined-type': "ietf-i2nsf-cfi-policy:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='enumeration', is_config=True)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='enumeration', is_config=True)

  start_date_time = __builtin__.property(_get_start_date_time, _set_start_date_time)
  end_date_time = __builtin__.property(_get_end_date_time, _set_end_date_time)
  period = __builtin__.property(_get_period, _set_period)
  frequency = __builtin__.property(_get_frequency, _set_frequency)


  _pyangbind_elements = OrderedDict([('start_date_time', start_date_time), ('end_date_time', end_date_time), ('period', period), ('frequency', frequency), ])


class yc_application_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_application(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/application. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for application
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol',)

  _yang_name = 'application'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'application']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/application/protocol (identityref)

    YANG Description: The condition based on the application layer
protocol
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/application/protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The condition based on the application layer
protocol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)


  _pyangbind_elements = OrderedDict([('protocol', protocol), ])


class yc_device_type_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_device_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/device-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for type of the destination device
  """
  __slots__ = ('_path_helper', '_extmethods', '__device',)

  _yang_name = 'device-type'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'device-type']

  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/device_type/device (identityref)

    YANG Description: The device attribute that can identify a device,
including the device type (i.e., router, switch,
pc, ios, or android) and the device's owner as
well.
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/device_type/device (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.

    YANG Description: The device attribute that can identify a device,
including the device type (i.e., router, switch,
pc, ios, or android) and the device's owner as
well.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:computer': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:mobile-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:tablet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:iot-device': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ot': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:vehicle': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('device', device), ])


class yc_user_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_user(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/users/user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The user with which the traffic flow is associated
can be identified by either a user ID or username.
The user-to-IP address mapping is assumed to be
provided by the unified user management system via
network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name',)

  _yang_name = 'user'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'users', 'user']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/user/id (uint32)

    YANG Description: The ID of the user.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/user/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The ID of the user.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/user/name (string)

    YANG Description: The name of the user.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/user/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the user.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ])


class yc_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/users/group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The user group with which the traffic flow is
associated can be identified by either a group ID
or group name. The group-to-IP address and
user-to-group mappings are assumed to be provided by
the unified user management system via network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name',)

  _yang_name = 'group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'users', 'group']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/group/id (uint32)

    YANG Description: The ID of the group.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/group/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The ID of the group.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/group/name (string)

    YANG Description: The name of the group.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ])


class yc_users_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/users. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for users
  """
  __slots__ = ('_path_helper', '_extmethods', '__user','__group',)

  _yang_name = 'users'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user = YANGDynClass(base=YANGListType("id",yc_user_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__group = YANGDynClass(base=YANGListType("id",yc_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'users']

  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/user (list)

    YANG Description: The user with which the traffic flow is associated
can be identified by either a user ID or username.
The user-to-IP address mapping is assumed to be
provided by the unified user management system via
network.
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/user (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: The user with which the traffic flow is associated
can be identified by either a user ID or username.
The user-to-IP address mapping is assumed to be
provided by the unified user management system via
network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_user_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_user_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=YANGListType("id",yc_user_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/group (list)

    YANG Description: The user group with which the traffic flow is
associated can be identified by either a group ID
or group name. The group-to-IP address and
user-to-group mappings are assumed to be provided by
the unified user management system via network.
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users/group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.

    YANG Description: The user group with which the traffic flow is
associated can be identified by either a group ID
or group name. The group-to-IP address and
user-to-group mappings are assumed to be provided by
the unified user management system via network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=YANGListType("id",yc_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)

  user = __builtin__.property(_get_user, _set_user)
  group = __builtin__.property(_get_group, _set_group)


  _pyangbind_elements = OrderedDict([('user', user), ('group', group), ])


class yc_geographic_location_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_geographic_location(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context/geographic-location. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A condition for a location-based connection
  """
  __slots__ = ('_path_helper', '_extmethods', '__source','__destination',)

  _yang_name = 'geographic-location'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)
    self.__destination = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context', 'geographic-location']

  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/geographic_location/source (leafref)

    YANG Description: This describes the paths to a location's sources.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/geographic_location/source (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: This describes the paths to a location's sources.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)


  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/geographic_location/destination (leafref)

    YANG Description: This describes the paths to a location's
destinations.
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/geographic_location/destination (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: This describes the paths to a location's
destinations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

  source = __builtin__.property(_get_source, _set_source)
  destination = __builtin__.property(_get_destination, _set_destination)


  _pyangbind_elements = OrderedDict([('source', source), ('destination', destination), ])


class yc_context_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/context. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for matching the context of the packet, such
as geographic location, time, packet direction
  """
  __slots__ = ('_path_helper', '_extmethods', '__time','__application','__device_type','__users','__geographic_location',)

  _yang_name = 'context'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__time = YANGDynClass(base=yc_time_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__application = YANGDynClass(base=yc_application_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__device_type = YANGDynClass(base=yc_device_type_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__users = YANGDynClass(base=yc_users_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__geographic_location = YANGDynClass(base=yc_geographic_location_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'context']

  def _get_time(self):
    """
    Getter method for time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time (container)

    YANG Description: The time when a security policy rule should be
applied.
    """
    return self.__time
      
  def _set_time(self, v, load=False):
    """
    Setter method for time, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/time (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time() directly.

    YANG Description: The time when a security policy rule should be
applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_time_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_time_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time(self):
    self.__time = YANGDynClass(base=yc_time_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_application(self):
    """
    Getter method for application, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/application (container)

    YANG Description: Condition for application
    """
    return self.__application
      
  def _set_application(self, v, load=False):
    """
    Setter method for application, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/application (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_application is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_application() directly.

    YANG Description: Condition for application
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_application_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """application must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_application_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__application = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_application(self):
    self.__application = YANGDynClass(base=yc_application_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/device_type (container)

    YANG Description: Condition for type of the destination device
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/device_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.

    YANG Description: Condition for type of the destination device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_device_type_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_device_type_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=yc_device_type_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_users(self):
    """
    Getter method for users, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users (container)

    YANG Description: Condition for users
    """
    return self.__users
      
  def _set_users(self, v, load=False):
    """
    Setter method for users, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/users (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_users() directly.

    YANG Description: Condition for users
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_users_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """users must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_users_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_users(self):
    self.__users = YANGDynClass(base=yc_users_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_geographic_location(self):
    """
    Getter method for geographic_location, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/geographic_location (container)

    YANG Description: A condition for a location-based connection
    """
    return self.__geographic_location
      
  def _set_geographic_location(self, v, load=False):
    """
    Setter method for geographic_location, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context/geographic_location (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geographic_location is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geographic_location() directly.

    YANG Description: A condition for a location-based connection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_geographic_location_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """geographic_location must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_geographic_location_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__geographic_location = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_geographic_location(self):
    self.__geographic_location = YANGDynClass(base=yc_geographic_location_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  time = __builtin__.property(_get_time, _set_time)
  application = __builtin__.property(_get_application, _set_application)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  users = __builtin__.property(_get_users, _set_users)
  geographic_location = __builtin__.property(_get_geographic_location, _set_geographic_location)


  _pyangbind_elements = OrderedDict([('time', time), ('application', application), ('device_type', device_type), ('users', users), ('geographic_location', geographic_location), ])


class yc_threat_feed_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_threat_feed(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition/threat-feed. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A condition based on the threat-feed information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'threat-feed'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition', 'threat-feed']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/threat_feed/name (leafref)

    YANG Description: This describes the paths to a threat-feed's sources.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/threat_feed/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This describes the paths to a threat-feed's sources.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_condition_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/condition. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Conditions for general security policies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__firewall','__ddos','__anti_virus','__payload','__url_category','__voice','__context','__threat_feed',)

  _yang_name = 'condition'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__firewall = YANGDynClass(base=yc_firewall_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall, is_container='container', yang_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__ddos = YANGDynClass(base=yc_ddos_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__anti_virus = YANGDynClass(base=yc_anti_virus_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__payload = YANGDynClass(base=yc_payload_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__url_category = YANGDynClass(base=yc_url_category_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__voice = YANGDynClass(base=yc_voice_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__context = YANGDynClass(base=yc_context_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__threat_feed = YANGDynClass(base=yc_threat_feed_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_threat_feed, is_container='container', yang_name="threat-feed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'condition']

  def _get_firewall(self):
    """
    Getter method for firewall, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall (container)

    YANG Description: A general firewall condition based on the packet
header.
    """
    return self.__firewall
      
  def _set_firewall(self, v, load=False):
    """
    Setter method for firewall, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/firewall (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firewall is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firewall() directly.

    YANG Description: A general firewall condition based on the packet
header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_firewall_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall, is_container='container', yang_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firewall must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_firewall_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall, is_container='container', yang_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__firewall = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firewall(self):
    self.__firewall = YANGDynClass(base=yc_firewall_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_firewall, is_container='container', yang_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_ddos(self):
    """
    Getter method for ddos, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos (container)

    YANG Description: A condition for a DDoS attack.
    """
    return self.__ddos
      
  def _set_ddos(self, v, load=False):
    """
    Setter method for ddos, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/ddos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ddos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ddos() directly.

    YANG Description: A condition for a DDoS attack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ddos_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ddos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ddos_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__ddos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ddos(self):
    self.__ddos = YANGDynClass(base=yc_ddos_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_anti_virus(self):
    """
    Getter method for anti_virus, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/anti_virus (container)

    YANG Description: A condition for anti-virus
    """
    return self.__anti_virus
      
  def _set_anti_virus(self, v, load=False):
    """
    Setter method for anti_virus, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/anti_virus (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_anti_virus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_anti_virus() directly.

    YANG Description: A condition for anti-virus
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_anti_virus_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """anti_virus must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_anti_virus_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__anti_virus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_anti_virus(self):
    self.__anti_virus = YANGDynClass(base=yc_anti_virus_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_payload(self):
    """
    Getter method for payload, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/payload (container)

    YANG Description: A condition based on a packet's content.
    """
    return self.__payload
      
  def _set_payload(self, v, load=False):
    """
    Setter method for payload, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/payload (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_payload is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_payload() directly.

    YANG Description: A condition based on a packet's content.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_payload_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """payload must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_payload_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__payload = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_payload(self):
    self.__payload = YANGDynClass(base=yc_payload_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_url_category(self):
    """
    Getter method for url_category, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/url_category (container)

    YANG Description: Condition for url category
    """
    return self.__url_category
      
  def _set_url_category(self, v, load=False):
    """
    Setter method for url_category, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/url_category (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url_category is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url_category() directly.

    YANG Description: Condition for url category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_url_category_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url_category must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_url_category_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__url_category = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url_category(self):
    self.__url_category = YANGDynClass(base=yc_url_category_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_voice(self):
    """
    Getter method for voice, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice (container)

    YANG Description: For the VoIP/VoCN security system, a VoIP/
VoCN security system can monitor each
VoIP/VoCN flow and manage VoIP/VoCN
security rules controlled by a centralized
server for VoIP/VoCN security service
(called VoIP IPS). The VoIP/VoCN security
system controls each switch for the
VoIP/VoCN call flow management by
manipulating the rules that can be added,
deleted, or modified dynamically.
Note that VoIP is Voice over Internet Protocol
and VoCN is Voice over Cellular Network such as
Voice over LTE or 5G
    """
    return self.__voice
      
  def _set_voice(self, v, load=False):
    """
    Setter method for voice, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/voice (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_voice is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_voice() directly.

    YANG Description: For the VoIP/VoCN security system, a VoIP/
VoCN security system can monitor each
VoIP/VoCN flow and manage VoIP/VoCN
security rules controlled by a centralized
server for VoIP/VoCN security service
(called VoIP IPS). The VoIP/VoCN security
system controls each switch for the
VoIP/VoCN call flow management by
manipulating the rules that can be added,
deleted, or modified dynamically.
Note that VoIP is Voice over Internet Protocol
and VoCN is Voice over Cellular Network such as
Voice over LTE or 5G
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_voice_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """voice must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_voice_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__voice = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_voice(self):
    self.__voice = YANGDynClass(base=yc_voice_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_context(self):
    """
    Getter method for context, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context (container)

    YANG Description: Condition for matching the context of the packet, such
as geographic location, time, packet direction
    """
    return self.__context
      
  def _set_context(self, v, load=False):
    """
    Setter method for context, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/context (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_context is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_context() directly.

    YANG Description: Condition for matching the context of the packet, such
as geographic location, time, packet direction
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_context_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """context must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_context_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__context = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_context(self):
    self.__context = YANGDynClass(base=yc_context_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_threat_feed(self):
    """
    Getter method for threat_feed, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/threat_feed (container)

    YANG Description: A condition based on the threat-feed information.
    """
    return self.__threat_feed
      
  def _set_threat_feed(self, v, load=False):
    """
    Setter method for threat_feed, mapped from YANG variable /i2nsf_cfi_policy/rules/condition/threat_feed (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threat_feed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threat_feed() directly.

    YANG Description: A condition based on the threat-feed information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_threat_feed_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_threat_feed, is_container='container', yang_name="threat-feed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threat_feed must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_threat_feed_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_threat_feed, is_container='container', yang_name="threat-feed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__threat_feed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threat_feed(self):
    self.__threat_feed = YANGDynClass(base=yc_threat_feed_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition_threat_feed, is_container='container', yang_name="threat-feed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  firewall = __builtin__.property(_get_firewall, _set_firewall)
  ddos = __builtin__.property(_get_ddos, _set_ddos)
  anti_virus = __builtin__.property(_get_anti_virus, _set_anti_virus)
  payload = __builtin__.property(_get_payload, _set_payload)
  url_category = __builtin__.property(_get_url_category, _set_url_category)
  voice = __builtin__.property(_get_voice, _set_voice)
  context = __builtin__.property(_get_context, _set_context)
  threat_feed = __builtin__.property(_get_threat_feed, _set_threat_feed)


  _pyangbind_elements = OrderedDict([('firewall', firewall), ('ddos', ddos), ('anti_virus', anti_virus), ('payload', payload), ('url_category', url_category), ('voice', voice), ('context', context), ('threat_feed', threat_feed), ])


class yc_primary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_primary_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/action/primary-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents primary actions (e.g., ingress and
egress actions) to be applied to a condition.
If this is not set, it cannot support the primary
actions.
  """
  __slots__ = ('_path_helper', '_extmethods', '__action',)

  _yang_name = 'primary-action'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'action', 'primary-action']

  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/primary_action/action (identityref)

    YANG Description: Ingress actions: pass, drop, reject, rate-limit,
and mirror.
Egress actions: pass, drop, reject, rate-limit,
mirror, invoke-signaling, tunnel-encapsulation,
forwarding, and transformation..
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/primary_action/action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Ingress actions: pass, drop, reject, rate-limit,
and mirror.
Egress actions: pass, drop, reject, rate-limit,
mirror, invoke-signaling, tunnel-encapsulation,
forwarding, and transformation..
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('action', action), ])


class yc_secondary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_secondary_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/action/secondary-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents secondary actions (e.g., log and syslog)
to be applied if they are needed.  If this is not set,
it cannot support the secondary actions.
  """
  __slots__ = ('_path_helper', '_extmethods', '__log_action',)

  _yang_name = 'secondary-action'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'action', 'secondary-action']

  def _get_log_action(self):
    """
    Getter method for log_action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/secondary_action/log_action (identityref)

    YANG Description: Log action: rule log and session log
    """
    return self.__log_action
      
  def _set_log_action(self, v, load=False):
    """
    Setter method for log_action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/secondary_action/log_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_action() directly.

    YANG Description: Log action: rule log and session log
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__log_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_action(self):
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  log_action = __builtin__.property(_get_log_action, _set_log_action)


  _pyangbind_elements = OrderedDict([('log_action', log_action), ])


class yc_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules/action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This is the action container.
  """
  __slots__ = ('_path_helper', '_extmethods', '__primary_action','__secondary_action',)

  _yang_name = 'action'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__primary_action = YANGDynClass(base=yc_primary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_primary_action, is_container='container', yang_name="primary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__secondary_action = YANGDynClass(base=yc_secondary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_secondary_action, is_container='container', yang_name="secondary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules', 'action']

  def _get_primary_action(self):
    """
    Getter method for primary_action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/primary_action (container)

    YANG Description: This represents primary actions (e.g., ingress and
egress actions) to be applied to a condition.
If this is not set, it cannot support the primary
actions.
    """
    return self.__primary_action
      
  def _set_primary_action(self, v, load=False):
    """
    Setter method for primary_action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/primary_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_action() directly.

    YANG Description: This represents primary actions (e.g., ingress and
egress actions) to be applied to a condition.
If this is not set, it cannot support the primary
actions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_primary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_primary_action, is_container='container', yang_name="primary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_primary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_primary_action, is_container='container', yang_name="primary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__primary_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_action(self):
    self.__primary_action = YANGDynClass(base=yc_primary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_primary_action, is_container='container', yang_name="primary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_secondary_action(self):
    """
    Getter method for secondary_action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/secondary_action (container)

    YANG Description: This represents secondary actions (e.g., log and syslog)
to be applied if they are needed.  If this is not set,
it cannot support the secondary actions.
    """
    return self.__secondary_action
      
  def _set_secondary_action(self, v, load=False):
    """
    Setter method for secondary_action, mapped from YANG variable /i2nsf_cfi_policy/rules/action/secondary_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_action() directly.

    YANG Description: This represents secondary actions (e.g., log and syslog)
to be applied if they are needed.  If this is not set,
it cannot support the secondary actions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_secondary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_secondary_action, is_container='container', yang_name="secondary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_secondary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_secondary_action, is_container='container', yang_name="secondary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__secondary_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_action(self):
    self.__secondary_action = YANGDynClass(base=yc_secondary_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action_secondary_action, is_container='container', yang_name="secondary-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  primary_action = __builtin__.property(_get_primary_action, _set_primary_action)
  secondary_action = __builtin__.property(_get_secondary_action, _set_secondary_action)


  _pyangbind_elements = OrderedDict([('primary_action', primary_action), ('secondary_action', secondary_action), ])


class yc_rules_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/rules. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: There can be a single or multiple number of rules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__priority','__event','__condition','__action',)

  _yang_name = 'rules'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint8', is_config=True)
    self.__event = YANGDynClass(base=yc_event_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__condition = YANGDynClass(base=yc_condition_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__action = YANGDynClass(base=yc_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'rules']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/name (string)

    YANG Description: This represents the name for a rule.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/rules/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This represents the name for a rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /i2nsf_cfi_policy/rules/priority (uint8)

    YANG Description: The priority keyword comes with a mandatory
numeric value which can range from 1 through 255.
Note that a higher number means a higher priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /i2nsf_cfi_policy/rules/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: The priority keyword comes with a mandatory
numeric value which can range from 1 through 255.
Note that a higher number means a higher priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='uint8', is_config=True)


  def _get_event(self):
    """
    Getter method for event, mapped from YANG variable /i2nsf_cfi_policy/rules/event (container)

    YANG Description: This represents an event (i.e., a security event), for
which a security rule is made.
    """
    return self.__event
      
  def _set_event(self, v, load=False):
    """
    Setter method for event, mapped from YANG variable /i2nsf_cfi_policy/rules/event (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event() directly.

    YANG Description: This represents an event (i.e., a security event), for
which a security rule is made.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_event_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_event_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event(self):
    self.__event = YANGDynClass(base=yc_event_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_condition(self):
    """
    Getter method for condition, mapped from YANG variable /i2nsf_cfi_policy/rules/condition (container)

    YANG Description: Conditions for general security policies.
    """
    return self.__condition
      
  def _set_condition(self, v, load=False):
    """
    Setter method for condition, mapped from YANG variable /i2nsf_cfi_policy/rules/condition (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_condition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_condition() directly.

    YANG Description: Conditions for general security policies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_condition_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """condition must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_condition_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__condition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_condition(self):
    self.__condition = YANGDynClass(base=yc_condition_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /i2nsf_cfi_policy/rules/action (container)

    YANG Description: This is the action container.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /i2nsf_cfi_policy/rules/action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: This is the action container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=yc_action_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  priority = __builtin__.property(_get_priority, _set_priority)
  event = __builtin__.property(_get_event, _set_event)
  condition = __builtin__.property(_get_condition, _set_condition)
  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('name', name), ('priority', priority), ('event', event), ('condition', condition), ('action', action), ])


class yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv4_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/user-group/range-ipv4-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A range match for IPv4 addresses is provided.
Note that the start IPv4 address must be lower than
the end IPv4 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_ipv4_address','__end_ipv4_address',)

  _yang_name = 'range-ipv4-address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__end_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'user-group', 'range-ipv4-address']

  def _get_start_ipv4_address(self):
    """
    Getter method for start_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv4_address/start_ipv4_address (inet:ipv4-address-no-zone)

    YANG Description: A start IPv4 address for a range match.
    """
    return self.__start_ipv4_address
      
  def _set_start_ipv4_address(self, v, load=False):
    """
    Setter method for start_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv4_address/start_ipv4_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_ipv4_address() directly.

    YANG Description: A start IPv4 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_ipv4_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__start_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_ipv4_address(self):
    self.__start_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_end_ipv4_address(self):
    """
    Getter method for end_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv4_address/end_ipv4_address (inet:ipv4-address-no-zone)

    YANG Description: An end IPv4 address for a range match.
    """
    return self.__end_ipv4_address
      
  def _set_end_ipv4_address(self, v, load=False):
    """
    Setter method for end_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv4_address/end_ipv4_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_ipv4_address() directly.

    YANG Description: An end IPv4 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_ipv4_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__end_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_ipv4_address(self):
    self.__end_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)

  start_ipv4_address = __builtin__.property(_get_start_ipv4_address, _set_start_ipv4_address)
  end_ipv4_address = __builtin__.property(_get_end_ipv4_address, _set_end_ipv4_address)

  __choices__ = {'match-type': {'range-match-ipv4': ['start_ipv4_address', 'end_ipv4_address']}}
  _pyangbind_elements = OrderedDict([('start_ipv4_address', start_ipv4_address), ('end_ipv4_address', end_ipv4_address), ])


class yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv6_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/user-group/range-ipv6-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A range match for IPv6 addresses is provided.
Note that the start IPv6 address must be lower than
the end IPv6 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_ipv6_address','__end_ipv6_address',)

  _yang_name = 'range-ipv6-address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__end_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'user-group', 'range-ipv6-address']

  def _get_start_ipv6_address(self):
    """
    Getter method for start_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv6_address/start_ipv6_address (inet:ipv6-address-no-zone)

    YANG Description: A start IPv6 address for a range match.
    """
    return self.__start_ipv6_address
      
  def _set_start_ipv6_address(self, v, load=False):
    """
    Setter method for start_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv6_address/start_ipv6_address (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_ipv6_address() directly.

    YANG Description: A start IPv6 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_ipv6_address must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__start_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_ipv6_address(self):
    self.__start_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_end_ipv6_address(self):
    """
    Getter method for end_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv6_address/end_ipv6_address (inet:ipv6-address-no-zone)

    YANG Description: An end IPv6 address for a range match.
    """
    return self.__end_ipv6_address
      
  def _set_end_ipv6_address(self, v, load=False):
    """
    Setter method for end_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv6_address/end_ipv6_address (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_ipv6_address() directly.

    YANG Description: An end IPv6 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_ipv6_address must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__end_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_ipv6_address(self):
    self.__end_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)

  start_ipv6_address = __builtin__.property(_get_start_ipv6_address, _set_start_ipv6_address)
  end_ipv6_address = __builtin__.property(_get_end_ipv6_address, _set_end_ipv6_address)

  __choices__ = {'match-type': {'range-match-ipv6': ['start_ipv6_address', 'end_ipv6_address']}}
  _pyangbind_elements = OrderedDict([('start_ipv6_address', start_ipv6_address), ('end_ipv6_address', end_ipv6_address), ])


class yc_user_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/user-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents a user group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__mac_address','__range_ipv4_address','__range_ipv6_address',)

  _yang_name = 'user-group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__mac_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'})), is_leaf=False, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:mac-address', is_config=True)
    self.__range_ipv4_address = YANGDynClass(base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__range_ipv6_address = YANGDynClass(base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'user-group']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/name (string)

    YANG Description: This represents the name of a user-group.  A user-group name
is used to map a user-group's name (e.g., employees) to IP
address(es), MAC address(es).
It is dependent on implementation.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This represents the name of a user-group.  A user-group name
is used to map a user-group's name (e.g., employees) to IP
address(es), MAC address(es).
It is dependent on implementation.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/mac_address (yang:mac-address)

    YANG Description: Represent the MAC Address of a user-group. A user-group
can have multiple MAC Addresses.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/mac_address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Represent the MAC Address of a user-group. A user-group
can have multiple MAC Addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'})), is_leaf=False, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'})), is_leaf=False, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'})), is_leaf=False, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='yang:mac-address', is_config=True)


  def _get_range_ipv4_address(self):
    """
    Getter method for range_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv4_address (container)

    YANG Description: A range match for IPv4 addresses is provided.
Note that the start IPv4 address must be lower than
the end IPv4 address.
    """
    return self.__range_ipv4_address
      
  def _set_range_ipv4_address(self, v, load=False):
    """
    Setter method for range_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv4_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range_ipv4_address() directly.

    YANG Description: A range match for IPv4 addresses is provided.
Note that the start IPv4 address must be lower than
the end IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """range_ipv4_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__range_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_range_ipv4_address(self):
    self.__range_ipv4_address = YANGDynClass(base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_range_ipv6_address(self):
    """
    Getter method for range_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv6_address (container)

    YANG Description: A range match for IPv6 addresses is provided.
Note that the start IPv6 address must be lower than
the end IPv6 address.
    """
    return self.__range_ipv6_address
      
  def _set_range_ipv6_address(self, v, load=False):
    """
    Setter method for range_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group/range_ipv6_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range_ipv6_address() directly.

    YANG Description: A range match for IPv6 addresses is provided.
Note that the start IPv6 address must be lower than
the end IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """range_ipv6_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__range_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_range_ipv6_address(self):
    self.__range_ipv6_address = YANGDynClass(base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  range_ipv4_address = __builtin__.property(_get_range_ipv4_address, _set_range_ipv4_address)
  range_ipv6_address = __builtin__.property(_get_range_ipv6_address, _set_range_ipv6_address)

  __choices__ = {'match-type': {'range-match-ipv4': ['range_ipv4_address'], 'range-match-ipv6': ['range_ipv6_address']}}
  _pyangbind_elements = OrderedDict([('name', name), ('mac_address', mac_address), ('range_ipv4_address', range_ipv4_address), ('range_ipv6_address', range_ipv6_address), ])


class yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv4_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/device-group/range-ipv4-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A range match for IPv4 addresses is provided.
Note that the start IPv4 address must be lower than
the end IPv4 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_ipv4_address','__end_ipv4_address',)

  _yang_name = 'range-ipv4-address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__end_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'device-group', 'range-ipv4-address']

  def _get_start_ipv4_address(self):
    """
    Getter method for start_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv4_address/start_ipv4_address (inet:ipv4-address-no-zone)

    YANG Description: A start IPv4 address for a range match.
    """
    return self.__start_ipv4_address
      
  def _set_start_ipv4_address(self, v, load=False):
    """
    Setter method for start_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv4_address/start_ipv4_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_ipv4_address() directly.

    YANG Description: A start IPv4 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_ipv4_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__start_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_ipv4_address(self):
    self.__start_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_end_ipv4_address(self):
    """
    Getter method for end_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv4_address/end_ipv4_address (inet:ipv4-address-no-zone)

    YANG Description: An end IPv4 address for a range match.
    """
    return self.__end_ipv4_address
      
  def _set_end_ipv4_address(self, v, load=False):
    """
    Setter method for end_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv4_address/end_ipv4_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_ipv4_address() directly.

    YANG Description: An end IPv4 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_ipv4_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__end_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_ipv4_address(self):
    self.__end_ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)

  start_ipv4_address = __builtin__.property(_get_start_ipv4_address, _set_start_ipv4_address)
  end_ipv4_address = __builtin__.property(_get_end_ipv4_address, _set_end_ipv4_address)

  __choices__ = {'match-type': {'range-match-ipv4': ['start_ipv4_address', 'end_ipv4_address']}}
  _pyangbind_elements = OrderedDict([('start_ipv4_address', start_ipv4_address), ('end_ipv4_address', end_ipv4_address), ])


class yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv6_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/device-group/range-ipv6-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A range match for IPv6 addresses is provided.
Note that the start IPv6 address must be lower than
the end IPv6 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_ipv6_address','__end_ipv6_address',)

  _yang_name = 'range-ipv6-address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__end_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'device-group', 'range-ipv6-address']

  def _get_start_ipv6_address(self):
    """
    Getter method for start_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv6_address/start_ipv6_address (inet:ipv6-address-no-zone)

    YANG Description: A start IPv6 address for a range match.
    """
    return self.__start_ipv6_address
      
  def _set_start_ipv6_address(self, v, load=False):
    """
    Setter method for start_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv6_address/start_ipv6_address (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_ipv6_address() directly.

    YANG Description: A start IPv6 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_ipv6_address must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__start_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_ipv6_address(self):
    self.__start_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_end_ipv6_address(self):
    """
    Getter method for end_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv6_address/end_ipv6_address (inet:ipv6-address-no-zone)

    YANG Description: An end IPv6 address for a range match.
    """
    return self.__end_ipv6_address
      
  def _set_end_ipv6_address(self, v, load=False):
    """
    Setter method for end_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv6_address/end_ipv6_address (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_ipv6_address() directly.

    YANG Description: An end IPv6 address for a range match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_ipv6_address must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__end_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_ipv6_address(self):
    self.__end_ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)

  start_ipv6_address = __builtin__.property(_get_start_ipv6_address, _set_start_ipv6_address)
  end_ipv6_address = __builtin__.property(_get_end_ipv6_address, _set_end_ipv6_address)

  __choices__ = {'match-type': {'range-match-ipv6': ['start_ipv6_address', 'end_ipv6_address']}}
  _pyangbind_elements = OrderedDict([('start_ipv6_address', start_ipv6_address), ('end_ipv6_address', end_ipv6_address), ])


class yc_device_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/device-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents a device group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__range_ipv4_address','__range_ipv6_address','__application_protocol',)

  _yang_name = 'device-group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__range_ipv4_address = YANGDynClass(base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__range_ipv6_address = YANGDynClass(base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__application_protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="application-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'device-group']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/name (string)

    YANG Description: This represents the name of a device-group.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This represents the name of a device-group.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_range_ipv4_address(self):
    """
    Getter method for range_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv4_address (container)

    YANG Description: A range match for IPv4 addresses is provided.
Note that the start IPv4 address must be lower than
the end IPv4 address.
    """
    return self.__range_ipv4_address
      
  def _set_range_ipv4_address(self, v, load=False):
    """
    Setter method for range_ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv4_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range_ipv4_address() directly.

    YANG Description: A range match for IPv4 addresses is provided.
Note that the start IPv4 address must be lower than
the end IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """range_ipv4_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__range_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_range_ipv4_address(self):
    self.__range_ipv4_address = YANGDynClass(base=yc_range_ipv4_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv4_address, is_container='container', yang_name="range-ipv4-address", parent=self, choice=('match-type', 'range-match-ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_range_ipv6_address(self):
    """
    Getter method for range_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv6_address (container)

    YANG Description: A range match for IPv6 addresses is provided.
Note that the start IPv6 address must be lower than
the end IPv6 address.
    """
    return self.__range_ipv6_address
      
  def _set_range_ipv6_address(self, v, load=False):
    """
    Setter method for range_ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/range_ipv6_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range_ipv6_address() directly.

    YANG Description: A range match for IPv6 addresses is provided.
Note that the start IPv6 address must be lower than
the end IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """range_ipv6_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__range_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_range_ipv6_address(self):
    self.__range_ipv6_address = YANGDynClass(base=yc_range_ipv6_address_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group_range_ipv6_address, is_container='container', yang_name="range-ipv6-address", parent=self, choice=('match-type', 'range-match-ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_application_protocol(self):
    """
    Getter method for application_protocol, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/application_protocol (identityref)

    YANG Description: This represents the application layer protocols of devices.
If this is not set, it cannot support the appropriate
protocol
    """
    return self.__application_protocol
      
  def _set_application_protocol(self, v, load=False):
    """
    Setter method for application_protocol, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group/application_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_application_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_application_protocol() directly.

    YANG Description: This represents the application layer protocols of devices.
If this is not set, it cannot support the appropriate
protocol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="application-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """application_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="application-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__application_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_application_protocol(self):
    self.__application_protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:http2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:https2': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ftp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:ssh': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:telnet': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:smtp': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pop3s': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imap': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:imaps': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="application-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  range_ipv4_address = __builtin__.property(_get_range_ipv4_address, _set_range_ipv4_address)
  range_ipv6_address = __builtin__.property(_get_range_ipv6_address, _set_range_ipv6_address)
  application_protocol = __builtin__.property(_get_application_protocol, _set_application_protocol)

  __choices__ = {'match-type': {'range-match-ipv4': ['range_ipv4_address'], 'range-match-ipv6': ['range_ipv6_address']}}
  _pyangbind_elements = OrderedDict([('name', name), ('range_ipv4_address', range_ipv4_address), ('range_ipv6_address', range_ipv6_address), ('application_protocol', application_protocol), ])


class yc_geo_ip_ipv4_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/location-group/geo-ip-ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents the list of IPv4 addresses based on a
location.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv4_address','__ipv4_prefix',)

  _yang_name = 'geo-ip-ipv4'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__ipv4_prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-prefix', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'location-group', 'geo-ip-ipv4']

  def _get_ipv4_address(self):
    """
    Getter method for ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv4/ipv4_address (inet:ipv4-address-no-zone)

    YANG Description: This represents an IPv4 geo-ip address of a location.
    """
    return self.__ipv4_address
      
  def _set_ipv4_address(self, v, load=False):
    """
    Setter method for ipv4_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv4/ipv4_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_address() directly.

    YANG Description: This represents an IPv4 geo-ip address of a location.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_address(self):
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_ipv4_prefix(self):
    """
    Getter method for ipv4_prefix, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv4/ipv4_prefix (inet:ipv4-prefix)

    YANG Description: This represents the prefix for the IPv4 addresses.
    """
    return self.__ipv4_prefix
      
  def _set_ipv4_prefix(self, v, load=False):
    """
    Setter method for ipv4_prefix, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv4/ipv4_prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_prefix() directly.

    YANG Description: This represents the prefix for the IPv4 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-prefix', is_config=True)""",
        })

    self.__ipv4_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_prefix(self):
    self.__ipv4_prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="ipv4-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv4-prefix', is_config=True)

  ipv4_address = __builtin__.property(_get_ipv4_address, _set_ipv4_address)
  ipv4_prefix = __builtin__.property(_get_ipv4_prefix, _set_ipv4_prefix)


  _pyangbind_elements = OrderedDict([('ipv4_address', ipv4_address), ('ipv4_prefix', ipv4_prefix), ])


class yc_geo_ip_ipv6_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/location-group/geo-ip-ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents the list of IPv6 addresses based on a
location.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6_address','__ipv6_prefix',)

  _yang_name = 'geo-ip-ipv6'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__ipv6_prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-prefix', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'location-group', 'geo-ip-ipv6']

  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv6/ipv6_address (inet:ipv6-address-no-zone)

    YANG Description: This represents an IPv6 geo-ip address of a location.
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv6/ipv6_address (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: This represents an IPv6 geo-ip address of a location.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_ipv6_prefix(self):
    """
    Getter method for ipv6_prefix, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv6/ipv6_prefix (inet:ipv6-prefix)

    YANG Description: This represents the prefix for the IPv6 addresses.
    """
    return self.__ipv6_prefix
      
  def _set_ipv6_prefix(self, v, load=False):
    """
    Setter method for ipv6_prefix, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv6/ipv6_prefix (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_prefix() directly.

    YANG Description: This represents the prefix for the IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_prefix must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-prefix', is_config=True)""",
        })

    self.__ipv6_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_prefix(self):
    self.__ipv6_prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="ipv6-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='inet:ipv6-prefix', is_config=True)

  ipv6_address = __builtin__.property(_get_ipv6_address, _set_ipv6_address)
  ipv6_prefix = __builtin__.property(_get_ipv6_prefix, _set_ipv6_prefix)


  _pyangbind_elements = OrderedDict([('ipv6_address', ipv6_address), ('ipv6_prefix', ipv6_prefix), ])


class yc_location_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/location-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents a location group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__geo_ip_ipv4','__geo_ip_ipv6','__continent',)

  _yang_name = 'location-group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__geo_ip_ipv4 = YANGDynClass(base=YANGListType("ipv4_address",yc_geo_ip_ipv4_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv4, yang_name="geo-ip-ipv4", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address', extensions=None), is_container='list', yang_name="geo-ip-ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__geo_ip_ipv6 = YANGDynClass(base=YANGListType("ipv6_address",yc_geo_ip_ipv6_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv6, yang_name="geo-ip-ipv6", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="geo-ip-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__continent = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("asia"), is_leaf=True, yang_name="continent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'location-group']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/name (string)

    YANG Description: This represents the name of a location.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This represents the name of a location.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_geo_ip_ipv4(self):
    """
    Getter method for geo_ip_ipv4, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv4 (list)

    YANG Description: This represents the list of IPv4 addresses based on a
location.
    """
    return self.__geo_ip_ipv4
      
  def _set_geo_ip_ipv4(self, v, load=False):
    """
    Setter method for geo_ip_ipv4, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv4 (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geo_ip_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geo_ip_ipv4() directly.

    YANG Description: This represents the list of IPv4 addresses based on a
location.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv4_address",yc_geo_ip_ipv4_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv4, yang_name="geo-ip-ipv4", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address', extensions=None), is_container='list', yang_name="geo-ip-ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """geo_ip_ipv4 must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv4_address",yc_geo_ip_ipv4_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv4, yang_name="geo-ip-ipv4", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address', extensions=None), is_container='list', yang_name="geo-ip-ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__geo_ip_ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_geo_ip_ipv4(self):
    self.__geo_ip_ipv4 = YANGDynClass(base=YANGListType("ipv4_address",yc_geo_ip_ipv4_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv4, yang_name="geo-ip-ipv4", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4-address', extensions=None), is_container='list', yang_name="geo-ip-ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_geo_ip_ipv6(self):
    """
    Getter method for geo_ip_ipv6, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv6 (list)

    YANG Description: This represents the list of IPv6 addresses based on a
location.
    """
    return self.__geo_ip_ipv6
      
  def _set_geo_ip_ipv6(self, v, load=False):
    """
    Setter method for geo_ip_ipv6, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/geo_ip_ipv6 (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geo_ip_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geo_ip_ipv6() directly.

    YANG Description: This represents the list of IPv6 addresses based on a
location.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv6_address",yc_geo_ip_ipv6_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv6, yang_name="geo-ip-ipv6", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="geo-ip-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """geo_ip_ipv6 must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv6_address",yc_geo_ip_ipv6_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv6, yang_name="geo-ip-ipv6", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="geo-ip-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__geo_ip_ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_geo_ip_ipv6(self):
    self.__geo_ip_ipv6 = YANGDynClass(base=YANGListType("ipv6_address",yc_geo_ip_ipv6_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group_geo_ip_ipv6, yang_name="geo-ip-ipv6", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6-address', extensions=None), is_container='list', yang_name="geo-ip-ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_continent(self):
    """
    Getter method for continent, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/continent (identityref)

    YANG Description: location-group has geo-ip addresses of the corresponding
continent.
    """
    return self.__continent
      
  def _set_continent(self, v, load=False):
    """
    Setter method for continent, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group/continent (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_continent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_continent() directly.

    YANG Description: location-group has geo-ip addresses of the corresponding
continent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("asia"), is_leaf=True, yang_name="continent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """continent must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("asia"), is_leaf=True, yang_name="continent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__continent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_continent(self):
    self.__continent = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:africa': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:asia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:antarctica': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:europe': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:north-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:south-america': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:australia': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("asia"), is_leaf=True, yang_name="continent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  geo_ip_ipv4 = __builtin__.property(_get_geo_ip_ipv4, _set_geo_ip_ipv4)
  geo_ip_ipv6 = __builtin__.property(_get_geo_ip_ipv6, _set_geo_ip_ipv6)
  continent = __builtin__.property(_get_continent, _set_continent)


  _pyangbind_elements = OrderedDict([('name', name), ('geo_ip_ipv4', geo_ip_ipv4), ('geo_ip_ipv6', geo_ip_ipv6), ('continent', continent), ])


class yc_url_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_url_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups/url-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This describes the list of URL.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__url',)

  _yang_name = 'url-group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__url = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups', 'url-group']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/url_group/name (string)

    YANG Description: This is the name of URL group, e.g., SNS sites,
gaming sites, ecommerce sites
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/url_group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This is the name of URL group, e.g., SNS sites,
gaming sites, ecommerce sites
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_url(self):
    """
    Getter method for url, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/url_group/url (string)

    YANG Description: Specifies the URL to be added into the group.
    """
    return self.__url
      
  def _set_url(self, v, load=False):
    """
    Setter method for url, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/url_group/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.

    YANG Description: Specifies the URL to be added into the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__url = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url(self):
    self.__url = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  url = __builtin__.property(_get_url, _set_url)


  _pyangbind_elements = OrderedDict([('name', name), ('url', url), ])


class yc_endpoint_groups_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/endpoint-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A logical entity in a business environment, where a security
policy is to be applied.
  """
  __slots__ = ('_path_helper', '_extmethods', '__user_group','__device_group','__location_group','__url_group',)

  _yang_name = 'endpoint-groups'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_group = YANGDynClass(base=YANGListType("name",yc_user_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group, yang_name="user-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__device_group = YANGDynClass(base=YANGListType("name",yc_device_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group, yang_name="device-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__location_group = YANGDynClass(base=YANGListType("name",yc_location_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group, yang_name="location-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="location-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__url_group = YANGDynClass(base=YANGListType("name",yc_url_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_url_group, yang_name="url-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="url-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'endpoint-groups']

  def _get_user_group(self):
    """
    Getter method for user_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group (list)

    YANG Description: This represents a user group.
    """
    return self.__user_group
      
  def _set_user_group(self, v, load=False):
    """
    Setter method for user_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/user_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_group() directly.

    YANG Description: This represents a user group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_user_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group, yang_name="user-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_user_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group, yang_name="user-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__user_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_group(self):
    self.__user_group = YANGDynClass(base=YANGListType("name",yc_user_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_user_group, yang_name="user-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_device_group(self):
    """
    Getter method for device_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group (list)

    YANG Description: This represents a device group.
    """
    return self.__device_group
      
  def _set_device_group(self, v, load=False):
    """
    Setter method for device_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/device_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_group() directly.

    YANG Description: This represents a device group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_device_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group, yang_name="device-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_device_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group, yang_name="device-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__device_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_group(self):
    self.__device_group = YANGDynClass(base=YANGListType("name",yc_device_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_device_group, yang_name="device-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_location_group(self):
    """
    Getter method for location_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group (list)

    YANG Description: This represents a location group.
    """
    return self.__location_group
      
  def _set_location_group(self, v, load=False):
    """
    Setter method for location_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/location_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_location_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_location_group() directly.

    YANG Description: This represents a location group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_location_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group, yang_name="location-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="location-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """location_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_location_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group, yang_name="location-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="location-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__location_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_location_group(self):
    self.__location_group = YANGDynClass(base=YANGListType("name",yc_location_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_location_group, yang_name="location-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="location-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_url_group(self):
    """
    Getter method for url_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/url_group (list)

    YANG Description: This describes the list of URL.
    """
    return self.__url_group
      
  def _set_url_group(self, v, load=False):
    """
    Setter method for url_group, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups/url_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url_group() directly.

    YANG Description: This describes the list of URL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_url_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_url_group, yang_name="url-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="url-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_url_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_url_group, yang_name="url-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="url-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__url_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url_group(self):
    self.__url_group = YANGDynClass(base=YANGListType("name",yc_url_group_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups_url_group, yang_name="url-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="url-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)

  user_group = __builtin__.property(_get_user_group, _set_user_group)
  device_group = __builtin__.property(_get_device_group, _set_device_group)
  location_group = __builtin__.property(_get_location_group, _set_location_group)
  url_group = __builtin__.property(_get_url_group, _set_url_group)


  _pyangbind_elements = OrderedDict([('user_group', user_group), ('device_group', device_group), ('location_group', location_group), ('url_group', url_group), ])


class yc_threat_feed_list_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_threat_feed_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/threat-prevention/threat-feed-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: There can be a single or multiple number of
threat-feeds.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__signatures',)

  _yang_name = 'threat-feed-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__signatures = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="signatures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'threat-prevention', 'threat-feed-list']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list/name (string)

    YANG Description: This represents the name of the threat-feed.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This represents the name of the threat-feed.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list/description (string)

    YANG Description: This represents the descriptions of a threat-feed.  The
description should include information, such as type,
threat, method, and file type.  Structured Threat
Information Expression (STIX) can be used for
description of a threat [STIX].
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This represents the descriptions of a threat-feed.  The
description should include information, such as type,
threat, method, and file type.  Structured Threat
Information Expression (STIX) can be used for
description of a threat [STIX].
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_signatures(self):
    """
    Getter method for signatures, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list/signatures (identityref)

    YANG Description: This contains a list of signatures or hashes of the
threats.
    """
    return self.__signatures
      
  def _set_signatures(self, v, load=False):
    """
    Setter method for signatures, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list/signatures (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_signatures is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_signatures() directly.

    YANG Description: This contains a list of signatures or hashes of the
threats.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="signatures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """signatures must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="signatures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__signatures = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_signatures(self):
    self.__signatures = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-yara': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-snort': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:signature-suricata': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},)), is_leaf=False, yang_name="signatures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  signatures = __builtin__.property(_get_signatures, _set_signatures)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('signatures', signatures), ])


class yc_payload_content_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_payload_content(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/threat-prevention/payload-content. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents a payload-string group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__content',)

  _yang_name = 'payload-content'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__content = YANGDynClass(unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='binary', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'threat-prevention', 'payload-content']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content/name (string)

    YANG Description: This represents the name of a packet's payload-content.
It should give an idea of why a specific payload content
is marked as a threat.  For example, the name 'backdoor'
indicates the payload content is related to a backdoor
attack.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: This represents the name of a packet's payload-content.
It should give an idea of why a specific payload content
is marked as a threat.  For example, the name 'backdoor'
indicates the payload content is related to a backdoor
attack.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content/description (string)

    YANG Description: This represents the description of a payload. Desecribe
how the payload content is related to a security
attack.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This represents the description of a payload. Desecribe
how the payload content is related to a security
attack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_content(self):
    """
    Getter method for content, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content/content (binary)

    YANG Description: This represents the string of the payload contents.
This content leaf-list contains the payload of a packet
to analyze a threat. Due to the types of threats, the
type of the content is defined as a binary to
accommodate any kind of a payload type such as HTTP,
HTTPS, and SIP.
    """
    return self.__content
      
  def _set_content(self, v, load=False):
    """
    Setter method for content, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content/content (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_content is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_content() directly.

    YANG Description: This represents the string of the payload contents.
This content leaf-list contains the payload of a packet
to analyze a threat. Due to the types of threats, the
type of the content is defined as a binary to
accommodate any kind of a payload type such as HTTP,
HTTPS, and SIP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='binary', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """content must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='binary', is_config=True)""",
        })

    self.__content = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_content(self):
    self.__content = YANGDynClass(unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='binary', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  content = __builtin__.property(_get_content, _set_content)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('content', content), ])


class yc_threat_prevention_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy/threat-prevention. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The container for threat-prevention.
  """
  __slots__ = ('_path_helper', '_extmethods', '__threat_feed_list','__payload_content',)

  _yang_name = 'threat-prevention'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__threat_feed_list = YANGDynClass(base=YANGListType("name",yc_threat_feed_list_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_threat_feed_list, yang_name="threat-feed-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="threat-feed-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__payload_content = YANGDynClass(base=YANGListType("name",yc_payload_content_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_payload_content, yang_name="payload-content", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="payload-content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy', 'threat-prevention']

  def _get_threat_feed_list(self):
    """
    Getter method for threat_feed_list, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list (list)

    YANG Description: There can be a single or multiple number of
threat-feeds.
    """
    return self.__threat_feed_list
      
  def _set_threat_feed_list(self, v, load=False):
    """
    Setter method for threat_feed_list, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/threat_feed_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threat_feed_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threat_feed_list() directly.

    YANG Description: There can be a single or multiple number of
threat-feeds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_threat_feed_list_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_threat_feed_list, yang_name="threat-feed-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="threat-feed-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threat_feed_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_threat_feed_list_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_threat_feed_list, yang_name="threat-feed-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="threat-feed-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__threat_feed_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threat_feed_list(self):
    self.__threat_feed_list = YANGDynClass(base=YANGListType("name",yc_threat_feed_list_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_threat_feed_list, yang_name="threat-feed-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="threat-feed-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_payload_content(self):
    """
    Getter method for payload_content, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content (list)

    YANG Description: This represents a payload-string group.
    """
    return self.__payload_content
      
  def _set_payload_content(self, v, load=False):
    """
    Setter method for payload_content, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention/payload_content (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_payload_content is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_payload_content() directly.

    YANG Description: This represents a payload-string group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_payload_content_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_payload_content, yang_name="payload-content", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="payload-content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """payload_content must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_payload_content_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_payload_content, yang_name="payload-content", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="payload-content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__payload_content = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_payload_content(self):
    self.__payload_content = YANGDynClass(base=YANGListType("name",yc_payload_content_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention_payload_content, yang_name="payload-content", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="payload-content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)

  threat_feed_list = __builtin__.property(_get_threat_feed_list, _set_threat_feed_list)
  payload_content = __builtin__.property(_get_payload_content, _set_payload_content)


  _pyangbind_elements = OrderedDict([('threat_feed_list', threat_feed_list), ('payload_content', payload_content), ])


class yc_i2nsf_cfi_policy_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /i2nsf-cfi-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This is a security policy list.  Each policy in the list
contains a list of security policy rules, and is a policy
instance to have the information of where and when a policy
needs to be applied.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__language','__resolution_strategy','__rules','__endpoint_groups','__threat_prevention',)

  _yang_name = 'i2nsf-cfi-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__language = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WY-Za-wy-z](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    self.__resolution_strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    self.__rules = YANGDynClass(base=YANGListType("name",yc_rules_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    self.__endpoint_groups = YANGDynClass(base=yc_endpoint_groups_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups, is_container='container', yang_name="endpoint-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    self.__threat_prevention = YANGDynClass(base=yc_threat_prevention_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention, is_container='container', yang_name="threat-prevention", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-cfi-policy']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_cfi_policy/name (string)

    YANG Description: The name which identifies the policy.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_cfi_policy/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name which identifies the policy.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_language(self):
    """
    Getter method for language, mapped from YANG variable /i2nsf_cfi_policy/language (string)

    YANG Description: The value in this field indicates the language tag
used for all of the 'leaf description' described in the
'i2nsf-cfi-policy'.

The attribute is encoded following the rules in Section 2.1
in RFC 5646. The default language tag is 'en-US'
    """
    return self.__language
      
  def _set_language(self, v, load=False):
    """
    Setter method for language, mapped from YANG variable /i2nsf_cfi_policy/language (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_language is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_language() directly.

    YANG Description: The value in this field indicates the language tag
used for all of the 'leaf description' described in the
'i2nsf-cfi-policy'.

The attribute is encoded following the rules in Section 2.1
in RFC 5646. The default language tag is 'en-US'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WY-Za-wy-z](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """language must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WY-Za-wy-z](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)""",
        })

    self.__language = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_language(self):
    self.__language = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WY-Za-wy-z](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='string', is_config=True)


  def _get_resolution_strategy(self):
    """
    Getter method for resolution_strategy, mapped from YANG variable /i2nsf_cfi_policy/resolution_strategy (identityref)

    YANG Description: The resolution strategies that can be used to
specify how to resolve conflicts that occur between
actions of the same or different policy rules that
are matched and contained in this particular NSF
    """
    return self.__resolution_strategy
      
  def _set_resolution_strategy(self, v, load=False):
    """
    Setter method for resolution_strategy, mapped from YANG variable /i2nsf_cfi_policy/resolution_strategy (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resolution_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resolution_strategy() directly.

    YANG Description: The resolution strategies that can be used to
specify how to resolve conflicts that occur between
actions of the same or different policy rules that
are matched and contained in this particular NSF
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resolution_strategy must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-cfi-policy:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)""",
        })

    self.__resolution_strategy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resolution_strategy(self):
    self.__resolution_strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:fmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:lmr': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmre': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}, 'nsfcfi:pmrn': {'@module': 'ietf-i2nsf-cfi-policy', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='identityref', is_config=True)


  def _get_rules(self):
    """
    Getter method for rules, mapped from YANG variable /i2nsf_cfi_policy/rules (list)

    YANG Description: There can be a single or multiple number of rules.
    """
    return self.__rules
      
  def _set_rules(self, v, load=False):
    """
    Setter method for rules, mapped from YANG variable /i2nsf_cfi_policy/rules (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rules() directly.

    YANG Description: There can be a single or multiple number of rules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rules_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rules must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rules_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__rules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rules(self):
    self.__rules = YANGDynClass(base=YANGListType("name",yc_rules_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)


  def _get_endpoint_groups(self):
    """
    Getter method for endpoint_groups, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups (container)

    YANG Description: A logical entity in a business environment, where a security
policy is to be applied.
    """
    return self.__endpoint_groups
      
  def _set_endpoint_groups(self, v, load=False):
    """
    Setter method for endpoint_groups, mapped from YANG variable /i2nsf_cfi_policy/endpoint_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endpoint_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endpoint_groups() directly.

    YANG Description: A logical entity in a business environment, where a security
policy is to be applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endpoint_groups_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups, is_container='container', yang_name="endpoint-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endpoint_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endpoint_groups_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups, is_container='container', yang_name="endpoint-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__endpoint_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endpoint_groups(self):
    self.__endpoint_groups = YANGDynClass(base=yc_endpoint_groups_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_endpoint_groups, is_container='container', yang_name="endpoint-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)


  def _get_threat_prevention(self):
    """
    Getter method for threat_prevention, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention (container)

    YANG Description: The container for threat-prevention.
    """
    return self.__threat_prevention
      
  def _set_threat_prevention(self, v, load=False):
    """
    Setter method for threat_prevention, mapped from YANG variable /i2nsf_cfi_policy/threat_prevention (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threat_prevention is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threat_prevention() directly.

    YANG Description: The container for threat-prevention.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_threat_prevention_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention, is_container='container', yang_name="threat-prevention", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threat_prevention must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_threat_prevention_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention, is_container='container', yang_name="threat-prevention", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)""",
        })

    self.__threat_prevention = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threat_prevention(self):
    self.__threat_prevention = YANGDynClass(base=yc_threat_prevention_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy_threat_prevention, is_container='container', yang_name="threat-prevention", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  language = __builtin__.property(_get_language, _set_language)
  resolution_strategy = __builtin__.property(_get_resolution_strategy, _set_resolution_strategy)
  rules = __builtin__.property(_get_rules, _set_rules)
  endpoint_groups = __builtin__.property(_get_endpoint_groups, _set_endpoint_groups)
  threat_prevention = __builtin__.property(_get_threat_prevention, _set_threat_prevention)


  _pyangbind_elements = OrderedDict([('name', name), ('language', language), ('resolution_strategy', resolution_strategy), ('rules', rules), ('endpoint_groups', endpoint_groups), ('threat_prevention', threat_prevention), ])


class ietf_i2nsf_cfi_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-cfi-policy - based on the path /ietf-i2nsf-cfi-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is a YANG module for Consumer-Facing Interface.

Copyright (c) 2022 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__i2nsf_cfi_policy',)

  _yang_name = 'ietf-i2nsf-cfi-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__i2nsf_cfi_policy = YANGDynClass(base=YANGListType("name",
                                                             yc_i2nsf_cfi_policy_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy, 
                                                             yang_name="i2nsf-cfi-policy", 
                                                             parent=self, 
                                                             is_container='list', 
                                                             user_ordered=False, 
                                                             path_helper=self._path_helper, 
                                                             yang_keys='name', extensions=None), 
                                           is_container='list', 
                                           yang_name="i2nsf-cfi-policy", 
                                           parent=self, 
                                           path_helper=self._path_helper, 
                                           extmethods=self._extmethods, 
                                           register_paths=True, 
                                           extensions=None,
                                           namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', 
                                           defining_module='ietf-i2nsf-cfi-policy', 
                                           yang_type='list', 
                                           is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_i2nsf_cfi_policy(self):
    """
    Getter method for i2nsf_cfi_policy, mapped from YANG variable /i2nsf_cfi_policy (list)

    YANG Description: This is a security policy list.  Each policy in the list
contains a list of security policy rules, and is a policy
instance to have the information of where and when a policy
needs to be applied.
    """
    return self.__i2nsf_cfi_policy
      
  def _set_i2nsf_cfi_policy(self, v, load=False):
    """
    Setter method for i2nsf_cfi_policy, mapped from YANG variable /i2nsf_cfi_policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_i2nsf_cfi_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_i2nsf_cfi_policy() directly.

    YANG Description: This is a security policy list.  Each policy in the list
contains a list of security policy rules, and is a policy
instance to have the information of where and when a policy
needs to be applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_i2nsf_cfi_policy_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy, yang_name="i2nsf-cfi-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="i2nsf-cfi-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """i2nsf_cfi_policy must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_i2nsf_cfi_policy_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy, yang_name="i2nsf-cfi-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="i2nsf-cfi-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)""",
        })

    self.__i2nsf_cfi_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_i2nsf_cfi_policy(self):
    self.__i2nsf_cfi_policy = YANGDynClass(base=YANGListType("name",yc_i2nsf_cfi_policy_ietf_i2nsf_cfi_policy__i2nsf_cfi_policy, yang_name="i2nsf-cfi-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="i2nsf-cfi-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-cfi-policy', defining_module='ietf-i2nsf-cfi-policy', yang_type='list', is_config=True)

  i2nsf_cfi_policy = __builtin__.property(_get_i2nsf_cfi_policy, _set_i2nsf_cfi_policy)


  _pyangbind_elements = OrderedDict([('i2nsf_cfi_policy', i2nsf_cfi_policy), ])


