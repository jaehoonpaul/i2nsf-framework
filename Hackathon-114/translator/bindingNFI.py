# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_long_connection_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_long_connection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/long-connection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A container for long connection. A long connection is a
connection that is maintained after the socket connection
is established, regardless of whether it is used for data
traffic or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__duration',)

  _yang_name = 'long-connection'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'long-connection']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /i2nsf_security_policy/rules/long_connection/enable (boolean)

    YANG Description: If true, the rule is enabled and enforced.
If false, the rule is configured but disabled
and not enforced.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /i2nsf_security_policy/rules/long_connection/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: If true, the rule is enabled and enforced.
If false, the rule is configured but disabled
and not enforced.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)


  def _get_duration(self):
    """
    Getter method for duration, mapped from YANG variable /i2nsf_security_policy/rules/long_connection/duration (uint32)

    YANG Description: This is the maximum inactive connection duration of a
long connection before a connection is declared as
expired.
    """
    return self.__duration
      
  def _set_duration(self, v, load=False):
    """
    Setter method for duration, mapped from YANG variable /i2nsf_security_policy/rules/long_connection/duration (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duration() directly.

    YANG Description: This is the maximum inactive connection duration of a
long connection before a connection is declared as
expired.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duration must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__duration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duration(self):
    self.__duration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="duration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  duration = __builtin__.property(_get_duration, _set_duration)


  _pyangbind_elements = OrderedDict([('enable', enable), ('duration', duration), ])


class yc_event_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_event(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/event. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An event is defined as any important
occurrence in time of a change in the system being
managed, and/or in the environment of the system being
managed. When used in the context of policy rules for
a flow-based NSF, it is used to determine whether the
Condition clause of the Policy Rule can be evaluated
or not. Examples of an I2NSF event include time and
user actions (e.g., logon, logoff, and actions that
violate any ACL.).
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__system_event','__system_alarm',)

  _yang_name = 'event'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__system_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__system_alarm = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'event']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/event/description (string)

    YANG Description: Description for an event clause
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/event/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for an event clause
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_system_event(self):
    """
    Getter method for system_event, mapped from YANG variable /i2nsf_security_policy/rules/event/system_event (identityref)

    YANG Description: The security policy rule according to
system events.
    """
    return self.__system_event
      
  def _set_system_event(self, v, load=False):
    """
    Setter method for system_event, mapped from YANG variable /i2nsf_security_policy/rules/event/system_event (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_event() directly.

    YANG Description: The security policy rule according to
system events.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_event must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__system_event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_event(self):
    self.__system_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:access-violation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:configuration-change': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_system_alarm(self):
    """
    Getter method for system_alarm, mapped from YANG variable /i2nsf_security_policy/rules/event/system_alarm (identityref)

    YANG Description: The security policy rule according to
system alarms.
    """
    return self.__system_alarm
      
  def _set_system_alarm(self, v, load=False):
    """
    Setter method for system_alarm, mapped from YANG variable /i2nsf_security_policy/rules/event/system_alarm (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_alarm() directly.

    YANG Description: The security policy rule according to
system alarms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_alarm must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__system_alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_alarm(self):
    self.__system_alarm = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:memory-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:cpu-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:disk-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:hardware-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:interface-alarm': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="system-alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  system_event = __builtin__.property(_get_system_event, _set_system_event)
  system_alarm = __builtin__.property(_get_system_alarm, _set_system_alarm)


  _pyangbind_elements = OrderedDict([('description', description), ('system_event', system_event), ('system_alarm', system_alarm), ])


class yc_layer_2_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_layer_2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/layer-2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent layer 2
packet header information to determine the set of policy
actions in this ECA policy rule should be executed or
not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__destination_mac_address','__destination_mac_address_mask','__source_mac_address','__source_mac_address_mask','__ethertype',)

  _yang_name = 'layer-2'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__destination_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    self.__destination_mac_address_mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    self.__source_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    self.__source_mac_address_mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    self.__ethertype = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {'value': 2048}, 'arp': {'value': 2054}, 'wlan': {'value': 2114}, 'trill': {'value': 8947}, 'srp': {'value': 8938}, 'decnet': {'value': 24579}, 'rarp': {'value': 32821}, 'appletalk': {'value': 32923}, 'aarp': {'value': 33011}, 'vlan': {'value': 33024}, 'ipx': {'value': 33079}, 'qnx': {'value': 33284}, 'ipv6': {'value': 34525}, 'efc': {'value': 34824}, 'esp': {'value': 34825}, 'cobranet': {'value': 34841}, 'mpls-unicast': {'value': 34887}, 'mpls-multicast': {'value': 34888}, 'pppoe-discovery': {'value': 34915}, 'pppoe-session': {'value': 34916}, 'intel-ans': {'value': 34925}, 'jumbo-frames': {'value': 34928}, 'homeplug': {'value': 34939}, 'eap': {'value': 34958}, 'profinet': {'value': 34962}, 'hyperscsi': {'value': 34970}, 'aoe': {'value': 34978}, 'ethercat': {'value': 34980}, 'provider-bridging': {'value': 34984}, 'ethernet-powerlink': {'value': 34987}, 'goose': {'value': 35000}, 'gse': {'value': 35001}, 'sv': {'value': 35002}, 'lldp': {'value': 35020}, 'sercos': {'value': 35021}, 'wsmp': {'value': 35036}, 'homeplug-av-mme': {'value': 35041}, 'mrp': {'value': 35043}, 'macsec': {'value': 35045}, 'pbb': {'value': 35047}, 'cfm': {'value': 35074}, 'fcoe': {'value': 35078}, 'fcoe-ip': {'value': 35092}, 'roce': {'value': 35093}, 'tte': {'value': 35101}, 'hsr': {'value': 35119}},),], is_leaf=True, yang_name="ethertype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='eth:ethertype', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'layer-2']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/description (string)

    YANG Description: The ethernet condition description
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The ethernet condition description
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_destination_mac_address(self):
    """
    Getter method for destination_mac_address, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/destination_mac_address (yang:mac-address)

    YANG Description: Destination IEEE 802 Media Access Control (MAC)
address.
    """
    return self.__destination_mac_address
      
  def _set_destination_mac_address(self, v, load=False):
    """
    Setter method for destination_mac_address, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/destination_mac_address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_mac_address() directly.

    YANG Description: Destination IEEE 802 Media Access Control (MAC)
address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_mac_address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__destination_mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_mac_address(self):
    self.__destination_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)


  def _get_destination_mac_address_mask(self):
    """
    Getter method for destination_mac_address_mask, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/destination_mac_address_mask (yang:mac-address)

    YANG Description: Destination IEEE 802 MAC address mask.
    """
    return self.__destination_mac_address_mask
      
  def _set_destination_mac_address_mask(self, v, load=False):
    """
    Setter method for destination_mac_address_mask, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/destination_mac_address_mask (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_mac_address_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_mac_address_mask() directly.

    YANG Description: Destination IEEE 802 MAC address mask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_mac_address_mask must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__destination_mac_address_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_mac_address_mask(self):
    self.__destination_mac_address_mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="destination-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)


  def _get_source_mac_address(self):
    """
    Getter method for source_mac_address, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/source_mac_address (yang:mac-address)

    YANG Description: Source IEEE 802 MAC address.
    """
    return self.__source_mac_address
      
  def _set_source_mac_address(self, v, load=False):
    """
    Setter method for source_mac_address, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/source_mac_address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_mac_address() directly.

    YANG Description: Source IEEE 802 MAC address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_mac_address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__source_mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_mac_address(self):
    self.__source_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)


  def _get_source_mac_address_mask(self):
    """
    Getter method for source_mac_address_mask, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/source_mac_address_mask (yang:mac-address)

    YANG Description: Source IEEE 802 MAC address mask.
    """
    return self.__source_mac_address_mask
      
  def _set_source_mac_address_mask(self, v, load=False):
    """
    Setter method for source_mac_address_mask, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/source_mac_address_mask (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_mac_address_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_mac_address_mask() directly.

    YANG Description: Source IEEE 802 MAC address mask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_mac_address_mask must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__source_mac_address_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_mac_address_mask(self):
    self.__source_mac_address_mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="source-mac-address-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:mac-address', is_config=True)


  def _get_ethertype(self):
    """
    Getter method for ethertype, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/ethertype (eth:ethertype)

    YANG Description: The Ethernet Type (or Length) value represented
in the canonical order defined by IEEE 802.
The canonical representation uses lowercase
characters.
    """
    return self.__ethertype
      
  def _set_ethertype(self, v, load=False):
    """
    Setter method for ethertype, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2/ethertype (eth:ethertype)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethertype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethertype() directly.

    YANG Description: The Ethernet Type (or Length) value represented
in the canonical order defined by IEEE 802.
The canonical representation uses lowercase
characters.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {'value': 2048}, 'arp': {'value': 2054}, 'wlan': {'value': 2114}, 'trill': {'value': 8947}, 'srp': {'value': 8938}, 'decnet': {'value': 24579}, 'rarp': {'value': 32821}, 'appletalk': {'value': 32923}, 'aarp': {'value': 33011}, 'vlan': {'value': 33024}, 'ipx': {'value': 33079}, 'qnx': {'value': 33284}, 'ipv6': {'value': 34525}, 'efc': {'value': 34824}, 'esp': {'value': 34825}, 'cobranet': {'value': 34841}, 'mpls-unicast': {'value': 34887}, 'mpls-multicast': {'value': 34888}, 'pppoe-discovery': {'value': 34915}, 'pppoe-session': {'value': 34916}, 'intel-ans': {'value': 34925}, 'jumbo-frames': {'value': 34928}, 'homeplug': {'value': 34939}, 'eap': {'value': 34958}, 'profinet': {'value': 34962}, 'hyperscsi': {'value': 34970}, 'aoe': {'value': 34978}, 'ethercat': {'value': 34980}, 'provider-bridging': {'value': 34984}, 'ethernet-powerlink': {'value': 34987}, 'goose': {'value': 35000}, 'gse': {'value': 35001}, 'sv': {'value': 35002}, 'lldp': {'value': 35020}, 'sercos': {'value': 35021}, 'wsmp': {'value': 35036}, 'homeplug-av-mme': {'value': 35041}, 'mrp': {'value': 35043}, 'macsec': {'value': 35045}, 'pbb': {'value': 35047}, 'cfm': {'value': 35074}, 'fcoe': {'value': 35078}, 'fcoe-ip': {'value': 35092}, 'roce': {'value': 35093}, 'tte': {'value': 35101}, 'hsr': {'value': 35119}},),], is_leaf=True, yang_name="ethertype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='eth:ethertype', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethertype must be of a type compatible with eth:ethertype""",
          'defined-type': "eth:ethertype",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {'value': 2048}, 'arp': {'value': 2054}, 'wlan': {'value': 2114}, 'trill': {'value': 8947}, 'srp': {'value': 8938}, 'decnet': {'value': 24579}, 'rarp': {'value': 32821}, 'appletalk': {'value': 32923}, 'aarp': {'value': 33011}, 'vlan': {'value': 33024}, 'ipx': {'value': 33079}, 'qnx': {'value': 33284}, 'ipv6': {'value': 34525}, 'efc': {'value': 34824}, 'esp': {'value': 34825}, 'cobranet': {'value': 34841}, 'mpls-unicast': {'value': 34887}, 'mpls-multicast': {'value': 34888}, 'pppoe-discovery': {'value': 34915}, 'pppoe-session': {'value': 34916}, 'intel-ans': {'value': 34925}, 'jumbo-frames': {'value': 34928}, 'homeplug': {'value': 34939}, 'eap': {'value': 34958}, 'profinet': {'value': 34962}, 'hyperscsi': {'value': 34970}, 'aoe': {'value': 34978}, 'ethercat': {'value': 34980}, 'provider-bridging': {'value': 34984}, 'ethernet-powerlink': {'value': 34987}, 'goose': {'value': 35000}, 'gse': {'value': 35001}, 'sv': {'value': 35002}, 'lldp': {'value': 35020}, 'sercos': {'value': 35021}, 'wsmp': {'value': 35036}, 'homeplug-av-mme': {'value': 35041}, 'mrp': {'value': 35043}, 'macsec': {'value': 35045}, 'pbb': {'value': 35047}, 'cfm': {'value': 35074}, 'fcoe': {'value': 35078}, 'fcoe-ip': {'value': 35092}, 'roce': {'value': 35093}, 'tte': {'value': 35101}, 'hsr': {'value': 35119}},),], is_leaf=True, yang_name="ethertype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='eth:ethertype', is_config=True)""",
        })

    self.__ethertype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethertype(self):
    self.__ethertype = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {'value': 2048}, 'arp': {'value': 2054}, 'wlan': {'value': 2114}, 'trill': {'value': 8947}, 'srp': {'value': 8938}, 'decnet': {'value': 24579}, 'rarp': {'value': 32821}, 'appletalk': {'value': 32923}, 'aarp': {'value': 33011}, 'vlan': {'value': 33024}, 'ipx': {'value': 33079}, 'qnx': {'value': 33284}, 'ipv6': {'value': 34525}, 'efc': {'value': 34824}, 'esp': {'value': 34825}, 'cobranet': {'value': 34841}, 'mpls-unicast': {'value': 34887}, 'mpls-multicast': {'value': 34888}, 'pppoe-discovery': {'value': 34915}, 'pppoe-session': {'value': 34916}, 'intel-ans': {'value': 34925}, 'jumbo-frames': {'value': 34928}, 'homeplug': {'value': 34939}, 'eap': {'value': 34958}, 'profinet': {'value': 34962}, 'hyperscsi': {'value': 34970}, 'aoe': {'value': 34978}, 'ethercat': {'value': 34980}, 'provider-bridging': {'value': 34984}, 'ethernet-powerlink': {'value': 34987}, 'goose': {'value': 35000}, 'gse': {'value': 35001}, 'sv': {'value': 35002}, 'lldp': {'value': 35020}, 'sercos': {'value': 35021}, 'wsmp': {'value': 35036}, 'homeplug-av-mme': {'value': 35041}, 'mrp': {'value': 35043}, 'macsec': {'value': 35045}, 'pbb': {'value': 35047}, 'cfm': {'value': 35074}, 'fcoe': {'value': 35078}, 'fcoe-ip': {'value': 35092}, 'roce': {'value': 35093}, 'tte': {'value': 35101}, 'hsr': {'value': 35119}},),], is_leaf=True, yang_name="ethertype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='eth:ethertype', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  destination_mac_address = __builtin__.property(_get_destination_mac_address, _set_destination_mac_address)
  destination_mac_address_mask = __builtin__.property(_get_destination_mac_address_mask, _set_destination_mac_address_mask)
  source_mac_address = __builtin__.property(_get_source_mac_address, _set_source_mac_address)
  source_mac_address_mask = __builtin__.property(_get_source_mac_address_mask, _set_source_mac_address_mask)
  ethertype = __builtin__.property(_get_ethertype, _set_ethertype)


  _pyangbind_elements = OrderedDict([('description', description), ('destination_mac_address', destination_mac_address), ('destination_mac_address_mask', destination_mac_address_mask), ('source_mac_address', source_mac_address), ('source_mac_address_mask', source_mac_address_mask), ('ethertype', ethertype), ])


class yc_destination_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_destination_ipv4_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/ipv4/destination-ipv4-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv4 addresses specified with
a start IPv4 address and an end IPv4
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv4 address MUST be
equal to or greater than the 'start' IPv4
address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'destination-ipv4-range'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'ipv4', 'destination-ipv4-range']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_range/start (inet:ipv4-address-no-zone)

    YANG Description: A start IPv4 address for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_range/start (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start IPv4 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_range/end (inet:ipv4-address-no-zone)

    YANG Description: An end IPv4 address for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_range/end (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end IPv4 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'destination-network': {'destination-ipv4-range': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_source_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_source_ipv4_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/ipv4/source-ipv4-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv4 addresses specified with
a start IPv4 address and an end IPv4
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv4 address MUST be
equal or greater than the 'start' IPv4
address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'source-ipv4-range'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'ipv4', 'source-ipv4-range']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_range/start (inet:ipv4-address-no-zone)

    YANG Description: A start IPv4 address for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_range/start (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start IPv4 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_range/end (inet:ipv4-address-no-zone)

    YANG Description: An end IPv4 address for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_range/end (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end IPv4 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-address-no-zone', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'source-network': {'source-ipv4-range': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_ipv4_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent
IPv4 packet header information to determine if
the set of policy actions in this ECA policy rule
should be executed or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__dscp','__ecn','__length','__ttl','__protocol','__ihl','__flags','__offset','__identification','__destination_ipv4_network','__destination_ipv4_range','__source_ipv4_network','__source_ipv4_range',)

  _yang_name = 'ipv4'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)
    self.__ecn = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__ihl = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..60']}), is_leaf=True, yang_name="ihl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__flags = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__offset = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['20..65535']}), is_leaf=True, yang_name="offset", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    self.__identification = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="identification", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    self.__destination_ipv4_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="destination-ipv4-network", parent=self, choice=('destination-network', 'destination-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)
    self.__destination_ipv4_range = YANGDynClass(base=YANGListType("start end",yc_destination_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_destination_ipv4_range, yang_name="destination-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="destination-ipv4-range", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    self.__source_ipv4_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="source-ipv4-network", parent=self, choice=('source-network', 'source-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)
    self.__source_ipv4_range = YANGDynClass(base=YANGListType("start end",yc_source_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_source_ipv4_range, yang_name="source-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="source-ipv4-range", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'ipv4']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/description (string)

    YANG Description: This is description for IPv4 condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for IPv4 condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_dscp(self):
    """
    Getter method for dscp, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/dscp (inet:dscp)

    YANG Description: Differentiated Services Code Point.
    """
    return self.__dscp
      
  def _set_dscp(self, v, load=False):
    """
    Setter method for dscp, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/dscp (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dscp() directly.

    YANG Description: Differentiated Services Code Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dscp must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)""",
        })

    self.__dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dscp(self):
    self.__dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)


  def _get_ecn(self):
    """
    Getter method for ecn, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/ecn (uint8)

    YANG Description: Explicit Congestion Notification.
    """
    return self.__ecn
      
  def _set_ecn(self, v, load=False):
    """
    Setter method for ecn, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/ecn (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ecn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ecn() directly.

    YANG Description: Explicit Congestion Notification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ecn must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__ecn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ecn(self):
    self.__ecn = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_length(self):
    """
    Getter method for length, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/length (uint16)

    YANG Description: In the IPv4 header field, this field is known as the Total
Length.  Total Length is the length of the datagram, measured
in octets, including internet header and data.
In the IPv6 header field, this field is known as the Payload
Length, which is the length of the IPv6 payload, i.e., the rest
of the packet following the IPv6 header, in octets.
    """
    return self.__length
      
  def _set_length(self, v, load=False):
    """
    Setter method for length, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/length (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_length() directly.

    YANG Description: In the IPv4 header field, this field is known as the Total
Length.  Total Length is the length of the datagram, measured
in octets, including internet header and data.
In the IPv6 header field, this field is known as the Payload
Length, which is the length of the IPv6 payload, i.e., the rest
of the packet following the IPv6 header, in octets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """length must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_length(self):
    self.__length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/ttl (uint8)

    YANG Description: This field indicates the maximum time the datagram is allowed
to remain in the internet system.  If this field contains the
value zero, then the datagram must be dropped.
In IPv6, this field is known as the Hop Limit.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: This field indicates the maximum time the datagram is allowed
to remain in the internet system.  If this field contains the
value zero, then the datagram must be dropped.
In IPv6, this field is known as the Hop Limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/protocol (uint8)

    YANG Description: Internet Protocol number.  Refers to the protocol of the
payload.  In IPv6, this field is known as 'next-header',
and if extension headers are present, the protocol is
present in the 'upper-layer' header.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/protocol (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Internet Protocol number.  Refers to the protocol of the
payload.  In IPv6, this field is known as 'next-header',
and if extension headers are present, the protocol is
present in the 'upper-layer' header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_ihl(self):
    """
    Getter method for ihl, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/ihl (uint8)

    YANG Description: In an IPv4 header field, the Internet Header Length (IHL) is
the length of the internet header in 32-bit words and
thus points to the beginning of the data.  Note that the
minimum value for a correct header is 5.
    """
    return self.__ihl
      
  def _set_ihl(self, v, load=False):
    """
    Setter method for ihl, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/ihl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ihl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ihl() directly.

    YANG Description: In an IPv4 header field, the Internet Header Length (IHL) is
the length of the internet header in 32-bit words and
thus points to the beginning of the data.  Note that the
minimum value for a correct header is 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..60']}), is_leaf=True, yang_name="ihl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ihl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..60']}), is_leaf=True, yang_name="ihl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__ihl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ihl(self):
    self.__ihl = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..60']}), is_leaf=True, yang_name="ihl", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_flags(self):
    """
    Getter method for flags, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/flags (string)

    YANG Description: Bit definitions for the Flags field in the IPv4 header.
    """
    return self.__flags
      
  def _set_flags(self, v, load=False):
    """
    Setter method for flags, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/flags (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags() directly.

    YANG Description: Bit definitions for the Flags field in the IPv4 header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags(self):
    self.__flags = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_offset(self):
    """
    Getter method for offset, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/offset (uint16)

    YANG Description: The fragment offset is measured in units of 8 octets (64 bits).
The first fragment has offset zero.  The length is 13 bits
    """
    return self.__offset
      
  def _set_offset(self, v, load=False):
    """
    Setter method for offset, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/offset (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offset() directly.

    YANG Description: The fragment offset is measured in units of 8 octets (64 bits).
The first fragment has offset zero.  The length is 13 bits
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['20..65535']}), is_leaf=True, yang_name="offset", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offset must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['20..65535']}), is_leaf=True, yang_name="offset", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offset(self):
    self.__offset = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['20..65535']}), is_leaf=True, yang_name="offset", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)


  def _get_identification(self):
    """
    Getter method for identification, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/identification (uint16)

    YANG Description: An identifying value assigned by the sender to aid in
assembling the fragments of a datagram.
    """
    return self.__identification
      
  def _set_identification(self, v, load=False):
    """
    Setter method for identification, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/identification (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identification() directly.

    YANG Description: An identifying value assigned by the sender to aid in
assembling the fragments of a datagram.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="identification", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identification must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="identification", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__identification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identification(self):
    self.__identification = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="identification", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)


  def _get_destination_ipv4_network(self):
    """
    Getter method for destination_ipv4_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_network (inet:ipv4-prefix)

    YANG Description: Destination IPv4 address prefix.
    """
    return self.__destination_ipv4_network
      
  def _set_destination_ipv4_network(self, v, load=False):
    """
    Setter method for destination_ipv4_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_network (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ipv4_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ipv4_network() directly.

    YANG Description: Destination IPv4 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="destination-ipv4-network", parent=self, choice=('destination-network', 'destination-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ipv4_network must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="destination-ipv4-network", parent=self, choice=('destination-network', 'destination-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)""",
        })

    self.__destination_ipv4_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ipv4_network(self):
    self.__destination_ipv4_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="destination-ipv4-network", parent=self, choice=('destination-network', 'destination-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)


  def _get_destination_ipv4_range(self):
    """
    Getter method for destination_ipv4_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_range (list)

    YANG Description: The list of IPv4 addresses specified with
a start IPv4 address and an end IPv4
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv4 address MUST be
equal to or greater than the 'start' IPv4
address.
    """
    return self.__destination_ipv4_range
      
  def _set_destination_ipv4_range(self, v, load=False):
    """
    Setter method for destination_ipv4_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/destination_ipv4_range (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ipv4_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ipv4_range() directly.

    YANG Description: The list of IPv4 addresses specified with
a start IPv4 address and an end IPv4
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv4 address MUST be
equal to or greater than the 'start' IPv4
address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_destination_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_destination_ipv4_range, yang_name="destination-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="destination-ipv4-range", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ipv4_range must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_destination_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_destination_ipv4_range, yang_name="destination-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="destination-ipv4-range", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__destination_ipv4_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ipv4_range(self):
    self.__destination_ipv4_range = YANGDynClass(base=YANGListType("start end",yc_destination_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_destination_ipv4_range, yang_name="destination-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="destination-ipv4-range", parent=self, choice=('destination-network', 'destination-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)


  def _get_source_ipv4_network(self):
    """
    Getter method for source_ipv4_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_network (inet:ipv4-prefix)

    YANG Description: Source IPv4 address prefix.
    """
    return self.__source_ipv4_network
      
  def _set_source_ipv4_network(self, v, load=False):
    """
    Setter method for source_ipv4_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_network (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ipv4_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ipv4_network() directly.

    YANG Description: Source IPv4 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="source-ipv4-network", parent=self, choice=('source-network', 'source-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ipv4_network must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="source-ipv4-network", parent=self, choice=('source-network', 'source-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)""",
        })

    self.__source_ipv4_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ipv4_network(self):
    self.__source_ipv4_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="source-ipv4-network", parent=self, choice=('source-network', 'source-ipv4-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv4-prefix', is_config=True)


  def _get_source_ipv4_range(self):
    """
    Getter method for source_ipv4_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_range (list)

    YANG Description: The list of IPv4 addresses specified with
a start IPv4 address and an end IPv4
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv4 address MUST be
equal or greater than the 'start' IPv4
address.
    """
    return self.__source_ipv4_range
      
  def _set_source_ipv4_range(self, v, load=False):
    """
    Setter method for source_ipv4_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4/source_ipv4_range (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ipv4_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ipv4_range() directly.

    YANG Description: The list of IPv4 addresses specified with
a start IPv4 address and an end IPv4
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv4 address MUST be
equal or greater than the 'start' IPv4
address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_source_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_source_ipv4_range, yang_name="source-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="source-ipv4-range", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ipv4_range must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_source_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_source_ipv4_range, yang_name="source-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="source-ipv4-range", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__source_ipv4_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ipv4_range(self):
    self.__source_ipv4_range = YANGDynClass(base=YANGListType("start end",yc_source_ipv4_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4_source_ipv4_range, yang_name="source-ipv4-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv4')), is_container='list', yang_name="source-ipv4-range", parent=self, choice=('source-network', 'source-ipv4-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  dscp = __builtin__.property(_get_dscp, _set_dscp)
  ecn = __builtin__.property(_get_ecn, _set_ecn)
  length = __builtin__.property(_get_length, _set_length)
  ttl = __builtin__.property(_get_ttl, _set_ttl)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  ihl = __builtin__.property(_get_ihl, _set_ihl)
  flags = __builtin__.property(_get_flags, _set_flags)
  offset = __builtin__.property(_get_offset, _set_offset)
  identification = __builtin__.property(_get_identification, _set_identification)
  destination_ipv4_network = __builtin__.property(_get_destination_ipv4_network, _set_destination_ipv4_network)
  destination_ipv4_range = __builtin__.property(_get_destination_ipv4_range, _set_destination_ipv4_range)
  source_ipv4_network = __builtin__.property(_get_source_ipv4_network, _set_source_ipv4_network)
  source_ipv4_range = __builtin__.property(_get_source_ipv4_range, _set_source_ipv4_range)

  __choices__ = {'layer-3': {'ipv4': ['description', 'dscp', 'ecn', 'length', 'ttl', 'protocol', 'ihl', 'flags', 'offset', 'identification']}, 'destination-network': {'destination-ipv4-network': ['destination_ipv4_network'], 'destination-ipv4-range': ['destination_ipv4_range']}, 'source-network': {'source-ipv4-network': ['source_ipv4_network'], 'source-ipv4-range': ['source_ipv4_range']}}
  _pyangbind_elements = OrderedDict([('description', description), ('dscp', dscp), ('ecn', ecn), ('length', length), ('ttl', ttl), ('protocol', protocol), ('ihl', ihl), ('flags', flags), ('offset', offset), ('identification', identification), ('destination_ipv4_network', destination_ipv4_network), ('destination_ipv4_range', destination_ipv4_range), ('source_ipv4_network', source_ipv4_network), ('source_ipv4_range', source_ipv4_range), ])


class yc_destination_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_destination_ipv6_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/ipv6/destination-ipv6-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv6 addresses specified with
a start IPv6 address and an end IPv6
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv6 address MUST be
equal to or greater than the 'start' IPv6
address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'destination-ipv6-range'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'ipv6', 'destination-ipv6-range']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_range/start (inet:ipv6-address-no-zone)

    YANG Description: A start IPv6 address for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_range/start (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start IPv6 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_range/end (inet:ipv6-address-no-zone)

    YANG Description: An end IPv6 address for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_range/end (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end IPv6 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'destination-network': {'destination-ipv6-range': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_source_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_source_ipv6_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/ipv6/source-ipv6-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of IPv6 addresses specified with
a start IPv6 address and an end IPv6
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv6 address MUST be
equal to or greater than the 'start' IPv6
address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'source-ipv6-range'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'ipv6', 'source-ipv6-range']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_range/start (inet:ipv6-address-no-zone)

    YANG Description: A start IPv6 address for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_range/start (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start IPv6 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="start", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_range/end (inet:ipv6-address-no-zone)

    YANG Description: An end IPv6 address for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_range/end (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end IPv6 address for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="end", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-address-no-zone', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'source-network': {'source-ipv6-range': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_ipv6_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent IPv6
packet header information to determine if the set
of policy actions in this ECA policy rule should
be executed or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__dscp','__ecn','__length','__ttl','__protocol','__destination_ipv6_network','__destination_ipv6_range','__source_ipv6_network','__source_ipv6_range','__flow_label',)

  _yang_name = 'ipv6'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)
    self.__ecn = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__destination_ipv6_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="destination-ipv6-network", parent=self, choice=('destination-network', 'destination-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)
    self.__destination_ipv6_range = YANGDynClass(base=YANGListType("start end",yc_destination_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_destination_ipv6_range, yang_name="destination-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="destination-ipv6-range", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    self.__source_ipv6_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="source-ipv6-network", parent=self, choice=('source-network', 'source-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)
    self.__source_ipv6_range = YANGDynClass(base=YANGListType("start end",yc_source_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_source_ipv6_range, yang_name="source-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="source-ipv6-range", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    self.__flow_label = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), is_leaf=True, yang_name="flow-label", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-flow-label', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'ipv6']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/description (string)

    YANG Description: This is description for IPv6 condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for IPv6 condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_dscp(self):
    """
    Getter method for dscp, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/dscp (inet:dscp)

    YANG Description: Differentiated Services Code Point.
    """
    return self.__dscp
      
  def _set_dscp(self, v, load=False):
    """
    Setter method for dscp, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/dscp (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dscp() directly.

    YANG Description: Differentiated Services Code Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dscp must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)""",
        })

    self.__dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dscp(self):
    self.__dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="dscp", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:dscp', is_config=True)


  def _get_ecn(self):
    """
    Getter method for ecn, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/ecn (uint8)

    YANG Description: Explicit Congestion Notification.
    """
    return self.__ecn
      
  def _set_ecn(self, v, load=False):
    """
    Setter method for ecn, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/ecn (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ecn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ecn() directly.

    YANG Description: Explicit Congestion Notification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ecn must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__ecn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ecn(self):
    self.__ecn = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="ecn", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_length(self):
    """
    Getter method for length, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/length (uint16)

    YANG Description: In the IPv4 header field, this field is known as the Total
Length.  Total Length is the length of the datagram, measured
in octets, including internet header and data.
In the IPv6 header field, this field is known as the Payload
Length, which is the length of the IPv6 payload, i.e., the rest
of the packet following the IPv6 header, in octets.
    """
    return self.__length
      
  def _set_length(self, v, load=False):
    """
    Setter method for length, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/length (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_length() directly.

    YANG Description: In the IPv4 header field, this field is known as the Total
Length.  Total Length is the length of the datagram, measured
in octets, including internet header and data.
In the IPv6 header field, this field is known as the Payload
Length, which is the length of the IPv6 payload, i.e., the rest
of the packet following the IPv6 header, in octets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """length must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_length(self):
    self.__length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/ttl (uint8)

    YANG Description: This field indicates the maximum time the datagram is allowed
to remain in the internet system.  If this field contains the
value zero, then the datagram must be dropped.
In IPv6, this field is known as the Hop Limit.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: This field indicates the maximum time the datagram is allowed
to remain in the internet system.  If this field contains the
value zero, then the datagram must be dropped.
In IPv6, this field is known as the Hop Limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ttl", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/protocol (uint8)

    YANG Description: Internet Protocol number.  Refers to the protocol of the
payload.  In IPv6, this field is known as 'next-header',
and if extension headers are present, the protocol is
present in the 'upper-layer' header.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/protocol (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Internet Protocol number.  Refers to the protocol of the
payload.  In IPv6, this field is known as 'next-header',
and if extension headers are present, the protocol is
present in the 'upper-layer' header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="protocol", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_destination_ipv6_network(self):
    """
    Getter method for destination_ipv6_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_network (inet:ipv6-prefix)

    YANG Description: Destination IPv6 address prefix.
    """
    return self.__destination_ipv6_network
      
  def _set_destination_ipv6_network(self, v, load=False):
    """
    Setter method for destination_ipv6_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_network (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ipv6_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ipv6_network() directly.

    YANG Description: Destination IPv6 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="destination-ipv6-network", parent=self, choice=('destination-network', 'destination-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ipv6_network must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="destination-ipv6-network", parent=self, choice=('destination-network', 'destination-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)""",
        })

    self.__destination_ipv6_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ipv6_network(self):
    self.__destination_ipv6_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="destination-ipv6-network", parent=self, choice=('destination-network', 'destination-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)


  def _get_destination_ipv6_range(self):
    """
    Getter method for destination_ipv6_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_range (list)

    YANG Description: The list of IPv6 addresses specified with
a start IPv6 address and an end IPv6
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv6 address MUST be
equal to or greater than the 'start' IPv6
address.
    """
    return self.__destination_ipv6_range
      
  def _set_destination_ipv6_range(self, v, load=False):
    """
    Setter method for destination_ipv6_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/destination_ipv6_range (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ipv6_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ipv6_range() directly.

    YANG Description: The list of IPv6 addresses specified with
a start IPv6 address and an end IPv6
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv6 address MUST be
equal to or greater than the 'start' IPv6
address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_destination_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_destination_ipv6_range, yang_name="destination-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="destination-ipv6-range", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ipv6_range must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_destination_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_destination_ipv6_range, yang_name="destination-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="destination-ipv6-range", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__destination_ipv6_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ipv6_range(self):
    self.__destination_ipv6_range = YANGDynClass(base=YANGListType("start end",yc_destination_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_destination_ipv6_range, yang_name="destination-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="destination-ipv6-range", parent=self, choice=('destination-network', 'destination-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)


  def _get_source_ipv6_network(self):
    """
    Getter method for source_ipv6_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_network (inet:ipv6-prefix)

    YANG Description: Source IPv6 address prefix.
    """
    return self.__source_ipv6_network
      
  def _set_source_ipv6_network(self, v, load=False):
    """
    Setter method for source_ipv6_network, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_network (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ipv6_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ipv6_network() directly.

    YANG Description: Source IPv6 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="source-ipv6-network", parent=self, choice=('source-network', 'source-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ipv6_network must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="source-ipv6-network", parent=self, choice=('source-network', 'source-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)""",
        })

    self.__source_ipv6_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ipv6_network(self):
    self.__source_ipv6_network = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="source-ipv6-network", parent=self, choice=('source-network', 'source-ipv6-network'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-prefix', is_config=True)


  def _get_source_ipv6_range(self):
    """
    Getter method for source_ipv6_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_range (list)

    YANG Description: The list of IPv6 addresses specified with
a start IPv6 address and an end IPv6
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv6 address MUST be
equal to or greater than the 'start' IPv6
address.
    """
    return self.__source_ipv6_range
      
  def _set_source_ipv6_range(self, v, load=False):
    """
    Setter method for source_ipv6_range, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/source_ipv6_range (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ipv6_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ipv6_range() directly.

    YANG Description: The list of IPv6 addresses specified with
a start IPv6 address and an end IPv6
address. If only one value is needed, then
set both start and end to the same value.
Note that the 'end' IPv6 address MUST be
equal to or greater than the 'start' IPv6
address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_source_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_source_ipv6_range, yang_name="source-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="source-ipv6-range", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ipv6_range must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_source_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_source_ipv6_range, yang_name="source-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="source-ipv6-range", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__source_ipv6_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ipv6_range(self):
    self.__source_ipv6_range = YANGDynClass(base=YANGListType("start end",yc_source_ipv6_range_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6_source_ipv6_range, yang_name="source-ipv6-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-3', 'ipv6')), is_container='list', yang_name="source-ipv6-range", parent=self, choice=('source-network', 'source-ipv6-range'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)


  def _get_flow_label(self):
    """
    Getter method for flow_label, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/flow_label (inet:ipv6-flow-label)

    YANG Description: IPv6 Flow label.
    """
    return self.__flow_label
      
  def _set_flow_label(self, v, load=False):
    """
    Setter method for flow_label, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6/flow_label (inet:ipv6-flow-label)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_label() directly.

    YANG Description: IPv6 Flow label.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), is_leaf=True, yang_name="flow-label", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-flow-label', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_label must be of a type compatible with inet:ipv6-flow-label""",
          'defined-type': "inet:ipv6-flow-label",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), is_leaf=True, yang_name="flow-label", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-flow-label', is_config=True)""",
        })

    self.__flow_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_label(self):
    self.__flow_label = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), is_leaf=True, yang_name="flow-label", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:ipv6-flow-label', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  dscp = __builtin__.property(_get_dscp, _set_dscp)
  ecn = __builtin__.property(_get_ecn, _set_ecn)
  length = __builtin__.property(_get_length, _set_length)
  ttl = __builtin__.property(_get_ttl, _set_ttl)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  destination_ipv6_network = __builtin__.property(_get_destination_ipv6_network, _set_destination_ipv6_network)
  destination_ipv6_range = __builtin__.property(_get_destination_ipv6_range, _set_destination_ipv6_range)
  source_ipv6_network = __builtin__.property(_get_source_ipv6_network, _set_source_ipv6_network)
  source_ipv6_range = __builtin__.property(_get_source_ipv6_range, _set_source_ipv6_range)
  flow_label = __builtin__.property(_get_flow_label, _set_flow_label)

  __choices__ = {'layer-3': {'ipv6': ['description', 'dscp', 'ecn', 'length', 'ttl', 'protocol', 'flow_label']}, 'destination-network': {'destination-ipv6-network': ['destination_ipv6_network'], 'destination-ipv6-range': ['destination_ipv6_range']}, 'source-network': {'source-ipv6-network': ['source_ipv6_network'], 'source-ipv6-range': ['source_ipv6_range']}}
  _pyangbind_elements = OrderedDict([('description', description), ('dscp', dscp), ('ecn', ecn), ('length', length), ('ttl', ttl), ('protocol', protocol), ('destination_ipv6_network', destination_ipv6_network), ('destination_ipv6_range', destination_ipv6_range), ('source_ipv6_network', source_ipv6_network), ('source_ipv6_range', source_ipv6_range), ('flow_label', flow_label), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/tcp/source-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of source port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'tcp', 'source-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'source-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/tcp/source-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
tcp source port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'source-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'tcp', 'source-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number/port_numbers (list)

    YANG Description: List of source port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of source port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'source-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/tcp/destination-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of destination port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'tcp', 'destination-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'destination-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/tcp/destination-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
tcp destination port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'destination-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'tcp', 'destination-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number/port_numbers (list)

    YANG Description: List of destination port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of destination port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'tcp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'destination-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_tcp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/tcp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent
TCP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__source_port_number','__destination_port_number','__sequence_number','__acknowledgement_number','__data_offset','__reserved','__flags','__window_size','__urgent_pointer','__options',)

  _yang_name = 'tcp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__sequence_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sequence-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    self.__acknowledgement_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="acknowledgement-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    self.__data_offset = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..15']}), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__reserved = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reserved", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__flags = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__window_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="window-size", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    self.__urgent_pointer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="urgent-pointer", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    self.__options = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="options", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'tcp']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/description (string)

    YANG Description: This is description for tcp condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for tcp condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_source_port_number(self):
    """
    Getter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number (container)

    YANG Description: The security policy rule according to
tcp source port number.
    """
    return self.__source_port_number
      
  def _set_source_port_number(self, v, load=False):
    """
    Setter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/source_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port_number() directly.

    YANG Description: The security policy rule according to
tcp source port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__source_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port_number(self):
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_destination_port_number(self):
    """
    Getter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number (container)

    YANG Description: The security policy rule according to
tcp destination port number.
    """
    return self.__destination_port_number
      
  def _set_destination_port_number(self, v, load=False):
    """
    Setter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/destination_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port_number() directly.

    YANG Description: The security policy rule according to
tcp destination port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__destination_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port_number(self):
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_sequence_number(self):
    """
    Getter method for sequence_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/sequence_number (uint32)

    YANG Description: Sequence number that appears in the packet.
    """
    return self.__sequence_number
      
  def _set_sequence_number(self, v, load=False):
    """
    Setter method for sequence_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/sequence_number (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sequence_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sequence_number() directly.

    YANG Description: Sequence number that appears in the packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sequence-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sequence_number must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sequence-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__sequence_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sequence_number(self):
    self.__sequence_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sequence-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)


  def _get_acknowledgement_number(self):
    """
    Getter method for acknowledgement_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/acknowledgement_number (uint32)

    YANG Description: The acknowledgement number that appears in the
packet.
    """
    return self.__acknowledgement_number
      
  def _set_acknowledgement_number(self, v, load=False):
    """
    Setter method for acknowledgement_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/acknowledgement_number (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acknowledgement_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acknowledgement_number() directly.

    YANG Description: The acknowledgement number that appears in the
packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="acknowledgement-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acknowledgement_number must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="acknowledgement-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__acknowledgement_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acknowledgement_number(self):
    self.__acknowledgement_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="acknowledgement-number", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)


  def _get_data_offset(self):
    """
    Getter method for data_offset, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/data_offset (uint8)

    YANG Description: Specifies the size of the TCP header in 32-bit
words.  The minimum size header is 5 words and
the maximum is 15 words; thus, this gives a
minimum size of 20 bytes and a maximum of 60
bytes, allowing for up to 40 bytes of options
in the header.
    """
    return self.__data_offset
      
  def _set_data_offset(self, v, load=False):
    """
    Setter method for data_offset, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/data_offset (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_offset() directly.

    YANG Description: Specifies the size of the TCP header in 32-bit
words.  The minimum size header is 5 words and
the maximum is 15 words; thus, this gives a
minimum size of 20 bytes and a maximum of 60
bytes, allowing for up to 40 bytes of options
in the header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..15']}), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_offset must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..15']}), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__data_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_offset(self):
    self.__data_offset = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['5..15']}), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_reserved(self):
    """
    Getter method for reserved, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/reserved (uint8)

    YANG Description: Reserved for future use.
    """
    return self.__reserved
      
  def _set_reserved(self, v, load=False):
    """
    Setter method for reserved, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/reserved (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserved is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserved() directly.

    YANG Description: Reserved for future use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reserved", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserved must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reserved", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__reserved = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserved(self):
    self.__reserved = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="reserved", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_flags(self):
    """
    Getter method for flags, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/flags (string)

    YANG Description: Also known as Control Bits.  Contains nine 1-bit flags.
    """
    return self.__flags
      
  def _set_flags(self, v, load=False):
    """
    Setter method for flags, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/flags (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags() directly.

    YANG Description: Also known as Control Bits.  Contains nine 1-bit flags.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags(self):
    self.__flags = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flags", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_window_size(self):
    """
    Getter method for window_size, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/window_size (uint16)

    YANG Description: The size of the receive window, which specifies
the number of window size units beyond the segment
identified by the sequence number in the Acknowledgement
field that the sender of this segment is currently
willing to receive.
    """
    return self.__window_size
      
  def _set_window_size(self, v, load=False):
    """
    Setter method for window_size, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/window_size (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_window_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_window_size() directly.

    YANG Description: The size of the receive window, which specifies
the number of window size units beyond the segment
identified by the sequence number in the Acknowledgement
field that the sender of this segment is currently
willing to receive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="window-size", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """window_size must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="window-size", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__window_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_window_size(self):
    self.__window_size = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="window-size", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)


  def _get_urgent_pointer(self):
    """
    Getter method for urgent_pointer, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/urgent_pointer (uint16)

    YANG Description: This field is an offset from the sequence number
indicating the last urgent data byte.
    """
    return self.__urgent_pointer
      
  def _set_urgent_pointer(self, v, load=False):
    """
    Setter method for urgent_pointer, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/urgent_pointer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_urgent_pointer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_urgent_pointer() directly.

    YANG Description: This field is an offset from the sequence number
indicating the last urgent data byte.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="urgent-pointer", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """urgent_pointer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="urgent-pointer", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__urgent_pointer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_urgent_pointer(self):
    self.__urgent_pointer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="urgent-pointer", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)


  def _get_options(self):
    """
    Getter method for options, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/options (binary)

    YANG Description: The length of this field is determined by the
Data Offset field.  Options have up to three
fields: Option-Kind (1 byte), Option-Length
(1 byte), and Option-Data (variable).  The Option-Kind
field indicates the type of option and is the
only field that is not optional.  Depending on
what kind of option we are dealing with,
the next two fields may be set: the Option-Length
field indicates the total length of the option,
and the Option-Data field contains the value of
the option, if applicable.
    """
    return self.__options
      
  def _set_options(self, v, load=False):
    """
    Setter method for options, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp/options (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_options() directly.

    YANG Description: The length of this field is determined by the
Data Offset field.  Options have up to three
fields: Option-Kind (1 byte), Option-Length
(1 byte), and Option-Data (variable).  The Option-Kind
field indicates the type of option and is the
only field that is not optional.  Depending on
what kind of option we are dealing with,
the next two fields may be set: the Option-Length
field indicates the total length of the option,
and the Option-Data field contains the value of
the option, if applicable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="options", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """options must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="options", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)""",
        })

    self.__options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_options(self):
    self.__options = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="options", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  source_port_number = __builtin__.property(_get_source_port_number, _set_source_port_number)
  destination_port_number = __builtin__.property(_get_destination_port_number, _set_destination_port_number)
  sequence_number = __builtin__.property(_get_sequence_number, _set_sequence_number)
  acknowledgement_number = __builtin__.property(_get_acknowledgement_number, _set_acknowledgement_number)
  data_offset = __builtin__.property(_get_data_offset, _set_data_offset)
  reserved = __builtin__.property(_get_reserved, _set_reserved)
  flags = __builtin__.property(_get_flags, _set_flags)
  window_size = __builtin__.property(_get_window_size, _set_window_size)
  urgent_pointer = __builtin__.property(_get_urgent_pointer, _set_urgent_pointer)
  options = __builtin__.property(_get_options, _set_options)

  __choices__ = {'layer-4': {'tcp': ['description', 'source_port_number', 'destination_port_number', 'sequence_number', 'acknowledgement_number', 'data_offset', 'reserved', 'flags', 'window_size', 'urgent_pointer', 'options']}}
  _pyangbind_elements = OrderedDict([('description', description), ('source_port_number', source_port_number), ('destination_port_number', destination_port_number), ('sequence_number', sequence_number), ('acknowledgement_number', acknowledgement_number), ('data_offset', data_offset), ('reserved', reserved), ('flags', flags), ('window_size', window_size), ('urgent_pointer', urgent_pointer), ('options', options), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/udp/source-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of source port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'udp', 'source-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'source-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/udp/source-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
udp source port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'source-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'udp', 'source-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number/port_numbers (list)

    YANG Description: List of source port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of source port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'source-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/udp/destination-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of destination port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'udp', 'destination-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'destination-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/udp/destination-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
udp destination port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'destination-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'udp', 'destination-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number/port_numbers (list)

    YANG Description: List of destination port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of destination port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'udp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'destination-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_udp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/udp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent
UDP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__source_port_number','__destination_port_number','__length',)

  _yang_name = 'udp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'udp']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/description (string)

    YANG Description: This is description for udp condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for udp condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_source_port_number(self):
    """
    Getter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number (container)

    YANG Description: The security policy rule according to
udp source port number.
    """
    return self.__source_port_number
      
  def _set_source_port_number(self, v, load=False):
    """
    Setter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/source_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port_number() directly.

    YANG Description: The security policy rule according to
udp source port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__source_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port_number(self):
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_destination_port_number(self):
    """
    Getter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number (container)

    YANG Description: The security policy rule according to
udp destination port number.
    """
    return self.__destination_port_number
      
  def _set_destination_port_number(self, v, load=False):
    """
    Setter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/destination_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port_number() directly.

    YANG Description: The security policy rule according to
udp destination port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__destination_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port_number(self):
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_length(self):
    """
    Getter method for length, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/length (uint16)

    YANG Description: A field that specifies the length in bytes of
the UDP header and UDP data.  The minimum
length is 8 bytes because that is the length of
the header.  The field size sets a theoretical
limit of 65,535 bytes (8-byte header plus 65,527
bytes of data) for a UDP datagram.  However, the
actual limit for the data length, which is
imposed by the underlying IPv4 protocol, is
65,507 bytes (65,535 minus 8-byte UDP header
minus 20-byte IP header).
In IPv6 jumbograms, it is possible to have
UDP packets of a size greater than 65,535 bytes.
RFC 2675 specifies that the Length field is set
to zero if the length of the UDP header plus
UDP data is greater than 65,535.
    """
    return self.__length
      
  def _set_length(self, v, load=False):
    """
    Setter method for length, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp/length (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_length() directly.

    YANG Description: A field that specifies the length in bytes of
the UDP header and UDP data.  The minimum
length is 8 bytes because that is the length of
the header.  The field size sets a theoretical
limit of 65,535 bytes (8-byte header plus 65,527
bytes of data) for a UDP datagram.  However, the
actual limit for the data length, which is
imposed by the underlying IPv4 protocol, is
65,507 bytes (65,535 minus 8-byte UDP header
minus 20-byte IP header).
In IPv6 jumbograms, it is possible to have
UDP packets of a size greater than 65,535 bytes.
RFC 2675 specifies that the Length field is set
to zero if the length of the UDP header plus
UDP data is greater than 65,535.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """length must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_length(self):
    self.__length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="length", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  source_port_number = __builtin__.property(_get_source_port_number, _set_source_port_number)
  destination_port_number = __builtin__.property(_get_destination_port_number, _set_destination_port_number)
  length = __builtin__.property(_get_length, _set_length)

  __choices__ = {'layer-4': {'udp': ['description', 'source_port_number', 'destination_port_number', 'length']}}
  _pyangbind_elements = OrderedDict([('description', description), ('source_port_number', source_port_number), ('destination_port_number', destination_port_number), ('length', length), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/sctp/source-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of source port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'sctp', 'source-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'source-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/sctp/source-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
sctp source port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'source-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'sctp', 'source-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number/port_numbers (list)

    YANG Description: List of source port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of source port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'source-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/sctp/destination-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of destination port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'sctp', 'destination-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'destination-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/sctp/destination-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
sctp destination port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'destination-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'sctp', 'destination-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number/port_numbers (list)

    YANG Description: List of destination port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of destination port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'sctp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'destination-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_sctp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/sctp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent
SCTP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__source_port_number','__destination_port_number','__chunk_type','__chunk_length',)

  _yang_name = 'sctp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__chunk_type = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="chunk-type", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__chunk_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['4..max']}), is_leaf=True, yang_name="chunk-length", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'sctp']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/description (string)

    YANG Description: This is description for sctp condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for sctp condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_source_port_number(self):
    """
    Getter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number (container)

    YANG Description: The security policy rule according to
sctp source port number.
    """
    return self.__source_port_number
      
  def _set_source_port_number(self, v, load=False):
    """
    Setter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/source_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port_number() directly.

    YANG Description: The security policy rule according to
sctp source port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__source_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port_number(self):
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_destination_port_number(self):
    """
    Getter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number (container)

    YANG Description: The security policy rule according to
sctp destination port number.
    """
    return self.__destination_port_number
      
  def _set_destination_port_number(self, v, load=False):
    """
    Setter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/destination_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port_number() directly.

    YANG Description: The security policy rule according to
sctp destination port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__destination_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port_number(self):
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_chunk_type(self):
    """
    Getter method for chunk_type, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/chunk_type (uint8)

    YANG Description: The security policy rule according to
sctp chunk type ID Value.
    """
    return self.__chunk_type
      
  def _set_chunk_type(self, v, load=False):
    """
    Setter method for chunk_type, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/chunk_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chunk_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chunk_type() directly.

    YANG Description: The security policy rule according to
sctp chunk type ID Value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="chunk-type", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chunk_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="chunk-type", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__chunk_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chunk_type(self):
    self.__chunk_type = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="chunk-type", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_chunk_length(self):
    """
    Getter method for chunk_length, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/chunk_length (uint16)

    YANG Description: The security policy rule according to the length
of  the chunk in sctp. This value represents the
size of the chunk in bytes, including the Chunk
Type, Chunk Flags, Chunk Length, and Chunk Value
fields.
    """
    return self.__chunk_length
      
  def _set_chunk_length(self, v, load=False):
    """
    Setter method for chunk_length, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp/chunk_length (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chunk_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chunk_length() directly.

    YANG Description: The security policy rule according to the length
of  the chunk in sctp. This value represents the
size of the chunk in bytes, including the Chunk
Type, Chunk Flags, Chunk Length, and Chunk Value
fields.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['4..max']}), is_leaf=True, yang_name="chunk-length", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chunk_length must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['4..max']}), is_leaf=True, yang_name="chunk-length", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)""",
        })

    self.__chunk_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chunk_length(self):
    self.__chunk_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['4..max']}), is_leaf=True, yang_name="chunk-length", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint16', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  source_port_number = __builtin__.property(_get_source_port_number, _set_source_port_number)
  destination_port_number = __builtin__.property(_get_destination_port_number, _set_destination_port_number)
  chunk_type = __builtin__.property(_get_chunk_type, _set_chunk_type)
  chunk_length = __builtin__.property(_get_chunk_length, _set_chunk_length)

  __choices__ = {'layer-4': {'sctp': ['description', 'source_port_number', 'destination_port_number', 'chunk_type', 'chunk_length']}}
  _pyangbind_elements = OrderedDict([('description', description), ('source_port_number', source_port_number), ('destination_port_number', destination_port_number), ('chunk_type', chunk_type), ('chunk_length', chunk_length), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/dccp/source-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of source port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'dccp', 'source-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'source-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/dccp/source-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
dccp source port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'source-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'dccp', 'source-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number/port_numbers (list)

    YANG Description: List of source port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of source port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('source-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'source-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number_port_numbers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/dccp/destination-port-number/port-numbers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of destination port numbers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'port-numbers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'dccp', 'destination-port-number', 'port-numbers']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number/port_numbers/start (inet:port-number)

    YANG Description: A start port number for a range match.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number/port_numbers/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: A start port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number/port_numbers/end (inet:port-number)

    YANG Description: An end port number for a range match.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number/port_numbers/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: An end port number for a range match.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)

  __choices__ = {'destination-port': {'port-list': ['start', 'end']}}
  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/dccp/destination-port-number. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The security policy rule according to
dccp destination port number.
  """
  __slots__ = ('_path_helper', '_extmethods', '__port_numbers',)

  _yang_name = 'destination-port-number'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'dccp', 'destination-port-number']

  def _get_port_numbers(self):
    """
    Getter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number/port_numbers (list)

    YANG Description: List of destination port numbers.
    """
    return self.__port_numbers
      
  def _set_port_numbers(self, v, load=False):
    """
    Setter method for port_numbers, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number/port_numbers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_numbers() directly.

    YANG Description: List of destination port numbers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_numbers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__port_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_numbers(self):
    self.__port_numbers = YANGDynClass(base=YANGListType("start end",yc_port_numbers_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number_port_numbers, yang_name="port-numbers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None, choice=('layer-4', 'dccp')), is_container='list', yang_name="port-numbers", parent=self, choice=('destination-port', 'port-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  port_numbers = __builtin__.property(_get_port_numbers, _set_port_numbers)

  __choices__ = {'destination-port': {'port-list': ['port_numbers']}}
  _pyangbind_elements = OrderedDict([('port_numbers', port_numbers), ])


class yc_dccp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/dccp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent
DCCP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__source_port_number','__destination_port_number','__service_code','__type','__data_offset',)

  _yang_name = 'dccp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__service_code = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="service-code", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    self.__type = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..15']})), is_leaf=False, yang_name="type", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__data_offset = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'dccp']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/description (string)

    YANG Description: This is description for dccp condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for dccp condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_source_port_number(self):
    """
    Getter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number (container)

    YANG Description: The security policy rule according to
dccp source port number.
    """
    return self.__source_port_number
      
  def _set_source_port_number(self, v, load=False):
    """
    Setter method for source_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/source_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port_number() directly.

    YANG Description: The security policy rule according to
dccp source port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__source_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port_number(self):
    self.__source_port_number = YANGDynClass(base=yc_source_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_source_port_number, is_container='container', yang_name="source-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_destination_port_number(self):
    """
    Getter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number (container)

    YANG Description: The security policy rule according to
dccp destination port number.
    """
    return self.__destination_port_number
      
  def _set_destination_port_number(self, v, load=False):
    """
    Setter method for destination_port_number, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/destination_port_number (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port_number() directly.

    YANG Description: The security policy rule according to
dccp destination port number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port_number must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__destination_port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port_number(self):
    self.__destination_port_number = YANGDynClass(base=yc_destination_port_number_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp_destination_port_number, is_container='container', yang_name="destination-port-number", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_service_code(self):
    """
    Getter method for service_code, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/service_code (uint32)

    YANG Description: The security policy rule according to
dccp service code.
    """
    return self.__service_code
      
  def _set_service_code(self, v, load=False):
    """
    Setter method for service_code, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/service_code (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_code() directly.

    YANG Description: The security policy rule according to
dccp service code.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="service-code", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_code must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="service-code", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__service_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_code(self):
    self.__service_code = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="service-code", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/type (uint8)

    YANG Description: The security policy rule according to the 4 bits
of dccp type header field for dccp packet types
such as DCCP-Request, DCCP-Response, DCCP-Data,
DCCP-Ack, and DCCP-DataAck.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The security policy rule according to the 4 bits
of dccp type header field for dccp packet types
such as DCCP-Request, DCCP-Response, DCCP-Data,
DCCP-Ack, and DCCP-DataAck.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..15']})), is_leaf=False, yang_name="type", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..15']})), is_leaf=False, yang_name="type", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..15']})), is_leaf=False, yang_name="type", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_data_offset(self):
    """
    Getter method for data_offset, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/data_offset (uint8)

    YANG Description: The security policy rule according to the offset
from
the start of the packet's DCCP header to the start
of its application data area, in 32-bit word.
    """
    return self.__data_offset
      
  def _set_data_offset(self, v, load=False):
    """
    Setter method for data_offset, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp/data_offset (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_offset() directly.

    YANG Description: The security policy rule according to the offset
from
the start of the packet's DCCP header to the start
of its application data area, in 32-bit word.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_offset must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__data_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_offset(self):
    self.__data_offset = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="data-offset", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  source_port_number = __builtin__.property(_get_source_port_number, _set_source_port_number)
  destination_port_number = __builtin__.property(_get_destination_port_number, _set_destination_port_number)
  service_code = __builtin__.property(_get_service_code, _set_service_code)
  type = __builtin__.property(_get_type, _set_type)
  data_offset = __builtin__.property(_get_data_offset, _set_data_offset)

  __choices__ = {'layer-4': {'dccp': ['description', 'source_port_number', 'destination_port_number', 'service_code', 'type', 'data_offset']}}
  _pyangbind_elements = OrderedDict([('description', description), ('source_port_number', source_port_number), ('destination_port_number', destination_port_number), ('service_code', service_code), ('type', type), ('data_offset', data_offset), ])


class yc_icmp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_icmp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/icmp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The purpose of this container is to represent
ICMPv4 and ICMPv6 packet header information to
determine if the set of policy actions in this ECA
policy rule should be executed or not.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__version','__type','__code','__rest_of_header',)

  _yang_name = 'icmp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'icmpv4': {'value': 1}, 'icmpv6': {'value': 2}},), is_leaf=True, yang_name="version", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="type", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__code = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="code", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__rest_of_header = YANGDynClass(base=bitarray, is_leaf=True, yang_name="rest-of-header", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'icmp']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/description (string)

    YANG Description: This is description for icmp condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for icmp condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/version (enumeration)

    YANG Description: The ICMP version to be matched. This value
affected the type and code values.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The ICMP version to be matched. This value
affected the type and code values.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'icmpv4': {'value': 1}, 'icmpv6': {'value': 2}},), is_leaf=True, yang_name="version", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with enumeration""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'icmpv4': {'value': 1}, 'icmpv6': {'value': 2}},), is_leaf=True, yang_name="version", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'icmpv4': {'value': 1}, 'icmpv6': {'value': 2}},), is_leaf=True, yang_name="version", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/type (uint8)

    YANG Description: Also known as control messages.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Also known as control messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="type", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="type", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="type", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_code(self):
    """
    Getter method for code, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/code (uint8)

    YANG Description: ICMP subtype.  Also known as control messages.
    """
    return self.__code
      
  def _set_code(self, v, load=False):
    """
    Setter method for code, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/code (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_code() directly.

    YANG Description: ICMP subtype.  Also known as control messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="code", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """code must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="code", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_code(self):
    self.__code = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="code", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_rest_of_header(self):
    """
    Getter method for rest_of_header, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/rest_of_header (binary)

    YANG Description: Unbounded in length, the contents vary based on the
ICMP type and code.  Also referred to as 'Message Body'
in ICMPv6.
    """
    return self.__rest_of_header
      
  def _set_rest_of_header(self, v, load=False):
    """
    Setter method for rest_of_header, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp/rest_of_header (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rest_of_header is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rest_of_header() directly.

    YANG Description: Unbounded in length, the contents vary based on the
ICMP type and code.  Also referred to as 'Message Body'
in ICMPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bitarray, is_leaf=True, yang_name="rest-of-header", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rest_of_header must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=bitarray, is_leaf=True, yang_name="rest-of-header", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)""",
        })

    self.__rest_of_header = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rest_of_header(self):
    self.__rest_of_header = YANGDynClass(base=bitarray, is_leaf=True, yang_name="rest-of-header", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  version = __builtin__.property(_get_version, _set_version)
  type = __builtin__.property(_get_type, _set_type)
  code = __builtin__.property(_get_code, _set_code)
  rest_of_header = __builtin__.property(_get_rest_of_header, _set_rest_of_header)

  __choices__ = {'layer-4': {'icmp': ['description', 'version', 'type', 'code', 'rest_of_header']}}
  _pyangbind_elements = OrderedDict([('description', description), ('version', version), ('type', type), ('code', code), ('rest_of_header', rest_of_header), ])


class yc_url_category_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_url_category(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/url-category. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for url category
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__pre_defined','__user_defined',)

  _yang_name = 'url-category'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__pre_defined = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="pre-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__user_defined = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'url-category']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category/description (string)

    YANG Description: This is description for the condition of a URL's
category such as SNS sites, game sites, ecommerce
sites, company sites, and university sites.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for the condition of a URL's
category such as SNS sites, game sites, ecommerce
sites, company sites, and university sites.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_pre_defined(self):
    """
    Getter method for pre_defined, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category/pre_defined (string)

    YANG Description: This is pre-defined-category. To specify the name of
URL database.
    """
    return self.__pre_defined
      
  def _set_pre_defined(self, v, load=False):
    """
    Setter method for pre_defined, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category/pre_defined (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_defined is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_defined() directly.

    YANG Description: This is pre-defined-category. To specify the name of
URL database.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="pre-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_defined must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="pre-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__pre_defined = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_defined(self):
    self.__pre_defined = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="pre-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_user_defined(self):
    """
    Getter method for user_defined, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category/user_defined (string)

    YANG Description: This user-defined-category. To allow a user's manual
addition of URLs for URL filtering.
    """
    return self.__user_defined
      
  def _set_user_defined(self, v, load=False):
    """
    Setter method for user_defined, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category/user_defined (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined() directly.

    YANG Description: This user-defined-category. To allow a user's manual
addition of URLs for URL filtering.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_defined must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__user_defined = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_defined(self):
    self.__user_defined = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-defined", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  pre_defined = __builtin__.property(_get_pre_defined, _set_pre_defined)
  user_defined = __builtin__.property(_get_user_defined, _set_user_defined)


  _pyangbind_elements = OrderedDict([('description', description), ('pre_defined', pre_defined), ('user_defined', user_defined), ])


class yc_voice_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_voice(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/voice. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: For the VoIP/VoCN security system, a VoIP/
VoCN security system can monitor each
VoIP/VoCN flow and manage VoIP/VoCN
security rules controlled by a centralized
server for VoIP/VoCN security service
(called VoIP IPS). The VoIP/VoCN security
system controls each switch for the
VoIP/VoCN call flow management by
manipulating the rules that can be added,
deleted, or modified dynamically.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__source_voice_id','__destination_voice_id','__user_agent',)

  _yang_name = 'voice'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__source_voice_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__destination_voice_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__user_agent = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'voice']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/description (string)

    YANG Description: This is description for voice condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for voice condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_source_voice_id(self):
    """
    Getter method for source_voice_id, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/source_voice_id (string)

    YANG Description: The security policy rule according to
a source voice ID for VoIP and VoCN.
    """
    return self.__source_voice_id
      
  def _set_source_voice_id(self, v, load=False):
    """
    Setter method for source_voice_id, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/source_voice_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_voice_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_voice_id() directly.

    YANG Description: The security policy rule according to
a source voice ID for VoIP and VoCN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_voice_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__source_voice_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_voice_id(self):
    self.__source_voice_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_destination_voice_id(self):
    """
    Getter method for destination_voice_id, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/destination_voice_id (string)

    YANG Description: The security policy rule according to
a destination voice ID for VoIP and VoCN.
    """
    return self.__destination_voice_id
      
  def _set_destination_voice_id(self, v, load=False):
    """
    Setter method for destination_voice_id, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/destination_voice_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_voice_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_voice_id() directly.

    YANG Description: The security policy rule according to
a destination voice ID for VoIP and VoCN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_voice_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__destination_voice_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_voice_id(self):
    self.__destination_voice_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination-voice-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_user_agent(self):
    """
    Getter method for user_agent, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/user_agent (string)

    YANG Description: The security policy rule according to
a user agent for VoIP and VoCN.
    """
    return self.__user_agent
      
  def _set_user_agent(self, v, load=False):
    """
    Setter method for user_agent, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice/user_agent (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_agent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_agent() directly.

    YANG Description: The security policy rule according to
a user agent for VoIP and VoCN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_agent must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__user_agent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_agent(self):
    self.__user_agent = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="user-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  source_voice_id = __builtin__.property(_get_source_voice_id, _set_source_voice_id)
  destination_voice_id = __builtin__.property(_get_destination_voice_id, _set_destination_voice_id)
  user_agent = __builtin__.property(_get_user_agent, _set_user_agent)


  _pyangbind_elements = OrderedDict([('description', description), ('source_voice_id', source_voice_id), ('destination_voice_id', destination_voice_id), ('user_agent', user_agent), ])


class yc_ddos_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ddos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/ddos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for DDoS attack.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__alert_packet_rate','__alert_flow_rate','__alert_byte_rate',)

  _yang_name = 'ddos'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__alert_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    self.__alert_flow_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-flow-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    self.__alert_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'ddos']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/description (string)

    YANG Description: This is description for ddos condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for ddos condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_alert_packet_rate(self):
    """
    Getter method for alert_packet_rate, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/alert_packet_rate (uint32)

    YANG Description: The alert rate of flood detection for
packets per second (PPS) of an IP address.
If the PPS of an IP address exceeds
the alert rate threshold, an alert
will be generated.
    """
    return self.__alert_packet_rate
      
  def _set_alert_packet_rate(self, v, load=False):
    """
    Setter method for alert_packet_rate, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/alert_packet_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alert_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alert_packet_rate() directly.

    YANG Description: The alert rate of flood detection for
packets per second (PPS) of an IP address.
If the PPS of an IP address exceeds
the alert rate threshold, an alert
will be generated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alert_packet_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__alert_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alert_packet_rate(self):
    self.__alert_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)


  def _get_alert_flow_rate(self):
    """
    Getter method for alert_flow_rate, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/alert_flow_rate (uint32)

    YANG Description: The alert rate of flood detection for the
flow creating requests (e.g., new TCP connection
establishment) per second of an IP address as
either a source node or a destination node. If
the flows per second of an IP address exceeds
the alert rate threshold, an alert will be
generated.
    """
    return self.__alert_flow_rate
      
  def _set_alert_flow_rate(self, v, load=False):
    """
    Setter method for alert_flow_rate, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/alert_flow_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alert_flow_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alert_flow_rate() directly.

    YANG Description: The alert rate of flood detection for the
flow creating requests (e.g., new TCP connection
establishment) per second of an IP address as
either a source node or a destination node. If
the flows per second of an IP address exceeds
the alert rate threshold, an alert will be
generated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-flow-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alert_flow_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-flow-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__alert_flow_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alert_flow_rate(self):
    self.__alert_flow_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-flow-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)


  def _get_alert_byte_rate(self):
    """
    Getter method for alert_byte_rate, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/alert_byte_rate (uint32)

    YANG Description: The alert rate of flood detection for
bytes per second (Bps) of an IP address.
If the bytes per second of an IP address
exceeds the alert rate threshold, an alert
will be generated.
    """
    return self.__alert_byte_rate
      
  def _set_alert_byte_rate(self, v, load=False):
    """
    Setter method for alert_byte_rate, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos/alert_byte_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alert_byte_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alert_byte_rate() directly.

    YANG Description: The alert rate of flood detection for
bytes per second (Bps) of an IP address.
If the bytes per second of an IP address
exceeds the alert rate threshold, an alert
will be generated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alert_byte_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__alert_byte_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alert_byte_rate(self):
    self.__alert_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alert-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  alert_packet_rate = __builtin__.property(_get_alert_packet_rate, _set_alert_packet_rate)
  alert_flow_rate = __builtin__.property(_get_alert_flow_rate, _set_alert_flow_rate)
  alert_byte_rate = __builtin__.property(_get_alert_byte_rate, _set_alert_byte_rate)


  _pyangbind_elements = OrderedDict([('description', description), ('alert_packet_rate', alert_packet_rate), ('alert_flow_rate', alert_flow_rate), ('alert_byte_rate', alert_byte_rate), ])


class yc_anti_virus_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_anti_virus(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/anti-virus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for antivirus
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile','__exception_files',)

  _yang_name = 'anti-virus'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__exception_files = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'anti-virus']

  def _get_profile(self):
    """
    Getter method for profile, mapped from YANG variable /i2nsf_security_policy/rules/condition/anti_virus/profile (string)

    YANG Description: The security profile for antivirus. This is used to
update the security profile for improving the
security. The security profile is used to scan
the viruses.
    """
    return self.__profile
      
  def _set_profile(self, v, load=False):
    """
    Setter method for profile, mapped from YANG variable /i2nsf_security_policy/rules/condition/anti_virus/profile (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile() directly.

    YANG Description: The security profile for antivirus. This is used to
update the security profile for improving the
security. The security profile is used to scan
the viruses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile(self):
    self.__profile = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_exception_files(self):
    """
    Getter method for exception_files, mapped from YANG variable /i2nsf_security_policy/rules/condition/anti_virus/exception_files (string)

    YANG Description: The type or name of the files to be excluded by the
antivirus. This can be used to keep the known
harmless files. Absolute paths are filenames/paths
to be excluded and relative ones are interpreted as
globs.
    """
    return self.__exception_files
      
  def _set_exception_files(self, v, load=False):
    """
    Setter method for exception_files, mapped from YANG variable /i2nsf_security_policy/rules/condition/anti_virus/exception_files (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exception_files is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exception_files() directly.

    YANG Description: The type or name of the files to be excluded by the
antivirus. This can be used to keep the known
harmless files. Absolute paths are filenames/paths
to be excluded and relative ones are interpreted as
globs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exception_files must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__exception_files = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exception_files(self):
    self.__exception_files = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="exception-files", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  profile = __builtin__.property(_get_profile, _set_profile)
  exception_files = __builtin__.property(_get_exception_files, _set_exception_files)


  _pyangbind_elements = OrderedDict([('profile', profile), ('exception_files', exception_files), ])


class yc_payload_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_payload(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/payload. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for packet payload
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__content',)

  _yang_name = 'payload'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__content = YANGDynClass(unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'payload']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/payload/description (string)

    YANG Description: This is description for payload condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/payload/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for payload condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_content(self):
    """
    Getter method for content, mapped from YANG variable /i2nsf_security_policy/rules/condition/payload/content (binary)

    YANG Description: This is a condition for packet payload content.
The payload content is the binary stream contained
by a security attack such as backdoor attack. It is
usually used for Deep Packet Inspection (DPI).
    """
    return self.__content
      
  def _set_content(self, v, load=False):
    """
    Setter method for content, mapped from YANG variable /i2nsf_security_policy/rules/condition/payload/content (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_content is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_content() directly.

    YANG Description: This is a condition for packet payload content.
The payload content is the binary stream contained
by a security attack such as backdoor attack. It is
usually used for Deep Packet Inspection (DPI).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """content must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)""",
        })

    self.__content = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_content(self):
    self.__content = YANGDynClass(unique=True, base=TypedListType(allowed_type=bitarray), is_leaf=False, yang_name="content", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='binary', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  content = __builtin__.property(_get_content, _set_content)


  _pyangbind_elements = OrderedDict([('description', description), ('content', content), ])


class yc_period_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time_period(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/time/period. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This represents the repetition time.  In the case
where the frequency is weekly, the days can be
set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_time','__end_time','__day','__date','__month',)

  _yang_name = 'period'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)
    self.__end_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)
    self.__day = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='day', is_config=True)
    self.__date = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='int8', is_config=True)
    self.__month = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'time', 'period']

  def _get_start_time(self):
    """
    Getter method for start_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/start_time (time)

    YANG Description: This is a period's start time for an event.
    """
    return self.__start_time
      
  def _set_start_time(self, v, load=False):
    """
    Setter method for start_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/start_time (time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_time() directly.

    YANG Description: This is a period's start time for an event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_time must be of a type compatible with time""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)""",
        })

    self.__start_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_time(self):
    self.__start_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="start-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)


  def _get_end_time(self):
    """
    Getter method for end_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/end_time (time)

    YANG Description: This is a period's end time for an event.
    """
    return self.__end_time
      
  def _set_end_time(self, v, load=False):
    """
    Setter method for end_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/end_time (time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_time() directly.

    YANG Description: This is a period's end time for an event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_time must be of a type compatible with time""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)""",
        })

    self.__end_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_time(self):
    self.__end_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="end-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='time', is_config=True)


  def _get_day(self):
    """
    Getter method for day, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/day (day)

    YANG Description: This represents the repeated day of every week
(e.g., Monday and Tuesday).  More than one day
can be specified.
    """
    return self.__day
      
  def _set_day(self, v, load=False):
    """
    Setter method for day, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/day (day)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_day is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_day() directly.

    YANG Description: This represents the repeated day of every week
(e.g., Monday and Tuesday).  More than one day
can be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='day', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """day must be of a type compatible with day""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:day",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='day', is_config=True)""",
        })

    self.__day = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_day(self):
    self.__day = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'monday': {}, 'tuesday': {}, 'wednesday': {}, 'thursday': {}, 'friday': {}, 'saturday': {}, 'sunday': {}},)), is_leaf=False, yang_name="day", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='day', is_config=True)


  def _get_date(self):
    """
    Getter method for date, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/date (int8)

    YANG Description: This represents the repeated date of every month.
More than one date can be specified.
    """
    return self.__date
      
  def _set_date(self, v, load=False):
    """
    Setter method for date, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/date (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_date is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_date() directly.

    YANG Description: This represents the repeated date of every month.
More than one date can be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """date must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='int8', is_config=True)""",
        })

    self.__date = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_date(self):
    self.__date = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), restriction_dict={'range': ['1..31']})), is_leaf=False, yang_name="date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='int8', is_config=True)


  def _get_month(self):
    """
    Getter method for month, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/month (string)

    YANG Description: This represents the repeated date and month of
every year.  More than one can be specified.
A pattern used here is Month and Date (MM-DD).
    """
    return self.__month
      
  def _set_month(self, v, load=False):
    """
    Setter method for month, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period/month (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_month is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_month() directly.

    YANG Description: This represents the repeated date and month of
every year.  More than one can be specified.
A pattern used here is Month and Date (MM-DD).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """month must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__month = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_month(self):
    self.__month = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{2}-\\d{2}'})), is_leaf=False, yang_name="month", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  start_time = __builtin__.property(_get_start_time, _set_start_time)
  end_time = __builtin__.property(_get_end_time, _set_end_time)
  day = __builtin__.property(_get_day, _set_day)
  date = __builtin__.property(_get_date, _set_date)
  month = __builtin__.property(_get_month, _set_month)


  _pyangbind_elements = OrderedDict([('start_time', start_time), ('end_time', end_time), ('day', day), ('date', date), ('month', month), ])


class yc_time_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/time. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Time to determine when the policy should be applied
  """
  __slots__ = ('_path_helper', '_extmethods', '__start_date_time','__end_date_time','__period','__frequency',)

  _yang_name = 'time'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)
    self.__end_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)
    self.__period = YANGDynClass(base=yc_period_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'time']

  def _get_start_date_time(self):
    """
    Getter method for start_date_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/start_date_time (yang:date-and-time)

    YANG Description: This is the start date and time for a security
policy rule.
    """
    return self.__start_date_time
      
  def _set_start_date_time(self, v, load=False):
    """
    Setter method for start_date_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/start_date_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_date_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_date_time() directly.

    YANG Description: This is the start date and time for a security
policy rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_date_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__start_date_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_date_time(self):
    self.__start_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="start-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)


  def _get_end_date_time(self):
    """
    Getter method for end_date_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/end_date_time (yang:date-and-time)

    YANG Description: This is the end date and time for a policy rule.
The policy rule will stop working after the
specified end-date-time.
    """
    return self.__end_date_time
      
  def _set_end_date_time(self, v, load=False):
    """
    Setter method for end_date_time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/end_date_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_date_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_date_time() directly.

    YANG Description: This is the end date and time for a policy rule.
The policy rule will stop working after the
specified end-date-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_date_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__end_date_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_date_time(self):
    self.__end_date_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="end-date-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='yang:date-and-time', is_config=True)


  def _get_period(self):
    """
    Getter method for period, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period (container)

    YANG Description: This represents the repetition time.  In the case
where the frequency is weekly, the days can be
set.
    """
    return self.__period
      
  def _set_period(self, v, load=False):
    """
    Setter method for period, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/period (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_period() directly.

    YANG Description: This represents the repetition time.  In the case
where the frequency is weekly, the days can be
set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_period_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """period must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_period_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_period(self):
    self.__period = YANGDynClass(base=yc_period_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time_period, is_container='container', yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/frequency (enumeration)

    YANG Description: This represents how frequently the rule
should be enforced.
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time/frequency (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: This represents how frequently the rule
should be enforced.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with enumeration""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'only-once': {}, 'daily': {}, 'weekly': {}, 'monthly': {}, 'yearly': {}},), default=six.text_type("only-once"), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='enumeration', is_config=True)

  start_date_time = __builtin__.property(_get_start_date_time, _set_start_date_time)
  end_date_time = __builtin__.property(_get_end_date_time, _set_end_date_time)
  period = __builtin__.property(_get_period, _set_period)
  frequency = __builtin__.property(_get_frequency, _set_frequency)


  _pyangbind_elements = OrderedDict([('start_date_time', start_date_time), ('end_date_time', end_date_time), ('period', period), ('frequency', frequency), ])


class yc_application_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_application(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/application. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for application
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__protocol',)

  _yang_name = 'application'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'application']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/application/description (string)

    YANG Description: This is description for application condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/application/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for application condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/application/protocol (identityref)

    YANG Description: The condition based on the application layer
protocol
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/application/protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The condition based on the application layer
protocol
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:http2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:https2': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ftp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ssh': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:telnet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:smtp': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pop3s': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imap': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:imaps': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  protocol = __builtin__.property(_get_protocol, _set_protocol)


  _pyangbind_elements = OrderedDict([('description', description), ('protocol', protocol), ])


class yc_device_type_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_device_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/device-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for type of the destination device
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__device',)

  _yang_name = 'device-type'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'device-type']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/device_type/description (string)

    YANG Description: This is description for destination device type
condition. Vendors can write instructions for the
condition that vendor made
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/device_type/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for destination device type
condition. Vendors can write instructions for the
condition that vendor made
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/device_type/device (identityref)

    YANG Description: The device attribute that can identify a device,
including the device type (i.e., router, switch,
pc, ios, or android) and the device's owner as
well.
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/device_type/device (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.

    YANG Description: The device attribute that can identify a device,
including the device type (i.e., router, switch,
pc, ios, or android) and the device's owner as
well.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:computer': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mobile-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-phone': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tablet': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:network-infrastructure-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:iot-device': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ot': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:vehicle': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('description', description), ('device', device), ])


class yc_user_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_user(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/users/user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The user with which the traffic flow is associated
can be identified by either a user ID or username.
The user-to-IP address mapping is assumed to be
provided by the unified user management system via
network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name',)

  _yang_name = 'user'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'users', 'user']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/user/id (uint32)

    YANG Description: The ID of the user.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/user/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The ID of the user.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/user/name (string)

    YANG Description: The name of the user.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/user/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the user.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ])


class yc_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/users/group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The user group with which the traffic flow is
associated can be identified by either a group ID
or group name. The group-to-IP address and
user-to-group mappings are assumed to be provided by
the unified user management system via network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name',)

  _yang_name = 'group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'users', 'group']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/group/id (uint32)

    YANG Description: The ID of the group.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/group/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The ID of the group.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint32', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/group/name (string)

    YANG Description: The name of the group.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ])


class yc_users_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/users. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for users
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__user','__group',)

  _yang_name = 'users'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__user = YANGDynClass(base=YANGListType("id",yc_user_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    self.__group = YANGDynClass(base=YANGListType("id",yc_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'users']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/description (string)

    YANG Description: This is the description for users' condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is the description for users' condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/user (list)

    YANG Description: The user with which the traffic flow is associated
can be identified by either a user ID or username.
The user-to-IP address mapping is assumed to be
provided by the unified user management system via
network.
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/user (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: The user with which the traffic flow is associated
can be identified by either a user ID or username.
The user-to-IP address mapping is assumed to be
provided by the unified user management system via
network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_user_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_user_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=YANGListType("id",yc_user_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)


  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/group (list)

    YANG Description: The user group with which the traffic flow is
associated can be identified by either a group ID
or group name. The group-to-IP address and
user-to-group mappings are assumed to be provided by
the unified user management system via network.
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users/group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.

    YANG Description: The user group with which the traffic flow is
associated can be identified by either a group ID
or group name. The group-to-IP address and
user-to-group mappings are assumed to be provided by
the unified user management system via network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=YANGListType("id",yc_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  user = __builtin__.property(_get_user, _set_user)
  group = __builtin__.property(_get_group, _set_group)


  _pyangbind_elements = OrderedDict([('description', description), ('user', user), ('group', group), ])


class yc_geographic_location_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_geographic_location(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context/geographic-location. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The location which network traffic flow is associated
with. The region can be the geographic location such
as country, province, and city, as well as the logical
network location such as IP address, network section,
and network domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__source','__destination',)

  _yang_name = 'geographic-location'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__source = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__destination = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context', 'geographic-location']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location/description (string)

    YANG Description: This is the description for the geographic location
condition. It is used to describe the conditions and
instructions that should be implemented.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is the description for the geographic location
condition. It is used to describe the conditions and
instructions that should be implemented.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location/source (string)

    YANG Description: The source is a geographic location mapped into an
IP address. It matches the mapped IP address to the
source IP address of the traffic flow.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location/source (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: The source is a geographic location mapped into an
IP address. It matches the mapped IP address to the
source IP address of the traffic flow.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location/destination (string)

    YANG Description: The destination is a geographic location mapped into
an IP address. It matches the mapped IP address to
the destination IP address of the traffic flow.
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location/destination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: The destination is a geographic location mapped into
an IP address. It matches the mapped IP address to
the destination IP address of the traffic flow.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  source = __builtin__.property(_get_source, _set_source)
  destination = __builtin__.property(_get_destination, _set_destination)


  _pyangbind_elements = OrderedDict([('description', description), ('source', source), ('destination', destination), ])


class yc_context_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition/context. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Condition for context
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__time','__application','__device_type','__users','__geographic_location',)

  _yang_name = 'context'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__time = YANGDynClass(base=yc_time_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__application = YANGDynClass(base=yc_application_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__device_type = YANGDynClass(base=yc_device_type_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__users = YANGDynClass(base=yc_users_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__geographic_location = YANGDynClass(base=yc_geographic_location_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition', 'context']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/description (string)

    YANG Description: This is description for context condition.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is description for context condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_time(self):
    """
    Getter method for time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time (container)

    YANG Description: Time to determine when the policy should be applied
    """
    return self.__time
      
  def _set_time(self, v, load=False):
    """
    Setter method for time, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/time (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time() directly.

    YANG Description: Time to determine when the policy should be applied
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_time_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_time_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time(self):
    self.__time = YANGDynClass(base=yc_time_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_time, is_container='container', yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_application(self):
    """
    Getter method for application, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/application (container)

    YANG Description: Condition for application
    """
    return self.__application
      
  def _set_application(self, v, load=False):
    """
    Setter method for application, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/application (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_application is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_application() directly.

    YANG Description: Condition for application
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_application_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """application must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_application_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__application = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_application(self):
    self.__application = YANGDynClass(base=yc_application_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_application, is_container='container', yang_name="application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/device_type (container)

    YANG Description: Condition for type of the destination device
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/device_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.

    YANG Description: Condition for type of the destination device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_device_type_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_device_type_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=yc_device_type_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_device_type, is_container='container', yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_users(self):
    """
    Getter method for users, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users (container)

    YANG Description: Condition for users
    """
    return self.__users
      
  def _set_users(self, v, load=False):
    """
    Setter method for users, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/users (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_users() directly.

    YANG Description: Condition for users
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_users_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """users must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_users_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_users(self):
    self.__users = YANGDynClass(base=yc_users_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_users, is_container='container', yang_name="users", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_geographic_location(self):
    """
    Getter method for geographic_location, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location (container)

    YANG Description: The location which network traffic flow is associated
with. The region can be the geographic location such
as country, province, and city, as well as the logical
network location such as IP address, network section,
and network domain.
    """
    return self.__geographic_location
      
  def _set_geographic_location(self, v, load=False):
    """
    Setter method for geographic_location, mapped from YANG variable /i2nsf_security_policy/rules/condition/context/geographic_location (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geographic_location is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geographic_location() directly.

    YANG Description: The location which network traffic flow is associated
with. The region can be the geographic location such
as country, province, and city, as well as the logical
network location such as IP address, network section,
and network domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_geographic_location_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """geographic_location must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_geographic_location_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__geographic_location = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_geographic_location(self):
    self.__geographic_location = YANGDynClass(base=yc_geographic_location_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context_geographic_location, is_container='container', yang_name="geographic-location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  time = __builtin__.property(_get_time, _set_time)
  application = __builtin__.property(_get_application, _set_application)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  users = __builtin__.property(_get_users, _set_users)
  geographic_location = __builtin__.property(_get_geographic_location, _set_geographic_location)


  _pyangbind_elements = OrderedDict([('description', description), ('time', time), ('application', application), ('device_type', device_type), ('users', users), ('geographic_location', geographic_location), ])


class yc_condition_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/condition. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A condition is defined as a set
of attributes, features, and/or values that are to be
compared with a set of known attributes, features,
and/or values in order to determine whether the
set of Actions in that (imperative) I2NSF Policy Rule
can be executed or not. Examples of I2NSF Conditions
include matching attributes of a packet or flow, and
comparing the internal state of an NSF to a desired
state.
The condition works with 'AND' logic, where all
fields set in a condition MUST match the packet or flow
for the condition to be evaluated as 'TRUE'
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__layer_2','__ipv4','__ipv6','__tcp','__udp','__sctp','__dccp','__icmp','__url_category','__voice','__ddos','__anti_virus','__payload','__context',)

  _yang_name = 'condition'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__layer_2 = YANGDynClass(base=YANGListType("destination_mac_address source_mac_address ethertype",yc_layer_2_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_layer_2, yang_name="layer-2", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-mac-address source-mac-address ethertype', extensions=None), is_container='list', yang_name="layer-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4, is_container='container', yang_name="ipv4", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6, is_container='container', yang_name="ipv6", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__tcp = YANGDynClass(base=yc_tcp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp, is_container='container', yang_name="tcp", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__udp = YANGDynClass(base=yc_udp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp, is_container='container', yang_name="udp", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__sctp = YANGDynClass(base=yc_sctp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp, is_container='container', yang_name="sctp", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__dccp = YANGDynClass(base=yc_dccp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp, is_container='container', yang_name="dccp", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__icmp = YANGDynClass(base=yc_icmp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_icmp, is_container='container', yang_name="icmp", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__url_category = YANGDynClass(base=yc_url_category_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__voice = YANGDynClass(base=yc_voice_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__ddos = YANGDynClass(base=yc_ddos_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__anti_virus = YANGDynClass(base=yc_anti_virus_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__payload = YANGDynClass(base=yc_payload_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__context = YANGDynClass(base=yc_context_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'condition']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/description (string)

    YANG Description: Description for a condition clause.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/condition/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for a condition clause.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_layer_2(self):
    """
    Getter method for layer_2, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2 (list)

    YANG Description: The purpose of this container is to represent layer 2
packet header information to determine the set of policy
actions in this ECA policy rule should be executed or
not.
    """
    return self.__layer_2
      
  def _set_layer_2(self, v, load=False):
    """
    Setter method for layer_2, mapped from YANG variable /i2nsf_security_policy/rules/condition/layer_2 (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_2() directly.

    YANG Description: The purpose of this container is to represent layer 2
packet header information to determine the set of policy
actions in this ECA policy rule should be executed or
not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("destination_mac_address source_mac_address ethertype",yc_layer_2_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_layer_2, yang_name="layer-2", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-mac-address source-mac-address ethertype', extensions=None), is_container='list', yang_name="layer-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """layer_2 must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("destination_mac_address source_mac_address ethertype",yc_layer_2_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_layer_2, yang_name="layer-2", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-mac-address source-mac-address ethertype', extensions=None), is_container='list', yang_name="layer-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__layer_2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_layer_2(self):
    self.__layer_2 = YANGDynClass(base=YANGListType("destination_mac_address source_mac_address ethertype",yc_layer_2_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_layer_2, yang_name="layer-2", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='destination-mac-address source-mac-address ethertype', extensions=None), is_container='list', yang_name="layer-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4 (container)

    YANG Description: The purpose of this container is to represent
IPv4 packet header information to determine if
the set of policy actions in this ECA policy rule
should be executed or not.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: The purpose of this container is to represent
IPv4 packet header information to determine if
the set of policy actions in this ECA policy rule
should be executed or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4, is_container='container', yang_name="ipv4", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4, is_container='container', yang_name="ipv4", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv4, is_container='container', yang_name="ipv4", parent=self, choice=('layer-3', 'ipv4'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6 (container)

    YANG Description: The purpose of this container is to represent IPv6
packet header information to determine if the set
of policy actions in this ECA policy rule should
be executed or not.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /i2nsf_security_policy/rules/condition/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: The purpose of this container is to represent IPv6
packet header information to determine if the set
of policy actions in this ECA policy rule should
be executed or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6, is_container='container', yang_name="ipv6", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6, is_container='container', yang_name="ipv6", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ipv6, is_container='container', yang_name="ipv6", parent=self, choice=('layer-3', 'ipv6'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_tcp(self):
    """
    Getter method for tcp, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp (container)

    YANG Description: The purpose of this container is to represent
TCP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    return self.__tcp
      
  def _set_tcp(self, v, load=False):
    """
    Setter method for tcp, mapped from YANG variable /i2nsf_security_policy/rules/condition/tcp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp() directly.

    YANG Description: The purpose of this container is to represent
TCP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tcp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp, is_container='container', yang_name="tcp", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tcp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp, is_container='container', yang_name="tcp", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__tcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp(self):
    self.__tcp = YANGDynClass(base=yc_tcp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_tcp, is_container='container', yang_name="tcp", parent=self, choice=('layer-4', 'tcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_udp(self):
    """
    Getter method for udp, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp (container)

    YANG Description: The purpose of this container is to represent
UDP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    return self.__udp
      
  def _set_udp(self, v, load=False):
    """
    Setter method for udp, mapped from YANG variable /i2nsf_security_policy/rules/condition/udp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_udp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_udp() directly.

    YANG Description: The purpose of this container is to represent
UDP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_udp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp, is_container='container', yang_name="udp", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """udp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_udp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp, is_container='container', yang_name="udp", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__udp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_udp(self):
    self.__udp = YANGDynClass(base=yc_udp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_udp, is_container='container', yang_name="udp", parent=self, choice=('layer-4', 'udp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_sctp(self):
    """
    Getter method for sctp, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp (container)

    YANG Description: The purpose of this container is to represent
SCTP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    return self.__sctp
      
  def _set_sctp(self, v, load=False):
    """
    Setter method for sctp, mapped from YANG variable /i2nsf_security_policy/rules/condition/sctp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sctp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sctp() directly.

    YANG Description: The purpose of this container is to represent
SCTP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sctp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp, is_container='container', yang_name="sctp", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sctp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sctp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp, is_container='container', yang_name="sctp", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__sctp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sctp(self):
    self.__sctp = YANGDynClass(base=yc_sctp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_sctp, is_container='container', yang_name="sctp", parent=self, choice=('layer-4', 'sctp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_dccp(self):
    """
    Getter method for dccp, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp (container)

    YANG Description: The purpose of this container is to represent
DCCP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    return self.__dccp
      
  def _set_dccp(self, v, load=False):
    """
    Setter method for dccp, mapped from YANG variable /i2nsf_security_policy/rules/condition/dccp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dccp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dccp() directly.

    YANG Description: The purpose of this container is to represent
DCCP packet header information to determine
if the set of policy actions in this ECA policy
rule should be executed or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dccp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp, is_container='container', yang_name="dccp", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dccp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dccp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp, is_container='container', yang_name="dccp", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__dccp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dccp(self):
    self.__dccp = YANGDynClass(base=yc_dccp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_dccp, is_container='container', yang_name="dccp", parent=self, choice=('layer-4', 'dccp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_icmp(self):
    """
    Getter method for icmp, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp (container)

    YANG Description: The purpose of this container is to represent
ICMPv4 and ICMPv6 packet header information to
determine if the set of policy actions in this ECA
policy rule should be executed or not.
    """
    return self.__icmp
      
  def _set_icmp(self, v, load=False):
    """
    Setter method for icmp, mapped from YANG variable /i2nsf_security_policy/rules/condition/icmp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_icmp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_icmp() directly.

    YANG Description: The purpose of this container is to represent
ICMPv4 and ICMPv6 packet header information to
determine if the set of policy actions in this ECA
policy rule should be executed or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_icmp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_icmp, is_container='container', yang_name="icmp", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """icmp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_icmp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_icmp, is_container='container', yang_name="icmp", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__icmp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_icmp(self):
    self.__icmp = YANGDynClass(base=yc_icmp_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_icmp, is_container='container', yang_name="icmp", parent=self, choice=('layer-4', 'icmp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_url_category(self):
    """
    Getter method for url_category, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category (container)

    YANG Description: Condition for url category
    """
    return self.__url_category
      
  def _set_url_category(self, v, load=False):
    """
    Setter method for url_category, mapped from YANG variable /i2nsf_security_policy/rules/condition/url_category (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url_category is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url_category() directly.

    YANG Description: Condition for url category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_url_category_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """url_category must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_url_category_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__url_category = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_url_category(self):
    self.__url_category = YANGDynClass(base=yc_url_category_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_url_category, is_container='container', yang_name="url-category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_voice(self):
    """
    Getter method for voice, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice (container)

    YANG Description: For the VoIP/VoCN security system, a VoIP/
VoCN security system can monitor each
VoIP/VoCN flow and manage VoIP/VoCN
security rules controlled by a centralized
server for VoIP/VoCN security service
(called VoIP IPS). The VoIP/VoCN security
system controls each switch for the
VoIP/VoCN call flow management by
manipulating the rules that can be added,
deleted, or modified dynamically.
    """
    return self.__voice
      
  def _set_voice(self, v, load=False):
    """
    Setter method for voice, mapped from YANG variable /i2nsf_security_policy/rules/condition/voice (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_voice is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_voice() directly.

    YANG Description: For the VoIP/VoCN security system, a VoIP/
VoCN security system can monitor each
VoIP/VoCN flow and manage VoIP/VoCN
security rules controlled by a centralized
server for VoIP/VoCN security service
(called VoIP IPS). The VoIP/VoCN security
system controls each switch for the
VoIP/VoCN call flow management by
manipulating the rules that can be added,
deleted, or modified dynamically.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_voice_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """voice must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_voice_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__voice = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_voice(self):
    self.__voice = YANGDynClass(base=yc_voice_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_voice, is_container='container', yang_name="voice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_ddos(self):
    """
    Getter method for ddos, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos (container)

    YANG Description: Condition for DDoS attack.
    """
    return self.__ddos
      
  def _set_ddos(self, v, load=False):
    """
    Setter method for ddos, mapped from YANG variable /i2nsf_security_policy/rules/condition/ddos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ddos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ddos() directly.

    YANG Description: Condition for DDoS attack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ddos_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ddos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ddos_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__ddos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ddos(self):
    self.__ddos = YANGDynClass(base=yc_ddos_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_ddos, is_container='container', yang_name="ddos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_anti_virus(self):
    """
    Getter method for anti_virus, mapped from YANG variable /i2nsf_security_policy/rules/condition/anti_virus (container)

    YANG Description: Condition for antivirus
    """
    return self.__anti_virus
      
  def _set_anti_virus(self, v, load=False):
    """
    Setter method for anti_virus, mapped from YANG variable /i2nsf_security_policy/rules/condition/anti_virus (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_anti_virus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_anti_virus() directly.

    YANG Description: Condition for antivirus
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_anti_virus_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """anti_virus must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_anti_virus_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__anti_virus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_anti_virus(self):
    self.__anti_virus = YANGDynClass(base=yc_anti_virus_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_anti_virus, is_container='container', yang_name="anti-virus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_payload(self):
    """
    Getter method for payload, mapped from YANG variable /i2nsf_security_policy/rules/condition/payload (container)

    YANG Description: Condition for packet payload
    """
    return self.__payload
      
  def _set_payload(self, v, load=False):
    """
    Setter method for payload, mapped from YANG variable /i2nsf_security_policy/rules/condition/payload (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_payload is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_payload() directly.

    YANG Description: Condition for packet payload
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_payload_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """payload must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_payload_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__payload = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_payload(self):
    self.__payload = YANGDynClass(base=yc_payload_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_payload, is_container='container', yang_name="payload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_context(self):
    """
    Getter method for context, mapped from YANG variable /i2nsf_security_policy/rules/condition/context (container)

    YANG Description: Condition for context
    """
    return self.__context
      
  def _set_context(self, v, load=False):
    """
    Setter method for context, mapped from YANG variable /i2nsf_security_policy/rules/condition/context (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_context is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_context() directly.

    YANG Description: Condition for context
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_context_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """context must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_context_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__context = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_context(self):
    self.__context = YANGDynClass(base=yc_context_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition_context, is_container='container', yang_name="context", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  layer_2 = __builtin__.property(_get_layer_2, _set_layer_2)
  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4)
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6)
  tcp = __builtin__.property(_get_tcp, _set_tcp)
  udp = __builtin__.property(_get_udp, _set_udp)
  sctp = __builtin__.property(_get_sctp, _set_sctp)
  dccp = __builtin__.property(_get_dccp, _set_dccp)
  icmp = __builtin__.property(_get_icmp, _set_icmp)
  url_category = __builtin__.property(_get_url_category, _set_url_category)
  voice = __builtin__.property(_get_voice, _set_voice)
  ddos = __builtin__.property(_get_ddos, _set_ddos)
  anti_virus = __builtin__.property(_get_anti_virus, _set_anti_virus)
  payload = __builtin__.property(_get_payload, _set_payload)
  context = __builtin__.property(_get_context, _set_context)

  __choices__ = {'layer-3': {'ipv4': ['ipv4'], 'ipv6': ['ipv6']}, 'layer-4': {'tcp': ['tcp'], 'udp': ['udp'], 'sctp': ['sctp'], 'dccp': ['dccp'], 'icmp': ['icmp']}}
  _pyangbind_elements = OrderedDict([('description', description), ('layer_2', layer_2), ('ipv4', ipv4), ('ipv6', ipv6), ('tcp', tcp), ('udp', udp), ('sctp', sctp), ('dccp', dccp), ('icmp', icmp), ('url_category', url_category), ('voice', voice), ('ddos', ddos), ('anti_virus', anti_virus), ('payload', payload), ('context', context), ])


class yc_packet_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_packet_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/action/packet-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action for packets
  """
  __slots__ = ('_path_helper', '_extmethods', '__ingress_action','__egress_action','__log_action',)

  _yang_name = 'packet-action'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ingress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__egress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'action', 'packet-action']

  def _get_ingress_action(self):
    """
    Getter method for ingress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action/ingress_action (identityref)

    YANG Description: Ingress Action: pass, drop, reject, rate-limit, and
mirror.
    """
    return self.__ingress_action
      
  def _set_ingress_action(self, v, load=False):
    """
    Setter method for ingress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action/ingress_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_action() directly.

    YANG Description: Ingress Action: pass, drop, reject, rate-limit, and
mirror.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__ingress_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_action(self):
    self.__ingress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_egress_action(self):
    """
    Getter method for egress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action/egress_action (identityref)

    YANG Description: Egress action: pass, drop, reject, rate-limit, mirror,
invoke-signaling, tunnel-encapsulation, forwarding,
redirection, and transformation.
    """
    return self.__egress_action
      
  def _set_egress_action(self, v, load=False):
    """
    Setter method for egress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action/egress_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress_action() directly.

    YANG Description: Egress action: pass, drop, reject, rate-limit, mirror,
invoke-signaling, tunnel-encapsulation, forwarding,
redirection, and transformation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__egress_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress_action(self):
    self.__egress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_log_action(self):
    """
    Getter method for log_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action/log_action (identityref)

    YANG Description: Log action: rule log and session log
    """
    return self.__log_action
      
  def _set_log_action(self, v, load=False):
    """
    Setter method for log_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action/log_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_action() directly.

    YANG Description: Log action: rule log and session log
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__log_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_action(self):
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

  ingress_action = __builtin__.property(_get_ingress_action, _set_ingress_action)
  egress_action = __builtin__.property(_get_egress_action, _set_egress_action)
  log_action = __builtin__.property(_get_log_action, _set_log_action)


  _pyangbind_elements = OrderedDict([('ingress_action', ingress_action), ('egress_action', egress_action), ('log_action', log_action), ])


class yc_flow_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_flow_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/action/flow-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action for flows
  """
  __slots__ = ('_path_helper', '_extmethods', '__ingress_action','__egress_action','__log_action',)

  _yang_name = 'flow-action'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ingress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__egress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'action', 'flow-action']

  def _get_ingress_action(self):
    """
    Getter method for ingress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action/ingress_action (identityref)

    YANG Description: Action: pass, drop, reject, rate-limit, and mirror.
    """
    return self.__ingress_action
      
  def _set_ingress_action(self, v, load=False):
    """
    Setter method for ingress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action/ingress_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_action() directly.

    YANG Description: Action: pass, drop, reject, rate-limit, and mirror.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__ingress_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_action(self):
    self.__ingress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pass': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:drop': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:reject': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:mirror': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rate-limit': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="ingress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_egress_action(self):
    """
    Getter method for egress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action/egress_action (identityref)

    YANG Description: Egress action: pass, drop, reject, rate-limit, mirror,
invoke-signaling, tunnel-encapsulation, forwarding,
redirection, and transformation.
    """
    return self.__egress_action
      
  def _set_egress_action(self, v, load=False):
    """
    Setter method for egress_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action/egress_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress_action() directly.

    YANG Description: Egress action: pass, drop, reject, rate-limit, mirror,
invoke-signaling, tunnel-encapsulation, forwarding,
redirection, and transformation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__egress_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress_action(self):
    self.__egress_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:invoke-signaling': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:tunnel-encapsulation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:forwarding': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:transformation': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="egress-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_log_action(self):
    """
    Getter method for log_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action/log_action (identityref)

    YANG Description: Log action: rule log and session log
    """
    return self.__log_action
      
  def _set_log_action(self, v, load=False):
    """
    Setter method for log_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action/log_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_action() directly.

    YANG Description: Log action: rule log and session log
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__log_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_action(self):
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:rule-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:session-log': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), is_leaf=True, yang_name="log-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

  ingress_action = __builtin__.property(_get_ingress_action, _set_ingress_action)
  egress_action = __builtin__.property(_get_egress_action, _set_egress_action)
  log_action = __builtin__.property(_get_log_action, _set_log_action)


  _pyangbind_elements = OrderedDict([('ingress_action', ingress_action), ('egress_action', egress_action), ('log_action', log_action), ])


class yc_advanced_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_advanced_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/action/advanced-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: If the packet needs to be additionally inspected,
the packet is passed to advanced network
security functions according to the profile.
The profile means the types of NSFs where the packet
will be forwarded in order to additionally
inspect the packet.
The advanced action activates Service Function
Chaining (SFC) for further inspection of a packet.
  """
  __slots__ = ('_path_helper', '_extmethods', '__content_security_control','__attack_mitigation_control',)

  _yang_name = 'advanced-action'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__content_security_control = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="content-security-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__attack_mitigation_control = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="attack-mitigation-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'action', 'advanced-action']

  def _get_content_security_control(self):
    """
    Getter method for content_security_control, mapped from YANG variable /i2nsf_security_policy/rules/action/advanced_action/content_security_control (identityref)

    YANG Description: Content-security-control is the NSFs that
inspect the payload of the packet.
The profile for the types of NSFs for mitigation is
divided into content security control and
attack-mitigation-control.
Content security control: ips, url filtering,
antivirus, and voip-vocn-filter. This can be
extended according to the provided NSFs.
    """
    return self.__content_security_control
      
  def _set_content_security_control(self, v, load=False):
    """
    Setter method for content_security_control, mapped from YANG variable /i2nsf_security_policy/rules/action/advanced_action/content_security_control (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_content_security_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_content_security_control() directly.

    YANG Description: Content-security-control is the NSFs that
inspect the payload of the packet.
The profile for the types of NSFs for mitigation is
divided into content security control and
attack-mitigation-control.
Content security control: ips, url filtering,
antivirus, and voip-vocn-filter. This can be
extended according to the provided NSFs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="content-security-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """content_security_control must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="content-security-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__content_security_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_content_security_control(self):
    self.__content_security_control = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:ips': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:url-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-virus': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:voip-vocn-filtering': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="content-security-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_attack_mitigation_control(self):
    """
    Getter method for attack_mitigation_control, mapped from YANG variable /i2nsf_security_policy/rules/action/advanced_action/attack_mitigation_control (identityref)

    YANG Description: Attack-mitigation-control is the NSFs that weaken
the attacks related to a denial-of-service (DoS)
and reconnaissance.
The profile for the types of NSFs for mitigation is
divided into content security control and
attack-mitigation-control.
Attack mitigation control: Anti-DDoS or DDoS
mitigator. This can be extended according to the
provided NSFs such as mitigators for ip sweep,
port scanning, ping of death, teardrop, oversized
icmp, and tracert.
    """
    return self.__attack_mitigation_control
      
  def _set_attack_mitigation_control(self, v, load=False):
    """
    Setter method for attack_mitigation_control, mapped from YANG variable /i2nsf_security_policy/rules/action/advanced_action/attack_mitigation_control (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attack_mitigation_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attack_mitigation_control() directly.

    YANG Description: Attack-mitigation-control is the NSFs that weaken
the attacks related to a denial-of-service (DoS)
and reconnaissance.
The profile for the types of NSFs for mitigation is
divided into content security control and
attack-mitigation-control.
Attack mitigation control: Anti-DDoS or DDoS
mitigator. This can be extended according to the
provided NSFs such as mitigators for ip sweep,
port scanning, ping of death, teardrop, oversized
icmp, and tracert.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="attack-mitigation-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attack_mitigation_control must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="attack-mitigation-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__attack_mitigation_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attack_mitigation_control(self):
    self.__attack_mitigation_control = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:anti-ddos': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},)), is_leaf=False, yang_name="attack-mitigation-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)

  content_security_control = __builtin__.property(_get_content_security_control, _set_content_security_control)
  attack_mitigation_control = __builtin__.property(_get_attack_mitigation_control, _set_attack_mitigation_control)


  _pyangbind_elements = OrderedDict([('content_security_control', content_security_control), ('attack_mitigation_control', attack_mitigation_control), ])


class yc_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules/action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An action is used to control and monitor aspects of
flow-based NSFs when the event and condition clauses
are satisfied. NSFs provide security functions by
executing various Actions. Examples of I2NSF Actions
include providing intrusion detection and/or protection,
web and flow filtering, and deep packet inspection
for packets and flows.
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__packet_action','__flow_action','__advanced_action',)

  _yang_name = 'action'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__packet_action = YANGDynClass(base=yc_packet_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_packet_action, is_container='container', yang_name="packet-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__flow_action = YANGDynClass(base=yc_flow_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_flow_action, is_container='container', yang_name="flow-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__advanced_action = YANGDynClass(base=yc_advanced_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_advanced_action, is_container='container', yang_name="advanced-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules', 'action']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/action/description (string)

    YANG Description: Description for an action clause.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/action/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for an action clause.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_packet_action(self):
    """
    Getter method for packet_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action (container)

    YANG Description: Action for packets
    """
    return self.__packet_action
      
  def _set_packet_action(self, v, load=False):
    """
    Setter method for packet_action, mapped from YANG variable /i2nsf_security_policy/rules/action/packet_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_action() directly.

    YANG Description: Action for packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_packet_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_packet_action, is_container='container', yang_name="packet-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_packet_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_packet_action, is_container='container', yang_name="packet-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__packet_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_action(self):
    self.__packet_action = YANGDynClass(base=yc_packet_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_packet_action, is_container='container', yang_name="packet-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_flow_action(self):
    """
    Getter method for flow_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action (container)

    YANG Description: Action for flows
    """
    return self.__flow_action
      
  def _set_flow_action(self, v, load=False):
    """
    Setter method for flow_action, mapped from YANG variable /i2nsf_security_policy/rules/action/flow_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_action() directly.

    YANG Description: Action for flows
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_flow_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_flow_action, is_container='container', yang_name="flow-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_flow_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_flow_action, is_container='container', yang_name="flow-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__flow_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_action(self):
    self.__flow_action = YANGDynClass(base=yc_flow_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_flow_action, is_container='container', yang_name="flow-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_advanced_action(self):
    """
    Getter method for advanced_action, mapped from YANG variable /i2nsf_security_policy/rules/action/advanced_action (container)

    YANG Description: If the packet needs to be additionally inspected,
the packet is passed to advanced network
security functions according to the profile.
The profile means the types of NSFs where the packet
will be forwarded in order to additionally
inspect the packet.
The advanced action activates Service Function
Chaining (SFC) for further inspection of a packet.
    """
    return self.__advanced_action
      
  def _set_advanced_action(self, v, load=False):
    """
    Setter method for advanced_action, mapped from YANG variable /i2nsf_security_policy/rules/action/advanced_action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advanced_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advanced_action() directly.

    YANG Description: If the packet needs to be additionally inspected,
the packet is passed to advanced network
security functions according to the profile.
The profile means the types of NSFs where the packet
will be forwarded in order to additionally
inspect the packet.
The advanced action activates Service Function
Chaining (SFC) for further inspection of a packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_advanced_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_advanced_action, is_container='container', yang_name="advanced-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advanced_action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_advanced_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_advanced_action, is_container='container', yang_name="advanced-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__advanced_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advanced_action(self):
    self.__advanced_action = YANGDynClass(base=yc_advanced_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action_advanced_action, is_container='container', yang_name="advanced-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  packet_action = __builtin__.property(_get_packet_action, _set_packet_action)
  flow_action = __builtin__.property(_get_flow_action, _set_flow_action)
  advanced_action = __builtin__.property(_get_advanced_action, _set_advanced_action)


  _pyangbind_elements = OrderedDict([('description', description), ('packet_action', packet_action), ('flow_action', flow_action), ('advanced_action', advanced_action), ])


class yc_rules_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rules. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This is a rule for network security functions.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__priority','__enable','__long_connection','__event','__condition','__action',)

  _yang_name = 'rules'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)
    self.__long_connection = YANGDynClass(base=yc_long_connection_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_long_connection, is_container='container', yang_name="long-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__event = YANGDynClass(base=yc_event_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__condition = YANGDynClass(base=yc_condition_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    self.__action = YANGDynClass(base=yc_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rules']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_security_policy/rules/name (string)

    YANG Description: The name of the rule.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_security_policy/rules/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rules/description (string)

    YANG Description: This description gives more information about
rules.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rules/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This description gives more information about
rules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /i2nsf_security_policy/rules/priority (uint8)

    YANG Description: The priority for the rule comes with a mandatory
numeric value which can range from 1 up to 255.
Note that a higher number means a higher priority
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /i2nsf_security_policy/rules/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: The priority for the rule comes with a mandatory
numeric value which can range from 1 up to 255.
Note that a higher number means a higher priority
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='uint8', is_config=True)


  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /i2nsf_security_policy/rules/enable (boolean)

    YANG Description: If true, the rule is enabled and enforced.
If false, the rule is configured but disabled and not
enforced.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /i2nsf_security_policy/rules/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: If true, the rule is enabled and enforced.
If false, the rule is configured but disabled and not
enforced.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)


  def _get_long_connection(self):
    """
    Getter method for long_connection, mapped from YANG variable /i2nsf_security_policy/rules/long_connection (container)

    YANG Description: A container for long connection. A long connection is a
connection that is maintained after the socket connection
is established, regardless of whether it is used for data
traffic or not.
    """
    return self.__long_connection
      
  def _set_long_connection(self, v, load=False):
    """
    Setter method for long_connection, mapped from YANG variable /i2nsf_security_policy/rules/long_connection (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_long_connection is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_long_connection() directly.

    YANG Description: A container for long connection. A long connection is a
connection that is maintained after the socket connection
is established, regardless of whether it is used for data
traffic or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_long_connection_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_long_connection, is_container='container', yang_name="long-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """long_connection must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_long_connection_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_long_connection, is_container='container', yang_name="long-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__long_connection = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_long_connection(self):
    self.__long_connection = YANGDynClass(base=yc_long_connection_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_long_connection, is_container='container', yang_name="long-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_event(self):
    """
    Getter method for event, mapped from YANG variable /i2nsf_security_policy/rules/event (container)

    YANG Description: An event is defined as any important
occurrence in time of a change in the system being
managed, and/or in the environment of the system being
managed. When used in the context of policy rules for
a flow-based NSF, it is used to determine whether the
Condition clause of the Policy Rule can be evaluated
or not. Examples of an I2NSF event include time and
user actions (e.g., logon, logoff, and actions that
violate any ACL.).
    """
    return self.__event
      
  def _set_event(self, v, load=False):
    """
    Setter method for event, mapped from YANG variable /i2nsf_security_policy/rules/event (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event() directly.

    YANG Description: An event is defined as any important
occurrence in time of a change in the system being
managed, and/or in the environment of the system being
managed. When used in the context of policy rules for
a flow-based NSF, it is used to determine whether the
Condition clause of the Policy Rule can be evaluated
or not. Examples of an I2NSF event include time and
user actions (e.g., logon, logoff, and actions that
violate any ACL.).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_event_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_event_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event(self):
    self.__event = YANGDynClass(base=yc_event_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_event, is_container='container', yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_condition(self):
    """
    Getter method for condition, mapped from YANG variable /i2nsf_security_policy/rules/condition (container)

    YANG Description: A condition is defined as a set
of attributes, features, and/or values that are to be
compared with a set of known attributes, features,
and/or values in order to determine whether the
set of Actions in that (imperative) I2NSF Policy Rule
can be executed or not. Examples of I2NSF Conditions
include matching attributes of a packet or flow, and
comparing the internal state of an NSF to a desired
state.
The condition works with 'AND' logic, where all
fields set in a condition MUST match the packet or flow
for the condition to be evaluated as 'TRUE'
    """
    return self.__condition
      
  def _set_condition(self, v, load=False):
    """
    Setter method for condition, mapped from YANG variable /i2nsf_security_policy/rules/condition (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_condition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_condition() directly.

    YANG Description: A condition is defined as a set
of attributes, features, and/or values that are to be
compared with a set of known attributes, features,
and/or values in order to determine whether the
set of Actions in that (imperative) I2NSF Policy Rule
can be executed or not. Examples of I2NSF Conditions
include matching attributes of a packet or flow, and
comparing the internal state of an NSF to a desired
state.
The condition works with 'AND' logic, where all
fields set in a condition MUST match the packet or flow
for the condition to be evaluated as 'TRUE'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_condition_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """condition must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_condition_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__condition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_condition(self):
    self.__condition = YANGDynClass(base=yc_condition_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_condition, is_container='container', yang_name="condition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /i2nsf_security_policy/rules/action (container)

    YANG Description: An action is used to control and monitor aspects of
flow-based NSFs when the event and condition clauses
are satisfied. NSFs provide security functions by
executing various Actions. Examples of I2NSF Actions
include providing intrusion detection and/or protection,
web and flow filtering, and deep packet inspection
for packets and flows.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /i2nsf_security_policy/rules/action (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: An action is used to control and monitor aspects of
flow-based NSFs when the event and condition clauses
are satisfied. NSFs provide security functions by
executing various Actions. Examples of I2NSF Actions
include providing intrusion detection and/or protection,
web and flow filtering, and deep packet inspection
for packets and flows.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=yc_action_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules_action, is_container='container', yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  priority = __builtin__.property(_get_priority, _set_priority)
  enable = __builtin__.property(_get_enable, _set_enable)
  long_connection = __builtin__.property(_get_long_connection, _set_long_connection)
  event = __builtin__.property(_get_event, _set_event)
  condition = __builtin__.property(_get_condition, _set_condition)
  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('priority', priority), ('enable', enable), ('long_connection', long_connection), ('event', event), ('condition', condition), ('action', action), ])


class yc_groups_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rule-group/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This is a group for rules
  """
  __slots__ = ('_path_helper', '_extmethods', '__group_name','__rule_name','__enable','__description',)

  _yang_name = 'groups'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__group_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__rule_name = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="rule-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='leafref', is_config=True)
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rule-group', 'groups']

  def _get_group_name(self):
    """
    Getter method for group_name, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/group_name (string)

    YANG Description: This is the name of the group for rules
    """
    return self.__group_name
      
  def _set_group_name(self, v, load=False):
    """
    Setter method for group_name, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/group_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_name() directly.

    YANG Description: This is the name of the group for rules
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__group_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_name(self):
    self.__group_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_rule_name(self):
    """
    Getter method for rule_name, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/rule_name (leafref)

    YANG Description: The names of the rules to be grouped.
    """
    return self.__rule_name
      
  def _set_rule_name(self, v, load=False):
    """
    Setter method for rule_name, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/rule_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_name() directly.

    YANG Description: The names of the rules to be grouped.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="rule-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="rule-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='leafref', is_config=True)""",
        })

    self.__rule_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_name(self):
    self.__rule_name = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="rule-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='leafref', is_config=True)


  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/enable (boolean)

    YANG Description: If true, the rule is enabled and enforced.
If false, the rule is configured but disabled
and not enforced.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: If true, the rule is enabled and enforced.
If false, the rule is configured but disabled
and not enforced.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='boolean', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/description (string)

    YANG Description: This is a description for rule-group
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /i2nsf_security_policy/rule_group/groups/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: This is a description for rule-group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)

  group_name = __builtin__.property(_get_group_name, _set_group_name)
  rule_name = __builtin__.property(_get_rule_name, _set_rule_name)
  enable = __builtin__.property(_get_enable, _set_enable)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('group_name', group_name), ('rule_name', rule_name), ('enable', enable), ('description', description), ])


class yc_rule_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy/rule-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This is rule group
  """
  __slots__ = ('_path_helper', '_extmethods', '__groups',)

  _yang_name = 'rule-group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__groups = YANGDynClass(base=YANGListType("group_name",yc_groups_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy', 'rule-group']

  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /i2nsf_security_policy/rule_group/groups (list)

    YANG Description: This is a group for rules
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /i2nsf_security_policy/rule_group/groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.

    YANG Description: This is a group for rules
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("group_name",yc_groups_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("group_name",yc_groups_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=YANGListType("group_name",yc_groups_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  groups = __builtin__.property(_get_groups, _set_groups)


  _pyangbind_elements = OrderedDict([('groups', groups), ])


class yc_i2nsf_security_policy_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /i2nsf-security-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for security policy
including a set of security rules according to certain logic,
i.e., their similarity or mutual relations, etc. The network
security policy can be applied to both the unidirectional
and bidirectional traffic across the NSF.
The I2NSF security policies use the Event-Condition-Action
(ECA) policy model 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__language','__priority_usage','__resolution_strategy','__default_action','__rules','__rule_group',)

  _yang_name = 'i2nsf-security-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__language = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WYZa-wyz](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    self.__priority_usage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("priority-by-order"), is_leaf=True, yang_name="priority-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__resolution_strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__default_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), default=six.text_type("mirror"), is_leaf=True, yang_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    self.__rules = YANGDynClass(base=YANGListType("name",yc_rules_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    self.__rule_group = YANGDynClass(base=yc_rule_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group, is_container='container', yang_name="rule-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['i2nsf-security-policy']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /i2nsf_security_policy/name (string)

    YANG Description: The name of the security policy.
This must be unique.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /i2nsf_security_policy/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the security policy.
This must be unique.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_language(self):
    """
    Getter method for language, mapped from YANG variable /i2nsf_security_policy/language (string)

    YANG Description: The value in this field indicates the language tag
used for all of the 'leaf description' described in the
'i2nsf-security-policy'. This field is mandatory only when
one or more of the 'leaf description' is used.

The attribute is encoded following the rules in Section 2.1
in RFC 5646. The default language tag is 'en-US'
    """
    return self.__language
      
  def _set_language(self, v, load=False):
    """
    Setter method for language, mapped from YANG variable /i2nsf_security_policy/language (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_language is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_language() directly.

    YANG Description: The value in this field indicates the language tag
used for all of the 'leaf description' described in the
'i2nsf-security-policy'. This field is mandatory only when
one or more of the 'leaf description' is used.

The attribute is encoded following the rules in Section 2.1
in RFC 5646. The default language tag is 'en-US'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WYZa-wyz](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """language must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WYZa-wyz](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)""",
        })

    self.__language = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_language(self):
    self.__language = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|([0-9][A-Za-z0-9]{3})))*(-[0-9A-WYZa-wyz](-([A-Za-z0-9]{2,8}))+)*(-[Xx](-([A-Za-z0-9]{1,8}))+)?|[Xx](-([A-Za-z0-9]{1,8}))+|(([Ee][Nn]-[Gg][Bb]-[Oo][Ee][Dd]|[Ii]-[Aa][Mm][Ii]|[Ii]-[Bb][Nn][Nn]|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Ee][Nn][Oo][Cc][Hh][Ii][Aa][Nn]|[Ii]-[Hh][Aa][Kk]|[Ii]-[Kk][Ll][Ii][Nn][Gg][Oo][Nn]|[Ii]-[Ll][Uu][Xx]|[Ii]-[Mm][Ii][Nn][Gg][Oo]|[Ii]-[Nn][Aa][Vv][Aa][Jj][Oo]|[Ii]-[Pp][Ww][Nn]|[Ii]-[Tt][Aa][Oo]|[Ii]-[Tt][Aa][Yy]|[Ii]-[Tt][Ss][Uu]|[Ss][Gg][Nn]-[Bb][Ee]-[Ff][Rr]|[Ss][Gg][Nn]-[Bb][Ee]-[Nn][Ll]|[Ss][Gg][Nn]-[Cc][Hh]-[Dd][Ee])|([Aa][Rr][Tt]-[Ll][Oo][Jj][Bb][Aa][Nn]|[Cc][Ee][Ll]-[Gg][Aa][Uu][Ll][Ii][Ss][Hh]|[Nn][Oo]-[Bb][Oo][Kk]|[Nn][Oo]-[Nn][Yy][Nn]|[Zz][Hh]-[Gg][Uu][Oo][Yy][Uu]|[Zz][Hh]-[Hh][Aa][Kk][Kk][Aa]|[Zz][Hh]-[Mm][Ii][Nn]|[Zz][Hh]-[Mm][Ii][Nn]-[Nn][Aa][Nn]|[Zz][Hh]-[Xx][Ii][Aa][Nn][Gg])))'}), default=six.text_type("en-US"), is_leaf=True, yang_name="language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='string', is_config=True)


  def _get_priority_usage(self):
    """
    Getter method for priority_usage, mapped from YANG variable /i2nsf_security_policy/priority_usage (identityref)

    YANG Description: Priority usage type for security policy rule:
priority by order and priority by number
    """
    return self.__priority_usage
      
  def _set_priority_usage(self, v, load=False):
    """
    Setter method for priority_usage, mapped from YANG variable /i2nsf_security_policy/priority_usage (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_usage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_usage() directly.

    YANG Description: Priority usage type for security policy rule:
priority by order and priority by number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("priority-by-order"), is_leaf=True, yang_name="priority-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_usage must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("priority-by-order"), is_leaf=True, yang_name="priority-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__priority_usage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_usage(self):
    self.__priority_usage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-order': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:priority-by-number': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("priority-by-order"), is_leaf=True, yang_name="priority-usage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_resolution_strategy(self):
    """
    Getter method for resolution_strategy, mapped from YANG variable /i2nsf_security_policy/resolution_strategy (identityref)

    YANG Description: The resolution strategies that can be used to
specify how to resolve conflicts that occur between
actions of the same or different policy rules that
are matched and contained in this particular NSF
    """
    return self.__resolution_strategy
      
  def _set_resolution_strategy(self, v, load=False):
    """
    Setter method for resolution_strategy, mapped from YANG variable /i2nsf_security_policy/resolution_strategy (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resolution_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resolution_strategy() directly.

    YANG Description: The resolution strategies that can be used to
specify how to resolve conflicts that occur between
actions of the same or different policy rules that
are matched and contained in this particular NSF
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resolution_strategy must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__resolution_strategy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resolution_strategy(self):
    self.__resolution_strategy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:fmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:lmr': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmre': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}, 'i2nsfnfi:pmrn': {'@module': 'ietf-i2nsf-nsf-facing-interface', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'}},), default=six.text_type("fmr"), is_leaf=True, yang_name="resolution-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_default_action(self):
    """
    Getter method for default_action, mapped from YANG variable /i2nsf_security_policy/default_action (identityref)

    YANG Description: This default action can be used to specify a predefined
action when no other alternative action was matched
by the currently executing I2NSF Policy Rule. An analogy
is the use of a default statement in a C switch statement.
    """
    return self.__default_action
      
  def _set_default_action(self, v, load=False):
    """
    Setter method for default_action, mapped from YANG variable /i2nsf_security_policy/default_action (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_action() directly.

    YANG Description: This default action can be used to specify a predefined
action when no other alternative action was matched
by the currently executing I2NSF Policy Rule. An analogy
is the use of a default statement in a C switch statement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), default=six.text_type("mirror"), is_leaf=True, yang_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_action must be of a type compatible with identityref""",
          'defined-type': "ietf-i2nsf-nsf-facing-interface:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), default=six.text_type("mirror"), is_leaf=True, yang_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)""",
        })

    self.__default_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_action(self):
    self.__default_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), default=six.text_type("mirror"), is_leaf=True, yang_name="default-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='identityref', is_config=True)


  def _get_rules(self):
    """
    Getter method for rules, mapped from YANG variable /i2nsf_security_policy/rules (list)

    YANG Description: This is a rule for network security functions.
    """
    return self.__rules
      
  def _set_rules(self, v, load=False):
    """
    Setter method for rules, mapped from YANG variable /i2nsf_security_policy/rules (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rules() directly.

    YANG Description: This is a rule for network security functions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rules_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rules must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rules_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__rules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rules(self):
    self.__rules = YANGDynClass(base=YANGListType("name",yc_rules_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rules, yang_name="rules", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)


  def _get_rule_group(self):
    """
    Getter method for rule_group, mapped from YANG variable /i2nsf_security_policy/rule_group (container)

    YANG Description: This is rule group
    """
    return self.__rule_group
      
  def _set_rule_group(self, v, load=False):
    """
    Setter method for rule_group, mapped from YANG variable /i2nsf_security_policy/rule_group (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_group() directly.

    YANG Description: This is rule group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rule_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group, is_container='container', yang_name="rule-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_group must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rule_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group, is_container='container', yang_name="rule-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)""",
        })

    self.__rule_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_group(self):
    self.__rule_group = YANGDynClass(base=yc_rule_group_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy_rule_group, is_container='container', yang_name="rule-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  language = __builtin__.property(_get_language, _set_language)
  priority_usage = __builtin__.property(_get_priority_usage, _set_priority_usage)
  resolution_strategy = __builtin__.property(_get_resolution_strategy, _set_resolution_strategy)
  default_action = __builtin__.property(_get_default_action, _set_default_action)
  rules = __builtin__.property(_get_rules, _set_rules)
  rule_group = __builtin__.property(_get_rule_group, _set_rule_group)


  _pyangbind_elements = OrderedDict([('name', name), ('language', language), ('priority_usage', priority_usage), ('resolution_strategy', resolution_strategy), ('default_action', default_action), ('rules', rules), ('rule_group', rule_group), ])


class ietf_i2nsf_nsf_facing_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-nsf-facing-interface - based on the path /ietf-i2nsf-nsf-facing-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is a YANG module for Network Security Functions
(NSF)-Facing Interface.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this
document are to be interpreted as described in BCP 14
(RFC 2119) (RFC 8174) when, and only when, they appear
in all capitals, as shown here.

Copyright (c) 2022 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Revised BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__i2nsf_security_policy',)

  _yang_name = 'ietf-i2nsf-nsf-facing-interface'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__i2nsf_security_policy = YANGDynClass(base=YANGListType("name",yc_i2nsf_security_policy_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy, yang_name="i2nsf-security-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="i2nsf-security-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_i2nsf_security_policy(self):
    """
    Getter method for i2nsf_security_policy, mapped from YANG variable /i2nsf_security_policy (list)

    YANG Description: Container for security policy
including a set of security rules according to certain logic,
i.e., their similarity or mutual relations, etc. The network
security policy can be applied to both the unidirectional
and bidirectional traffic across the NSF.
The I2NSF security policies use the Event-Condition-Action
(ECA) policy model 
    """
    return self.__i2nsf_security_policy
      
  def _set_i2nsf_security_policy(self, v, load=False):
    """
    Setter method for i2nsf_security_policy, mapped from YANG variable /i2nsf_security_policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_i2nsf_security_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_i2nsf_security_policy() directly.

    YANG Description: Container for security policy
including a set of security rules according to certain logic,
i.e., their similarity or mutual relations, etc. The network
security policy can be applied to both the unidirectional
and bidirectional traffic across the NSF.
The I2NSF security policies use the Event-Condition-Action
(ECA) policy model 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_i2nsf_security_policy_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy, yang_name="i2nsf-security-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="i2nsf-security-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """i2nsf_security_policy must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_i2nsf_security_policy_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy, yang_name="i2nsf-security-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="i2nsf-security-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)""",
        })

    self.__i2nsf_security_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_i2nsf_security_policy(self):
    self.__i2nsf_security_policy = YANGDynClass(base=YANGListType("name",yc_i2nsf_security_policy_ietf_i2nsf_nsf_facing_interface__i2nsf_security_policy, yang_name="i2nsf-security-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="i2nsf-security-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-nsf-facing-interface', defining_module='ietf-i2nsf-nsf-facing-interface', yang_type='list', is_config=True)

  i2nsf_security_policy = __builtin__.property(_get_i2nsf_security_policy, _set_i2nsf_security_policy)


  _pyangbind_elements = OrderedDict([('i2nsf_security_policy', i2nsf_security_policy), ])


