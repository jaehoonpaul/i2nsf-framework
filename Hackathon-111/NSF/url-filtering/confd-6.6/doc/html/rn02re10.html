<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>confd_lib_dp</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="ConfD User Guide"><link rel="up" href="rn02.html" title="ConfD man-pages, Volume 3"><link rel="prev" href="rn02re09.html" title="confd_lib_cdb"><link rel="next" href="rn02re11.html" title="confd_lib_events"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">confd_lib_dp</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="rn02re09.html">Prev</a>&nbsp;</td><th width="60%" align="center">ConfD man-pages, Volume 3</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="rn02re11.html">Next</a></td></tr></table><hr></div><div class="refentry"><a name="man.3.confd_lib_dp"></a><div class="titlepage"></div><div class="refnamediv"><a name="man.3.confd_lib_dp.name"></a><h2>Name</h2><p>confd_lib_dp &#8212; callback library for connecting data providers to ConfD</p></div><div class="refsynopsisdiv"><a name="man.3.confd_lib_dp.synopsis"></a><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;confd_lib.h&gt;
#include &lt;confd_dp.h&gt;
      </pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">struct confd_daemon_ctx *<b class="fsfunc">confd_init_daemon</b>(</code></td><td>const char *<var class="pdparam">name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_set_daemon_flags</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_release_daemon</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_connect</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_sock_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>const struct sockaddr *<var class="pdparam">srv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">addrsz</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_trans_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_trans_cbs *<var class="pdparam">trans</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_db_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_db_cbs *<var class="pdparam">dbcbs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int  <b class="fsfunc">confd_register_range_data_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_data_cbs *<var class="pdparam">data</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">lower</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">upper</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">numkeys</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_data_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_data_cbs *<var class="pdparam">data</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_usess_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_usess_cbs *<var class="pdparam">ucb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ncs_register_service_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct ncs_service_cbs *<var class="pdparam">scb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ncs_register_nano_service_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">component_type</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">state</var>, </td></tr><tr><td>&nbsp;</td><td>const struct ncs_nano_service_cbs *<var class="pdparam">scb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_done</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_fd_ready</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">fd</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_trans_set_fd</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_value</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">v</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_value_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">vs</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_tag_value_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">tvs</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_key</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_vals_in_key</var>, </td></tr><tr><td>&nbsp;</td><td>long <var class="pdparam">next</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_not_found</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_found</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>long <var class="pdparam">next</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_tag_value_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">tv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>long <var class="pdparam">next</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_arrays</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_next_object *<var class="pdparam">obj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nobj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_millisecs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_tag_value_arrays</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_tag_next_object *<var class="pdparam">tobj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nobj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_millisecs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_attrs</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_attr_value_t *<var class="pdparam">attrs</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_attrs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ncs_service_reply_proplist</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct ncs_name_value *<var class="pdparam">proplist</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_props</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ncs_nano_service_reply_proplist</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct ncs_name_value *<var class="pdparam">proplist</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_props</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_delayed_reply_ok</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_delayed_reply_error</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">errstr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_set_timeout</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_trans_seterr</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_trans_seterr_extended</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_trans_seterr_extended_info</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_db_seterr</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_db_seterr_extended</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_db_seterr_extended_info</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_db_set_timeout</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_aaa_reload</b>(</code></td><td>const struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_install_crypto_keys</b>(</code></td><td>struct confd_daemon_ctx* <var class="pdparam">dtx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_register_trans_validate_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_trans_validate_cbs *<var class="pdparam">vcbs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_valpoint_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_valpoint_cb *<var class="pdparam">vcb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_range_valpoint_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_valpoint_cb *<var class="pdparam">vcb</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">lower</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">upper</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">numkeys</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_delayed_reply_validation_warn</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_action_cbs</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_action_cbs *<var class="pdparam">acb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_range_action_cbs</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_action_cbs *<var class="pdparam">acb</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">lower</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">upper</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">numkeys</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_action_set_fd</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_action_seterr</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_action_seterr_extended</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_seterr_extended_info</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_values</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_command</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_rewrite</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">unhides</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nunhides</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_rewrite2</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">unhides</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nunhides</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_rewrite_select **<var class="pdparam">selects</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nselects</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_completion</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_completion_value *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_range_enum</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">keysize</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nkeys</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_delayed_reply_ok</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_delayed_reply_error</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">errstr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_set_timeout</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_notification_stream</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_notification_stream_cbs *<var class="pdparam">ncbs</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_notification_ctx **<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_send</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">time</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_replay_complete</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_replay_failed</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_reply_log_times</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">creation</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">aged</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_set_fd</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">fd</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_set_snmp_src_addr</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_ip *<var class="pdparam">src_addr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_set_snmp_notify_name</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notify_name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_seterr</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_seterr_extended</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_seterr_extended_info</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_snmp_notification</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notify_name</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">ctx_name</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_notification_ctx **<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_send_snmp</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notification</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_snmp_varbind *<var class="pdparam">varbinds</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_vars</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_notification_snmp_inform_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_notification_snmp_inform_cbs *<var class="pdparam">cb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_send_snmp_inform</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notification</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_snmp_varbind *<var class="pdparam">varbinds</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_vars</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">cb_id</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">ref</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_notification_sub_snmp_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_notification_sub_snmp_cb *<var class="pdparam">cb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_flush</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_auth_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_auth_cb *<var class="pdparam">acb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_auth_seterr</b>(</code></td><td>struct confd_auth_ctx *<var class="pdparam">actx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_authorization_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_authorization_cbs *<var class="pdparam">acb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_access_reply_result</b>(</code></td><td>struct confd_authorization_ctx *<var class="pdparam">actx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">result</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_authorization_set_timeout</b>(</code></td><td>struct confd_authorization_ctx *<var class="pdparam">actx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_error_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_error_cb *<var class="pdparam">ecb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_error_seterr</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1"><a name="man.3.confd_lib_dp.library"></a><h2>LIBRARY</h2><p>ConfD Library, (<code class="filename">libconfd</code>, <code class="option">-lconfd</code>)</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.description"></a><h2>DESCRIPTION</h2><p>The <code class="filename">libconfd</code> shared library is used to
    connect to the ConfD Data Provider API. The purpose of this API is
    to provide callback hooks so that user-written data providers can
    provide data stored externally to ConfD. ConfD needs this
    information in order to drive its northbound agents.</p><p>The library is also used to populate items in the data model
    which are not data or configuration items, such as statistics items
    from the device.</p><p>The library consists of a number of API functions whose
    purpose is to install different callback functions at different
    points in the data model tree which is the representation of the device
    configuration. Read more about callpoints in <a class="link" href="rn03re20.html" title="tailf_yang_extensions">tailf_yang_extensions(5)</a>. Read more about how to use the
    library in the User Guide chapters on Operational data and External
    data.</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.functions"></a><h2>FUNCTIONS</h2><div class="funcsynopsis"><a name="fn.confd_init_daemon"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">struct confd_daemon_ctx *<b class="fsfunc">confd_init_daemon</b>(</code></td><td>const char *<var class="pdparam">name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Initializes a new daemon context or returns NULL on failure.
    For most of the library functions described here a daemon_ctx is
    required, so we must create a daemon context before we can use
    them.  The daemon context contains a <span class="type">d_opaque</span> pointer
    which can be used by the application to pass application specific
    data into the callback functions.</p><p>The <em class="parameter"><code>name</code></em> parameter is used in
    various debug printouts and and is also used to uniquely
    identify the daemon. The <span class="command"><strong>confd -<span class="phrase">-</span>status</strong></span>
    will use this name when indicating which callpoints are
    registered.</p><p><span class="emphasis"><em>Errors</em></span>:
    CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_PROTOUSAGE
    </p><div class="funcsynopsis"><a name="fn.confd_set_daemon_flags"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_set_daemon_flags</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function modifies the API behaviour according to the
    flags ORed into the <em class="parameter"><code>flags</code></em> argument. It should
    be called immediately after creating the daemon context with
    <code class="function">confd_init_daemon()</code>. The following flags are
    available:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_DAEMON_FLAG_STRINGSONLY</code></span></dt><dd><p>If this flag is used, the callback functions described
          below will only receive string values for all instances of
          <span class="type">confd_value_t</span> (i.e. the type is always
          <span class="type">C_BUF</span>). The callbacks must also give only string
          values in their reply functions. This feature can be useful
          for proxy-type applications that are unaware of the types of
          all elements, i.e. data model agnostic.</p></dd><dt><span class="term"><code class="constant">CONFD_DAEMON_FLAG_REG_REPLACE_DISCONNECT</code></span></dt><dd><p>By default, if one daemon replaces a callpoint
          registration made by another daemon, this is only logged, and
          no action is taken towards the daemon that has "lost" its
          registration. This can be useful in some scenarios, e.g. it is
          possible to have an "initial default" daemon providing "null"
          data for many callpoints, until the actual data provider
          daemons have registered. If a daemon uses the
          <code class="constant">CONFD_DAEMON_FLAG_REG_REPLACE_DISCONNECT</code>
          flag, it will instead be disconnected from ConfD if any of its
          registrations are replaced by another daemon, and can take
          action as appropriate.</p></dd><dt><span class="term"><code class="constant">CONFD_DAEMON_FLAG_NO_DEFAULTS</code></span></dt><dd><p>This flag tells ConfD that the daemon does not store
          default values. By default, ConfD assumes that the daemon
          doesn't know about default values, and thus whenever default
          values come into effect, ConfD will issue
          <code class="function">set_elem()</code> callbacks to set those values,
          even if they have not actually been set by the northbound
          agent. Similarly <code class="function">set_case()</code> will be
          issued with the default case for choices that have one.</p><p>When the
          <code class="constant">CONFD_DAEMON_FLAG_NO_DEFAULTS</code> flag is
          set, ConfD will only issue <code class="function">set_elem()</code>
          callbacks when values have been explicitly set, and
          <code class="function">set_case()</code> when a case has been selected
          by explicitly setting an element in the
          case. Specifically:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>When a list entry or presence container is created,
              there will be no callbacks for descendant leafs with
              default value, or descendant choices with default case,
              unless values have been explicitly set.</p></li><li class="listitem"><p>When a leaf with a default value is deleted,
              a <code class="function">remove()</code> callback will be issued
              instead of a <code class="function">set_elem()</code> with the
              default value.</p></li><li class="listitem"><p>When the current case in a choice with
              default case is deleted without another case being
              selected, the <code class="function">set_case()</code>
              callback will be invoked with the case value given as NULL
               instead of the default case.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A daemon that has the
          <code class="constant">CONFD_DAEMON_FLAG_NO_DEFAULTS</code> flag set
          <span class="emphasis"><em>must</em></span> reply to
          <code class="function">get_elem()</code> and the other callbacks that
          request leaf values with a value of type C_DEFAULT, rather
          than the actual default value, when the default value for a
          leaf is in effect. It <span class="emphasis"><em>must</em></span> also reply to
          <code class="function">get_case()</code> with C_DEFAULT when the
          default case is in effect.</p></div></dd><dt><span class="term"><code class="constant">CONFD_DAEMON_FLAG_PREFER_BULK_GET</code></span></dt><dd><p>This flag requests that the
          <code class="function">get_object()</code> callback rather than
          <code class="function">get_elem()</code> should be used whenever
          possible, regardless of whether a "bulk hint" is given by the
          northbound agent. If <code class="function">get_elem()</code> is not
          registered, the flag is not useful (it has no effect -
          <code class="function">get_object()</code> is always used anyway), but
          in cases where the callpoint also covers leafs that cannot be
          retrieved with <code class="function">get_object()</code>, the daemon
          <span class="emphasis"><em>must</em></span> register
          <code class="function">get_elem()</code>.</p></dd><dt><span class="term"><code class="constant">CONFD_DAEMON_FLAG_BULK_GET_CONTAINER</code></span></dt><dd><p>This flag tells ConfD that the data provider is prepared
          to handle a <code class="function">get_object()</code> callback
          invocation for the toplevel ancestor container when a leaf is
          requested by a northbound agent, if there exists no ancestor
          list node but there exists such a container. If this flag is
          not set, <code class="function">get_object()</code> is only invoked for
          list entries, and <code class="function">get_elem()</code> is always
          used for leafs that do not have an ancestor list node. If both
          <code class="function">get_object()</code> and
          <code class="function">get_elem()</code> are registered, the choice
          between them is made as for list entries, i.e. based on a
          "bulk hint" from the northbound agent unless the flag
          <code class="constant">CONFD_DAEMON_FLAG_PREFER_BULK_GET</code> is also
          set (see above).</p></dd><dt><span class="term"><code class="constant">CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF</code></span></dt><dd><p>This flag requests that data provider and transform
          callbacks should treat leaf-lists as leafs and not as lists,
          e.g. use <code class="function">get_elem()</code> /
          <code class="function">set_elem()</code> rather than
          <code class="function">get_next()</code> /
          <code class="function">create()</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This flag is deprecated, and only present for
          temporary backward compatibility - it will be removed in a
          future release.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This flag is not supported for hooks, i.e. hook
          callbacks will always treat leaf-lists as lists - if the flag
          is set for a hook, it will cause an error on callback
          invocation for a leaf-list.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This flag has no effect for validation callbacks -
          however just as for a list, a <code class="code">tailf:validate</code>
          statement for a leaf-list may use a
          <code class="code">tailf:call-once</code> substatement to request a single
          invocation for validation of the whole leaf-list.</p></div></dd></dl></div><div class="funcsynopsis"><a name="fn.confd_release_daemon"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_release_daemon</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Returns all memory that has been allocated by
    <code class="function">confd_init_daemon()</code> and other functions for
    the daemon context. The control socket as well as all the worker
    sockets must be closed by the application (before or after
    <code class="function">confd_release_daemon()</code> has been called).</p><div class="funcsynopsis"><a name="fn.confd_connect"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_connect</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_sock_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>const struct sockaddr *<var class="pdparam">srv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">addrsz</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Connects to the ConfD daemon. The <em class="parameter"><code>dx</code></em>
    parameter is a daemon context acquired through a call to
    <code class="function">confd_init_daemon()</code>.</p><p>There are two different types of connected sockets between
    an external daemon and ConfD.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONTROL_SOCKET</code></span></dt><dd><p>The first socket that is connected must always be a
          control socket. All requests from ConfD to create new
          transactions will arrive on the control socket, but it is also
          used for a number of other requests that are expected to
          complete quickly - the general rule is that all callbacks that
          do not have a corresponding <code class="function">init()</code>
          callback are in fact control socket requests. There can only
          be one control socket for a given daemon context.</p></dd><dt><span class="term"><code class="constant">WORKER_SOCKET</code></span></dt><dd><p>We must always create at least one worker socket. All
          transaction, data, validation, and action callbacks, except
          the <code class="function">init()</code> callbacks, use a worker socket.
          It is possible for a daemon to have multiple worker sockets,
          and the <code class="function">init()</code> callback (see e.g.
          <code class="function">confd_register_trans_cb()</code>) must
          indicate which worker socket should be used for the subsequent
          requests. This makes it possible for an application
          to be multi-threaded, where different threads can be used for
          different transactions.</p></dd></dl></div><p>Returns CONFD_OK when successful or CONFD_ERR on
    connection error.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>All the callbacks that are invoked via these sockets are
    subject to timeouts configured in <code class="filename">confd.conf</code>,
    see <a class="link" href="rn03re17.html" title="confd.conf">confd.conf(5)</a>. The
    callbacks invoked via the control socket must generate a reply back
    to ConfD within the time configured for
    <code class="sgmltag-element">/confdConfig/capi/newSessionTimeout</code>, the callbacks
    invoked via a worker socket within the time configured for
    <code class="sgmltag-element">/confdConfig/capi/queryTimeout</code>. If either timeout is
    exceeded, the daemon will be considered dead, and ConfD will
    disconnect it by closing the control and worker
    sockets.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> If this call fails (i.e. does not return CONFD_OK),
    the socket descriptor must be closed and a new socket created
    before the call is re-attempted.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_PROTOUSAGE</p><div class="funcsynopsis"><a name="fn.confd_register_trans_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_trans_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_trans_cbs *<var class="pdparam">trans</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function registers transaction callback functions. A
  transaction is a ConfD concept. There may be multiple sources of
  data for the device configuration. </p><p>In order to orchestrate transactions with multiple sources of
  data, ConfD implements a two-phase commit protocol towards all data
  sources that participate in a transaction.</p><p>Each NETCONF operation will be an individual ConfD
  transaction. These transactions are typically very short
  lived. Transactions originating from the CLI or the Web UI have
  longer life. The ConfD transaction can be viewed as a conceptual
  state machine where the different phases of the transaction are
  different states and the invocations of the callback functions are
  state transitions. The following ASCII art depicts the state
  machine.</p><div class="informalfigure"><pre class="screen">               +-------+
               | START |
               +-------+
                   | init()
                   |
                   v
      read()   +------+          finish()
      ------&gt;  | READ | --------------------&gt; START
               +------+
                 ^  |
  trans_unlock() |  | trans_lock()
                 |  v
      read()  +----------+       finish()
      ------&gt; | VALIDATE | -----------------&gt; START
              +----------+
                   | write_start()
                   |
                   v
      write()  +-------+          finish()
      -------&gt; | WRITE | -------------------&gt; START
               +-------+
                   | prepare()
                   |
                   v
              +----------+   commit()   +-----------+
              | PREPARED | -----------&gt; | COMMITTED |
              +----------+              +-----------+
                   | abort()                  |
                   |                          | finish()
                   v                          |
               +---------+                    v
               | ABORTED |                  START
               +---------+
                   | finish()
                   |
                   v
                 START</pre></div><p>The <span class="type">struct confd_trans_cbs</span> is defined as:</p><div class="informalexample"><a name="struct.confd_trans_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_trans_cbs {
    <strong class="hl-keyword">int</strong> (*init)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
    <strong class="hl-keyword">int</strong> (*trans_lock)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *sctx);
    <strong class="hl-keyword">int</strong> (*trans_unlock)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *sctx);
    <strong class="hl-keyword">int</strong> (*write_start)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *sctx);
    <strong class="hl-keyword">int</strong> (*prepare)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
    <strong class="hl-keyword">int</strong> (*abort)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
    <strong class="hl-keyword">int</strong> (*commit)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
    <strong class="hl-keyword">int</strong> (*finish)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
    <strong class="hl-keyword">void</strong> (*interrupt)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
};</pre></div><p>Transactions can be performed towards fours
  different kind of storages.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_CANDIDATE</code></span></dt><dd><p>If the system has been configured so that the external
        database owns the candidate data share, we will have to
        execute candidate transactions here. Usually ConfD owns the
        candidate and in that case the external database will never
        see any CONFD_CANDIDATE transactions.</p></dd><dt><span class="term"><code class="constant">CONFD_RUNNING</code></span></dt><dd><p>This is a transaction towards the actual running
        configuration of the device. All write operations in a
        CONFD_RUNNING transaction must be propagated to the individual
        subsystems that use this configuration data.</p></dd><dt><span class="term"><code class="constant">CONFD_STARTUP</code></span></dt><dd><p>If the system has ben configured to support the NETCONF
        startup capability, this is a transaction towards the startup
        database.</p></dd><dt><span class="term"><code class="constant">CONFD_OPERATIONAL</code></span></dt><dd><p>
          This value indicates a transaction towards writable
          operational data.  This transaction is used only if there
          are non-config data marked as <code class="code">tailf:writable
          true</code> in the YANG module.
        </p><p>
          Currently, these transaction are only started by the SNMP
          agent, and only when writable operational data is SET over
          SNMP.
        </p></dd></dl></div><p>Which type we have is indicated through the
  <code class="varname">confd_dbname</code> field in the
  <span class="type">confd_trans_ctx</span>.</p><p>A transaction, regardless of whether it originates from the
  NETCONF agent, the CLI or the Web UI, has several distinct
  phases:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">init()</code></span></dt><dd><p>This callback must always be implemented.  All other
        callbacks are optional. This means that if the callback is set
        to NULL, ConfD will treat it as an implicit CONFD_OK.
        <code class="filename">libconfd</code> will allocate a transaction
        context on behalf of the transaction and give this newly
        allocated structure as an argument to the
        <code class="function">init()</code> callback. The structure is defined
        as:</p><div class="informalexample"><a name="struct.confd_user_info"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_user_info {
    <strong class="hl-keyword">int</strong> af;                        <em class="hl-comment" style="color: silver">/* AF_INET | AF_INET6 */</em>
    <strong class="hl-keyword">union</strong> {
        <strong class="hl-keyword">struct</strong> in_addr v4;         <em class="hl-comment" style="color: silver">/* address from where the */</em>
        <strong class="hl-keyword">struct</strong> in6_addr v6;        <em class="hl-comment" style="color: silver">/* user session originates */</em>
    } ip;
    u_int16_t port;                <em class="hl-comment" style="color: silver">/* source port */</em>
    <strong class="hl-keyword">char</strong> username[MAXUSERNAMELEN]; <em class="hl-comment" style="color: silver">/* who is the user */</em>
    <strong class="hl-keyword">int</strong> usid;                      <em class="hl-comment" style="color: silver">/* user session id */</em>
    <strong class="hl-keyword">char</strong> context[MAXCTXLEN];       <em class="hl-comment" style="color: silver">/* cli | webui | netconf | */</em>
                                   <em class="hl-comment" style="color: silver">/* noaaa | any MAAPI string */</em>
    <strong class="hl-keyword">enum</strong> confd_proto proto;        <em class="hl-comment" style="color: silver">/* which protocol */</em>
    <strong class="hl-keyword">struct</strong> confd_action_ctx actx;  <em class="hl-comment" style="color: silver">/* used during action call */</em>
    time_t logintime;
    <strong class="hl-keyword">enum</strong> confd_usess_lock_mode lmode;  <em class="hl-comment" style="color: silver">/* the lock we have (only from */</em>
                                       <em class="hl-comment" style="color: silver">/* maapi_get_user_session())   */</em>
    <strong class="hl-keyword">char</strong> snmp_v3_ctx[<span class="hl-number">255</span>];         <em class="hl-comment" style="color: silver">/* SNMP context for SNMP sessions */</em>
                                   <em class="hl-comment" style="color: silver">/* empty string ("") for non-SNMP sessions */</em>
    <strong class="hl-keyword">char</strong> clearpass[<span class="hl-number">255</span>];           <em class="hl-comment" style="color: silver">/* if have the pass, it's here */</em>
                                   <em class="hl-comment" style="color: silver">/* only if confd internal ssh is used */</em>
    <strong class="hl-keyword">int</strong> flags;                     <em class="hl-comment" style="color: silver">/* CONFD_USESS_FLAG_... */</em>
    <strong class="hl-keyword">void</strong> *u_opaque;                <em class="hl-comment" style="color: silver">/* Private User data */</em>
    <em class="hl-comment" style="color: silver">/* ConfD internal fields */</em>
    <strong class="hl-keyword">char</strong> *errstr;                  <em class="hl-comment" style="color: silver">/* for error formatting callback */</em>
    <strong class="hl-keyword">int</strong> refc;
};</pre><a name="struct.confd_trans_ctx"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_trans_ctx {
    <strong class="hl-keyword">int</strong> fd;                      <em class="hl-comment" style="color: silver">/* trans (worker) socket */</em>
    <strong class="hl-keyword">int</strong> vfd;                     <em class="hl-comment" style="color: silver">/* validation worker socket */</em>
    <strong class="hl-keyword">struct</strong> confd_daemon_ctx *dx; <em class="hl-comment" style="color: silver">/* our daemon ctx */</em>
    <strong class="hl-keyword">enum</strong> confd_trans_mode mode;
    <strong class="hl-keyword">enum</strong> confd_dbname dbname;
    <strong class="hl-keyword">struct</strong> confd_user_info *uinfo;
    <strong class="hl-keyword">void</strong> *t_opaque;              <em class="hl-comment" style="color: silver">/* Private User data (transaction) */</em>
    <strong class="hl-keyword">void</strong> *v_opaque;              <em class="hl-comment" style="color: silver">/* Private User data (validation) */</em>
    <strong class="hl-keyword">struct</strong> confd_error error;    <em class="hl-comment" style="color: silver">/* user settable via */</em>
                                 <em class="hl-comment" style="color: silver">/* confd_trans_seterr*() */</em>
    <strong class="hl-keyword">struct</strong> confd_tr_item *accumulated;
    <strong class="hl-keyword">int</strong> thandle;                 <em class="hl-comment" style="color: silver">/* transaction handle */</em>
    <strong class="hl-keyword">void</strong> *cb_opaque;             <em class="hl-comment" style="color: silver">/* private user data from */</em>
                                 <em class="hl-comment" style="color: silver">/* data callback registration */</em>
    <strong class="hl-keyword">void</strong> *vcb_opaque;            <em class="hl-comment" style="color: silver">/* private user data from */</em>
                                 <em class="hl-comment" style="color: silver">/* validation callback registration */</em>
    <strong class="hl-keyword">int</strong> secondary_index;         <em class="hl-comment" style="color: silver">/* if != 0: secondary index number */</em>
                                 <em class="hl-comment" style="color: silver">/* for list traversal */</em>
    <strong class="hl-keyword">int</strong> validation_info;         <em class="hl-comment" style="color: silver">/* CONFD_VALIDATION_FLAG_XXX */</em>
    <strong class="hl-keyword">char</strong> *callpoint_opaque;      <em class="hl-comment" style="color: silver">/* tailf:opaque for callpoint
                                    in data model */</em>
    <strong class="hl-keyword">char</strong> *validate_opaque;       <em class="hl-comment" style="color: silver">/* tailf:opaque for validation point
                                    in data model */</em>
    <strong class="hl-keyword">union</strong> confd_request_data request_data; <em class="hl-comment" style="color: silver">/* info from northbound agent */</em>
    <strong class="hl-keyword">int</strong> hide_inactive;           <em class="hl-comment" style="color: silver">/* if != 0: config data with
                                    CONFD_ATTR_INACTIVE should be hidden */</em>

    <em class="hl-comment" style="color: silver">/* ConfD internal fields                            */</em>
    <strong class="hl-keyword">int</strong> index;         <em class="hl-comment" style="color: silver">/* array pos                       */</em>
    <strong class="hl-keyword">int</strong> lastop;        <em class="hl-comment" style="color: silver">/* remember what we were doing     */</em>
    <strong class="hl-keyword">int</strong> last_proto_op; <em class="hl-comment" style="color: silver">/* ditto */</em>
    <strong class="hl-keyword">int</strong> seen_reply;    <em class="hl-comment" style="color: silver">/* have we seen a reply msg        */</em>
    <strong class="hl-keyword">int</strong> query_ref;     <em class="hl-comment" style="color: silver">/* last query ref for this trans   */</em>
    <strong class="hl-keyword">int</strong> in_num_instances;
    u_int32_t num_instances;
    <strong class="hl-keyword">long</strong> nextarg;
    <strong class="hl-keyword">struct</strong> confd_data_cbs *next_dcb;
    confd_hkeypath_t *next_kp;
    <strong class="hl-keyword">struct</strong> confd_tr_item *lastack; <em class="hl-comment" style="color: silver">/* tail of acklist */</em>
    <strong class="hl-keyword">int</strong> refc;
};</pre></div><p>This callback is required to prepare for future
        read/write operations towards the data source. It could be
        that a file handle or socket must be established. The place to
        do that is usually the <code class="function">init()</code>
        callback.</p><p>The <code class="function">init()</code> callback is conceptually
        invoked at the start of the transaction, but as an
        optimization, ConfD will as far as possible delay the actual
        invocation for a given daemon until it is required.  In case
        of a read-only transaction, or a daemon that is only providing
        operational data, this can have the result that a daemon will
        not have any callbacks at all invoked (if none of the data
        elements that it provides are accessed).</p><p>The callback must also indicate to
        <code class="filename">libconfd</code> which WORKER_SOCKET should be
        used for future communications in this transaction. This is
        the mechanism which is used by libconfd to distribute work
        among multiple worker threads in the database application. If
        another thread than the thread which owns the CONTROL_SOCKET
        should be used, it is up to the application to somehow notify
        that thread.</p><p>The choice of descriptor is done through the API call
        <code class="function">confd_trans_set_fd()</code>
        which sets the <code class="varname">fd</code> field in the
        transaction context.</p><p>The callback must return CONFD_OK,
        CONFD_DELAYED_RESPONSE or CONFD_ERR.</p><p>The transaction then enters READ state, where ConfD will
        perform a series of <code class="function">read()</code> operations.</p></dd><dt><span class="term"><code class="function">trans_lock()</code></span></dt><dd><p>This callback is invoked when the validation phase of
        the transaction starts.  If the underlying database supports
        real transactions, it is usually appropriate to start such a
        native transaction here.</p><p>The callback must return CONFD_OK,
        CONFD_DELAYED_RESPONSE, CONFD_ERR, or CONFD_ALREADY_LOCKED.

        The transaction enters VALIDATE state, where ConfD will
        perform a series of <code class="function">read()</code>
        operations.</p><p>The trans lock is set until either
        <code class="function">trans_unlock()</code> or
        <code class="function">finish()</code> is called. ConfD ensures that a
        trans_lock is set on a single transaction only. In the case of
        the CONFD_DELAYED_RESPONSE - to later indicate that the
        database is already locked, use the
        <code class="function">confd_delayed_reply_error()</code> function with
        the special error string "locked".  An alternate way to
        indicate that the database is already locked is to use
        <code class="function">confd_trans_seterr_extended()</code> (see below)
        with CONFD_ERRCODE_IN_USE - this is the only way to give a
        message in the "delayed" case. If this function is used, the
        callback must return CONFD_ERR in the "normal" case, and in
        the "delayed" case
        <code class="function">confd_delayed_reply_error()</code> must be
        called with a NULL argument after
        <code class="function">confd_trans_seterr_extended()</code>.</p></dd><dt><span class="term"><code class="function">trans_unlock()</code></span></dt><dd><p>This callback is called when the validation of the
        transaction failed, or the validation is triggered explicitly
        (i.e. not part of a 'commit' operation). This is common in the
        CLI and the Web UI where the user can enter invalid
        data. Transactions that originate from NETCONF will never
        trigger this callback.  If the underlying database supports
        real transactions and they are used, the transaction should be
        aborted here.</p><p>The callback must return CONFD_OK,
        CONFD_DELAYED_RESPONSE or CONFD_ERR. The transaction re-enters
        READ state.</p></dd><dt><span class="term"><code class="function">write_start()</code></span></dt><dd><p>This callback is invoked when the validation succeeded
        and the write phase of the transaction starts.  If the
        underlying database supports real transactions, it is usually
        appropriate to start such a native transaction here.</p><p>The transaction enters the WRITE state. No more
        <code class="function">read()</code> operations will be performed by
        ConfD.</p><p>The callback must return CONFD_OK,
        CONFD_DELAYED_RESPONSE, CONFD_ERR, or CONFD_IN_USE.</p><p>If CONFD_IN_USE is returned, the transaction is
        restarted, i.e.  it effectively returns to the READ state.  To
        give this return code after CONFD_DELAYED_RESPONSE, use the
        <code class="function">confd_delayed_reply_error()</code> function with
        the special error string "in_use".  An alternative for both
        cases is to use
        <code class="function">confd_trans_seterr_extended()</code> (see below)
        with CONFD_ERRCODE_IN_USE - this is the only way to give a
        message in the "delayed" case. If this function is used, the
        callback must return CONFD_ERR in the "normal" case, and in
        the "delayed" case
        <code class="function">confd_delayed_reply_error()</code> must be
        called with a NULL argument after
        <code class="function">confd_trans_seterr_extended()</code>.</p></dd><dt><span class="term"><code class="function">prepare()</code></span></dt><dd><p>If we have multiple sources of data it is highly
        recommended that the callback is implemented.  The callback is
        called at the end of the transaction, when all read and write
        operations for the transaction have been performed and the
        transaction should prepare to commit.</p><p>This callback should allocate the resources necessary
        for the commit, if any. The callback must return CONFD_OK,
        CONFD_DELAYED_RESPONSE, CONFD_ERR, or CONFD_IN_USE.</p><p>If CONFD_IN_USE is returned, the transaction is
        restarted, i.e.  it effectively returns to the READ state.  To
        give this return code after CONFD_DELAYED_RESPONSE, use the
        <code class="function">confd_delayed_reply_error()</code> function with
        the special error string "in_use".  An alternative for both
        cases is to use
        <code class="function">confd_trans_seterr_extended()</code> (see below)
        with CONFD_ERRCODE_IN_USE - this is the only way to give a
        message in the "delayed" case. If this function is used, the
        callback must return CONFD_ERR in the "normal" case, and in
        the "delayed" case
        <code class="function">confd_delayed_reply_error()</code> must be
        called with a NULL argument after
        <code class="function">confd_trans_seterr_extended()</code>.</p></dd><dt><span class="term"><code class="function">commit()</code></span></dt><dd><p>This callback is optional. This callback is responsible
        for writing the data to persistent storage. Must return
        CONFD_OK, CONFD_DELAYED_RESPONSE or CONFD_ERR.</p></dd><dt><span class="term"><code class="function">abort()</code></span></dt><dd><p>This callback is optional. This callback is responsible
        for undoing whatever was done in the
        <code class="function">prepare()</code> phase. Must return CONFD_OK,
        CONFD_DELAYED_RESPONSE or CONFD_ERR.</p></dd><dt><span class="term"><code class="function">finish()</code></span></dt><dd><p>This callback is optional. This callback is responsible
        for releasing resources allocated in the
        <code class="function">init()</code> phase. In particular, if the
        application choose to use the <code class="varname">t_opaque</code>
        field in the <span class="type">confd_trans_ctx</span> to hold any
        resources, these resources must be released here.</p></dd><dt><span class="term"><code class="function">interrupt()</code></span></dt><dd><p>This callback is optional. Unlike the other transaction
        callbacks, it does not imply a change of the transaction state,
        it is instead a notification that the user running the
        transaction requested that it should be interrupted (e.g. Ctrl-C
        in the CLI). Also unlike the other transaction callbacks, the
        callback request is sent asynchronously on the control socket.
        Registering this callback may be useful for a configuration data
        provider that has some (transaction or data) callbacks which
        require extensive processing - the callback could then determine
        whether one of these callbacks is being processed, and if
        feasible return an error from that callback instead of
        completing the processing. In that case,
        <code class="function">confd_trans_seterr_extended()</code> with
        <em class="parameter"><code>code</code></em>
        <code class="constant">CONFD_ERRCODE_INTERRUPT</code> should be
        used.</p></dd></dl></div><p>All the callback functions (except
  <code class="function">interrupt()</code>) must return CONFD_OK,
  CONFD_DELAYED_RESPONSE or CONFD_ERR.</p><p>It is often useful to associate an error string with a
  CONFD_ERR return value. This can be done through a call to
  <code class="function">confd_trans_seterr()</code> or
  <code class="function">confd_trans_seterr_extended()</code>.</p><p>Depending on the situation (original caller) the error string
  gets propagated to the CLI, the Web UI or the NETCONF manager.</p><div class="funcsynopsis"><a name="fn.confd_register_db_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_db_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_db_cbs *<var class="pdparam">dbcbs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>We may also optionally have a set of callback functions which
  span over several ConfD transactions.</p><p>If the system is configured in such a way so that the external
  database owns the candidate data store we must implement four
  callback functions to do this. If ConfD owns the candidate the
  candidate callbacks should be set to NULL.</p><p>If ConfD owns the candidate, ConfD has been configured to
  support <code class="code">confirmed-commit</code> and the
  <span class="emphasis"><em>revertByCommit</em></span> isn't enabled, then three checkpointing
  functions must be implemented; otherwise these should
  be set to NULL. When <code class="code">confirmed-commit</code> is
  enabled, the user can commit the candidate with a timeout. Unless a
  confirming commit is given by the user before the timer expires, the
  system must rollback to the previous running configuration. This
  mechanism is controlled by the checkpoint callbacks. If the revertByCommit
  feature is enabled the potential rollback to previous running configuration
  is done using normal reversed commits, hence no checkpointing support is
  required in this case. See further below.</p><p>An external database may also (optionally) support the
  lock/unlock and lock_partial/unlock_partial operations.  This is
  only interesting if there exists additional locking mechanisms
  towards the database - such as an external CLI which can lock the
  database, or if the external database owns the candidate.</p><p>Finally, the external database may optionally validate a
  candidate configuration. Configuration validation is preferably done
  through ConfD - however if a system already has implemented
  extensive configuration validation - the
  <code class="function">candidate_validate()</code> callback can be
  used.</p><p>The <span class="type">struct confd_db_cbs</span> structure looks
  like:</p><div class="informalexample"><a name="struct.confd_db_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_db_cbs {
    <strong class="hl-keyword">int</strong> (*candidate_commit)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx, <strong class="hl-keyword">int</strong> timeout);
    <strong class="hl-keyword">int</strong> (*candidate_confirming_commit)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*candidate_reset)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*candidate_chk_not_modified)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*candidate_rollback_running)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*candidate_validate)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*add_checkpoint_running)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*del_checkpoint_running)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*activate_checkpoint_running)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*copy_running_to_startup)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*running_chk_not_modified)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx);
    <strong class="hl-keyword">int</strong> (*lock)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx, <strong class="hl-keyword">enum</strong> confd_dbname dbname);
    <strong class="hl-keyword">int</strong> (*unlock)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx, <strong class="hl-keyword">enum</strong> confd_dbname dbname);
    <strong class="hl-keyword">int</strong> (*lock_partial)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx,
                        <strong class="hl-keyword">enum</strong> confd_dbname dbname, <strong class="hl-keyword">int</strong> lockid,
                        confd_hkeypath_t paths[], <strong class="hl-keyword">int</strong> npaths);
    <strong class="hl-keyword">int</strong> (*unlock_partial)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx,
                          <strong class="hl-keyword">enum</strong> confd_dbname dbname, <strong class="hl-keyword">int</strong> lockid);
    <strong class="hl-keyword">int</strong> (*delete_config)(<strong class="hl-keyword">struct</strong> confd_db_ctx *dbx,
                         <strong class="hl-keyword">enum</strong> confd_dbname dbname);
};</pre></div><p>If we have an externally implemented candidate, that is if
  confd.conf item
  <code class="sgmltag-element">/confdConfig/datastores/candidate/implementation</code>
  is set to "external", we must implement the 5 candidate callbacks.
  Otherwise (recommended) they must be set to NULL.</p><p>If implementation is "external", all databases (if there are
  more than one) MUST take care of the candidate for their part of the
  configuration data tree. If ConfD is configured to use an external
  database for parts of the configuration, and the built-in CDB database
  is used for some parts, CDB will handle the candidate for its part.
  See also <code class="filename">misc/extern_candidate</code> in the examples
  collection.</p><p>The callback functions are are the following:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">candidate_commit()</code></span></dt><dd><p>This function should copy the candidate DB into the
        running DB. If <em class="parameter"><code>timeout</code></em> != 0, we should be
        prepared to do a rollback or act on a
        <code class="function">candidate_confirming_commit()</code>. The
        <em class="parameter"><code>timeout</code></em> parameter can not be used to set
        a timer for when to rollback; this timer is handled by the
        ConfD daemon. If we terminate without having acted on the
        <code class="function">candidate_confirming_commit()</code>, we MUST
        restart with a rollback. Thus we must remember that we are
        waiting for a
        <code class="function">candidate_confirming_commit()</code> and we must
        do so on persistent storage. Must only be implemented when the
        external database owns the candidate.</p></dd><dt><span class="term"><code class="function">candidate_confirming_commit()</code></span></dt><dd><p>If the <em class="parameter"><code>timeout</code></em> in the
        <code class="function">candidate_commit()</code> function is != 0, we
        will be either invoked here or in the
        <code class="function">candidate_rollback_running()</code> function
        within <em class="parameter"><code>timeout</code></em>
        seconds. <code class="function">candidate_confirming_commit()</code>
        should make the commit persistent, whereas a call to
        <code class="function">candidate_rollback_running()</code> would copy
        back the previous running configuration to running.</p></dd><dt><span class="term"><code class="function">candidate_rollback_running()</code></span></dt><dd><p>If for some reason, apart from a timeout, something goes
        wrong, we get invoked in the
        <code class="function">candidate_rollback_running()</code>
        function. The function should copy back the previous running
        configuration to running.</p></dd><dt><span class="term"><code class="function">candidate_reset()</code></span></dt><dd><p>This function is intended to copy the current running
        configuration into the candidate.  It is invoked whenever the
        NETCONF operation <code class="code">&lt;discard-changes&gt;</code>
        is executed or when a lock is released without committing.</p></dd><dt><span class="term"><code class="function">candidate_chk_not_modified()</code></span></dt><dd><p>This function should check to see if the candidate has
        been modified or not. Returns CONFD_OK if no modifications has
        been done since the last commit or reset, and CONFD_ERR if any
        uncommitted modifications exist.</p></dd><dt><span class="term"><code class="function">candidate_validate()</code></span></dt><dd><p>This callback is optional. If implemented, the task of
        the callback is to validate the candidate configuration. Note
        that the running database can be validated by the database in
        the <code class="function">prepare()</code> callback.
        <code class="function">candidate_validate()</code> is only meaningful
        when an explicit validate operation is received, e.g. through
        NETCONF.</p></dd><dt><span class="term"><code class="function">add_checkpoint_running()</code></span></dt><dd><p>This function should be implemented only when ConfD owns
        the candidate, confirmed-commit is enabled and revertByCommit is
        disabled.</p><p>It is responsible for creating a checkpoint of the
        current running configuration and storing the checkpoint in
        non-volatile memory. When the system restarts this function
        should check if there is a checkpoint available, and use the
        checkpoint instead of running.</p></dd><dt><span class="term"><code class="function">del_checkpoint_running()</code></span></dt><dd><p>This function should delete a checkpoint created by
        <code class="function">add_checkpoint_running()</code>. It is called by
        ConfD when a confirming commit is received unless revertByCommit is
        enabled.</p></dd><dt><span class="term"><code class="function">activate_checkpoint_running()</code></span></dt><dd><p>This function should rollback running to the checkpoint
        created by <code class="function">add_checkpoint_running()</code>. It
        is called by ConfD when the timer expires or if the user
        session expires unless revertByCommit is enabled.</p></dd><dt><span class="term"><code class="function">copy_running_to_startup()</code></span></dt><dd><p>This function should copy running to startup. It only
        needs to be implemented if the startup data store is
        enabled.</p></dd><dt><span class="term"><code class="function">running_chk_not_modified()</code></span></dt><dd><p>This function should check to see if running has been
        modified or not. It only needs to be implemented if the startup
        data store is enabled. Returns CONFD_OK if no modifications have
        been done since the last copy of running to startup, and
        CONFD_ERR if any modifications exist.</p></dd><dt><span class="term"><code class="function">lock()</code></span></dt><dd><p>This should only be implemented if our database supports
        locking from other sources than through ConfD. In this case
        both the lock/unlock and lock_partial/unlock_partial callbacks
        must be implemented. If a lock on the whole database is set
        through e.g. NETCONF, ConfD will first make sure that no other
        ConfD transaction has locked the database. Then it will call
        <code class="function">lock()</code> to make sure that the database is
        not locked by some other source (such as a non-ConfD CLI).
        Returns CONFD_OK on success, and CONFD_ERR if the lock was
        already held by an external entity.</p></dd><dt><span class="term"><code class="function">unlock()</code></span></dt><dd><p>Unlocks the database.</p></dd><dt><span class="term"><code class="function">lock_partial()</code></span></dt><dd><p>This should only be implemented if our database supports
        locking from other sources than through ConfD, see
        <code class="function">lock()</code> above.  This callback is invoked
        if a northbound agent requests a partial lock.  The
        <em class="parameter"><code>paths[]</code></em> argument is an
        <em class="parameter"><code>npaths</code></em> long array of hkeypaths that
        identify the leafs and/or subtrees that are to be locked.  The
        <em class="parameter"><code>lockid</code></em> is a reference that will be used
        on a subsequent corresponding
        <code class="function">unlock_partial()</code> invocation.</p></dd><dt><span class="term"><code class="function">unlock_partial()</code></span></dt><dd><p>Unlocks the partial lock that was requested with
        <em class="parameter"><code>lockid</code></em>.</p></dd><dt><span class="term"><code class="function">delete_config()</code></span></dt><dd><p>Will be called for 'startup' or 'candidate' only. The
        database is supposed to be set to erased.</p></dd></dl></div><p>All the above callback functions must return either CONFD_OK
  or CONFD_ERR. If the system is configured so that ConfD owns the
  candidate, then obviously the candidate related functions need not
  be implemented. If the system is configured to not do confirmed
  commit, <code class="function">candidate_confirming_commit()</code> and
  <code class="function">candidate_commit()</code> need not to be
  implemented.</p><p>It is often interesting to associate an error string with a
  CONFD_ERR return value. In particular the
  <code class="function">validate()</code> callback must typically indicate
  which item was invalid and why. This can be done through a call to
  <code class="function">confd_db_seterr()</code> or
  <code class="function">confd_db_seterr_extended()</code>.</p><p>Depending on the situation (original caller) the error string
  is propagated to the CLI, the Web UI or the NETCONF manager.</p><div class="funcsynopsis"><a name="fn.confd_register_data_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_data_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_data_cbs *<var class="pdparam">data</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function registers the data manipulation callbacks. The
  data model defines a number of "callpoints". Each callpoint must have
  an associated set of data callbacks. </p><p>Thus if our database application serves three different
  callpoints in the data model we must install three different sets of
  data manipulation callbacks - one set at each callpoint.</p><p>The data callbacks either return data back to ConfD or they do
  not. For example the <code class="function">create()</code> callback does not
  return data whereas the <code class="function">get_next()</code> callback
  does. All the callbacks that return data do so through API
  functions, not by means of return values from the function
  itself.</p><p>The <span class="type">struct confd_data_cbs</span> is defined as:</p><div class="informalexample"><a name="struct.confd_data_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_data_cbs {
    <strong class="hl-keyword">char</strong> callpoint[MAX_CALLPOINT_LEN];
    <em class="hl-comment" style="color: silver">/* where in the XML tree do we */</em>
    <em class="hl-comment" style="color: silver">/* want this struct */</em>

    <em class="hl-comment" style="color: silver">/* Only necessary to have this cb if our data model has */</em>
    <em class="hl-comment" style="color: silver">/* typeless optional nodes or oper data lists w/o keys */</em>
    <strong class="hl-keyword">int</strong> (*exists_optional)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                           confd_hkeypath_t *kp);
    <strong class="hl-keyword">int</strong> (*get_elem)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp);
    <strong class="hl-keyword">int</strong> (*get_next)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp, <strong class="hl-keyword">long</strong> next);
    <strong class="hl-keyword">int</strong> (*set_elem)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp,
                    confd_value_t *newval);
    <strong class="hl-keyword">int</strong> (*create)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                  confd_hkeypath_t *kp);
    <strong class="hl-keyword">int</strong> (*remove)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                  confd_hkeypath_t *kp);
    <em class="hl-comment" style="color: silver">/* optional (find list entry by key/index values) */</em>
    <strong class="hl-keyword">int</strong> (*find_next)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                     confd_hkeypath_t *kp,
                     <strong class="hl-keyword">enum</strong> confd_find_next_type type,
                     confd_value_t *keys, <strong class="hl-keyword">int</strong> nkeys);
    <em class="hl-comment" style="color: silver">/* optional optimizations */</em>
    <strong class="hl-keyword">int</strong> (*num_instances)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                         confd_hkeypath_t *kp);
    <strong class="hl-keyword">int</strong> (*get_object)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                      confd_hkeypath_t *kp);
    <strong class="hl-keyword">int</strong> (*get_next_object)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                           confd_hkeypath_t *kp, <strong class="hl-keyword">long</strong> next);
    <strong class="hl-keyword">int</strong> (*find_next_object)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                            confd_hkeypath_t *kp,
                            <strong class="hl-keyword">enum</strong> confd_find_next_type type,
                            confd_value_t *keys, <strong class="hl-keyword">int</strong> nkeys);
    <em class="hl-comment" style="color: silver">/* next two are only necessary if 'choice' is used */</em>
    <strong class="hl-keyword">int</strong> (*get_case)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp, confd_value_t *choice);
    <strong class="hl-keyword">int</strong> (*set_case)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp, confd_value_t *choice,
                    confd_value_t *caseval);
    <em class="hl-comment" style="color: silver">/* next two are only necessary for config data providers,
       and only if /confdConfig/enableAttributes is 'true' */</em>
    <strong class="hl-keyword">int</strong> (*get_attrs)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                     confd_hkeypath_t *kp,
                     u_int32_t *attrs, <strong class="hl-keyword">int</strong> num_attrs);
    <strong class="hl-keyword">int</strong> (*set_attr)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp,
                    u_int32_t attr, confd_value_t *v);
    <em class="hl-comment" style="color: silver">/* only necessary if "ordered-by user" is used */</em>
    <strong class="hl-keyword">int</strong> (*move_after)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                      confd_hkeypath_t *kp, confd_value_t *prevkeys);
    <em class="hl-comment" style="color: silver">/* only for per-transaction-invoked transaction hook */</em>
    <strong class="hl-keyword">int</strong> (*write_all)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                     confd_hkeypath_t *kp);
    <strong class="hl-keyword">void</strong> *cb_opaque; <em class="hl-comment" style="color: silver">/* private user data    */</em>
};</pre></div><p>One of the parameters to the callback is a
  <span class="type">confd_hkeypath_t</span> (h - as in hashed keypath). This is
  fully described in <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a>.</p><p>The <code class="varname">cb_opaque</code> element can be used to pass
  arbitrary data to the callbacks, e.g. when the same set of callbacks
  is used for multiple callpoints. It is made available to the
  callbacks via an element with the same name in the transaction
  context (<em class="parameter"><code>tctx</code></em> argument), see the structure
  definition above.</p><p>If the <code class="code">tailf:opaque</code> substatement has been used with
  the <code class="code">tailf:callpoint</code> statement in the data model, the
  argument string is made available to the callbacks via the
  <code class="varname">callpoint_opaque</code> element in the transaction
  context.</p><p>When use of the <code class="constant">CONFD_ATTR_INACTIVE</code>
  attribute is enabled in the ConfD configuration
  (<code class="sgmltag-element">/confdConfig/enableAttributes</code> and
  <code class="sgmltag-element">/confdConfig/enableInactive</code> both set to
  <code class="constant">true</code>), read callbacks
  (<code class="function">get_elem()</code> etc) for configuration data must
  observe the current value of the <code class="varname">hide_inactive</code>
  element in the transaction context. If it is non-zero, those callbacks
  must act as if data with the <code class="constant">CONFD_ATTR_INACTIVE</code>
  attribute set does not exist.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
  CONFD_ERR_PROTOUSAGE</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">get_elem()</code></span></dt><dd><p>This callback function needs to return the value of a specific
        leaf. Assuming we have the following data model:</p><div class="informalexample"><pre class="programlisting">container servers {
  tailf:callpoint mycp;
  list server {
    key name;
    max-elements 64;
    leaf name {
      type string;
    }
    leaf ip {
      type inet:ip-address;
    }
    leaf port {
      type inet:port-number;
    }
  }
}
</pre></div><p>For example the value of the <code class="sgmltag-element">ip</code>
        leaf in the server entry whose key is "www" can be returned
        separately. The way to return a single data item is through
        <code class="function">confd_data_reply_value()</code>.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error or CONFD_DELAYED_RESPONSE if the reply value is not
        yet available. In the latter case the application must at a
        later stage call <code class="function">confd_data_reply_value()</code>
        (or <code class="function">confd_delayed_reply_ok()</code> for a
        write operation).  If an error is discovered at the time of a
        delayed reply, the error is signaled through a call to
        <code class="function">confd_delayed_reply_error()</code></p><p>If the leaf does not exist the callback must call
        <code class="function">confd_data_reply_not_found()</code>. If the
        leaf has a default value defined in the data model, and no
        value has been set, the callback should use
        <code class="function">confd_data_reply_value()</code> with a value of
        type C_DEFAULT - this makes it possible for northbound agents
        to leave such leafs out of the data returned to the
        user/manager (if requested).</p><p>The implementation of <code class="function">get_elem()</code>
        must be prepared to return values for all the leafs including the
        key(s). When ConfD invokes <code class="function">get_elem()</code> on
        a key leaf it is an existence test. The application should
        verify whether the object exists or not.</p></dd><dt><span class="term"><code class="function">get_next()</code></span></dt><dd><p>This callback makes it possible for ConfD to traverse a
        set of list entries, or a set leaf-list elements (unless the
        deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is
        used). The <em class="parameter"><code>next</code></em> parameter will be
        <code class="option">-1</code> on the first invocation. This function
        should reply by means of the function
        <code class="function">confd_data_reply_next_key()</code>.</p><p>If the list has a <code class="code">tailf:secondary-index</code>
        statement (see <a class="link" href="rn03re20.html" title="tailf_yang_extensions">tailf_yang_extensions(5)</a>),
        and the entries are supposed to be retrieved according to
        one of the secondary indexes, the variable
        <code class="varname">tctx-&gt;secondary_index</code> will be set to a
        value greater than <code class="constant">0</code>, indicating which
        secondary-index is used.  The first secondary-index in the
        definition is identified with the value <code class="constant">1</code>,
        the second with <code class="constant">2</code>, and so on.  confdc can
        be used to generate <code class="code">#define</code>s for the
        index names.  If no secondary indexes are defined, or if the
        sort order should be according to the key values,
        <code class="varname">tctx-&gt;secondary_index</code> is
        <code class="constant">0</code>.</p><p>To signal that no more entries exist, we reply with a
        NULL pointer as the key value in the
        <code class="function">confd_data_reply_next_key()</code>
        function.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error or CONFD_DELAYED_RESPONSE if the reply value is not
        yet available. In the latter case the application must at a
        later stage call
        <code class="function">confd_data_reply_next_key()</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For a list that does not specify a non-default sort
        order by means of a <code class="code">ordered-by user</code> or
        <code class="code">tailf:sort-order</code> statement, ConfD assumes that list
        entries are ordered strictly by increasing key (or secondary
        index) values. Thus for correct operation, we must observe this
        order when returning list entries in a sequence of
        <code class="function">get_next()</code> calls.</p></div></dd><dt><span class="term"><code class="function">set_elem()</code></span></dt><dd><p>This callback writes the value of a leaf. Note that an
        optional leaf with a type other than <span class="type">empty</span> is
        created by a call to this function. The callback must return
        CONFD_OK on success, CONFD_ERR on error or
        CONFD_DELAYED_RESPONSE.</p></dd><dt><span class="term"><code class="function">create()</code></span></dt><dd><p>This callback creates a new list entry, a
        <code class="code">presence</code> container, a leaf of type
        <code class="code">empty</code>, or a leaf-list element (unless the
        deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is
        used). In the case of the <code class="sgmltag-element">servers</code> data model
        above, this function need to create a new <code class="sgmltag-element">server</code>
        entry. Must return CONFD_OK on success, CONFD_ERR on error,
        CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE.</p><p>
          The data provider is responsible for maintaining the order of
          list entries.  If the list is marked as <code class="code">ordered-by
          user</code> in the YANG data model, the
          <code class="code">create()</code> callback must add the list entry to
          the end of the list.
        </p></dd><dt><span class="term"><code class="function">remove()</code></span></dt><dd><p>This callback is used to remove an existing list entry or
        <code class="code">presence</code> container and all its sub nodes (if
        any), an optional leaf, or a leaf-list element (unless the
        deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is
        used).  When we use the YANG <code class="code">choice</code> statement in the
        data model, it may also be used to remove nodes that are not
        optional as such when a different <code class="code">case</code> (or none) is
        selected.  I.e. it must always be possible to remove cases in a
        choice.</p><p>Must return CONFD_OK on success, CONFD_ERR on error,
        CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE.</p></dd><dt><span class="term"><code class="function">exists_optional()</code></span></dt><dd><p>If we have <code class="code">presence</code> containers or leafs of
        type <code class="code">empty</code>, we cannot use the
        <code class="function">get_elem()</code> callback to read the value of such a
        node, since it does not have a type. An example of a
        data model could be:</p><div class="informalexample"><pre class="programlisting">container bs {
  presence "";
  tailf:callpoint bcp;
  list b {
    key name;
    max-elements 64;
    leaf name {
      type string;
    }
    container opt {
      presence "";
      leaf ii {
        type int32;
      }
    }
    leaf foo {
      type empty;
    }
  }
}
</pre></div><p>The above YANG fragment has 3 nodes that may or may not
        exist and that do not have a type.
        If we do not have any such elements, nor any operational data
        lists without keys (see below), we do not need to implement the
        <code class="function">exists_optional()</code> callback and can set it
        to NULL.</p><p>If we have the above data model, we must implement the
        <code class="function">exists_optional()</code>, and our implementation
        must be prepared to reply on calls of the function for the
        paths <code class="sgmltag-element">/bs</code>, <code class="sgmltag-element">/bs/b/opt</code>, and
        <code class="sgmltag-element">/bs/b/foo</code>.  The leaf <code class="sgmltag-element">/bs/b/opt/ii</code> is
        not mandatory, but it does have a type namely
        <span class="type">int32</span>, and thus the existence of that leaf will
        be determined through a call to the
        <code class="function">get_elem()</code> callback.</p><p>The <code class="function">exists_optional()</code> callback may
        also be invoked by ConfD as "existence test" for an entry in an
        operational data list without keys (see the <a class="link" href="ch06.html#ug.opdata.without_keys" title="6.11.&nbsp;Operational data lists without keys">Operational Data chapter in
        the User Guide</a>), or for a leaf-list entry (unless the
        deprecated daemon flag CONFD_DAEMON_FLAG_LEAF_LIST_AS_LEAF is
        used). Normally this existence test is done with a
        <code class="function">get_elem()</code> request for the first key, but
        since there are no keys, this callback is used instead. Thus if
        we have such lists, or leaf-lists, we must also implement this
        callback, and handle a request where the keypath identifies a
        list entry or a leaf-list element.</p><p>The callback must reply to ConfD using either the
        <code class="function">confd_data_reply_not_found()</code> or the
        <code class="function">confd_data_reply_found()</code>
        function.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error or CONFD_DELAYED_RESPONSE if the reply value is not
        yet available.</p></dd><dt><span class="term"><code class="function">find_next()</code></span></dt><dd><p>This optional callback can be registered to optimize cases
        where ConfD wants to start a list traversal at some other point
        than at the first entry of the list, or otherwise make a "jump"
        in a list traversal. If the callback is not registered, ConfD
        will use a sequence of <code class="function">get_next()</code> calls to
        find the desired list entry.</p><p>Where the <code class="function">get_next()</code> callback
        provides a <em class="parameter"><code>next</code></em> parameter to indicate
        which keys should be returned, this callback instead provides a
        <em class="parameter"><code>type</code></em> parameter and a set of values to
        indicate which keys should be returned. Just like for
        <code class="function">get_next()</code>, the callback should reply by calling
        <code class="function">confd_data_reply_next_key()</code> with the keys
        for the requested list entry.</p><p>The <em class="parameter"><code>keys</code></em> parameter is a pointer to
        a <em class="parameter"><code>nkeys</code></em> elements long array of key
        values, or secondary index-leaf values (see below). The
        <em class="parameter"><code>type</code></em> can have one of two values:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_FIND_NEXT</code></span></dt><dd><p>The callback should always reply with the key values
              for the first list entry <span class="emphasis"><em>after</em></span> the
              one indicated by the <em class="parameter"><code>keys</code></em> array,
              and a <em class="parameter"><code>next</code></em> value appropriate for
              retrieval of subsequent entries. The
              <em class="parameter"><code>keys</code></em> array may not correspond to an
              actual existing list entry - the callback must return the
              keys for the first existing entry that is "later" in the
              list order than the keys provided by the
              callback. Furthermore the number of values provided in the
              array (<em class="parameter"><code>nkeys</code></em>) may be fewer than the
              number of keys (or number of index-leafs for a
              secondary-index) in the data model, possibly even zero.
              This means that only the first
              <em class="parameter"><code>nkeys</code></em> values are provided, and the
              remaining ones should be taken to have a value "earlier"
              than the value for any existing list entry.</p></dd><dt><span class="term"><code class="constant">CONFD_FIND_SAME_OR_NEXT</code></span></dt><dd><p>If the values in the <em class="parameter"><code>keys</code></em>
              array completely identify an actual existing list entry,
              the callback should reply with the keys for this list
              entry and a corresponding <em class="parameter"><code>next</code></em>
              value. Otherwise the same logic as described for
              <code class="constant">CONFD_FIND_NEXT</code> should be used.</p></dd></dl></div><p>The <code class="filename">dp/find_next</code> example in the
        bundled examples collection has an implementation of the
        <code class="function">find_next()</code> callback for a list with two
        integer keys. It shows how the <em class="parameter"><code>type</code></em> value
        and the provided keys need to be combined in order to find the
        requested entry - or find that no entry matching the request
        exists.</p><p>If the list has a <code class="code">tailf:secondary-index</code>
        statement (see <a class="link" href="rn03re20.html" title="tailf_yang_extensions">tailf_yang_extensions(5)</a>),
        the callback must examine the value of the
        <code class="varname">tctx-&gt;secondary_index</code> variable, as described
        for the <code class="function">get_next()</code> callback. If
        <code class="varname">tctx-&gt;secondary_index</code> has a value greater
        than <code class="constant">0</code>, the <em class="parameter"><code>keys</code></em> and
        <em class="parameter"><code>nkeys</code></em> parameters do not represent key
        values, but instead values for the index leafs specified by the
        <code class="code">tailf:index-leafs</code> statement for the secondary
        index. The callback should however still reply with the actual
        key values for the list entry in the
        <code class="function">confd_data_reply_next_key()</code> call.</p><p>Once we have called
        <code class="function">confd_data_reply_next_key()</code>, ConfD will use
        <code class="function">get_next()</code> (or
        <code class="function">get_next_object()</code>) for any subsequent
        entry-by-entry list traversal - however we can request that this
        traversal should be done using <code class="function">find_next()</code>
        (or <code class="function">find_next_object()</code>) instead, by passing
        <code class="constant">-1</code> for the <em class="parameter"><code>next</code></em>
        parameter to
        <code class="function">confd_data_reply_next_key()</code>. In this case
        ConfD will always invoke
        <code class="function">find_next()</code>/<code class="function">find_next_object()</code>
        with <em class="parameter"><code>type</code></em>
        <code class="constant">CONFD_FIND_NEXT</code>, and the (complete) set of
        keys from the previous reply.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the case of list traversal by means of a
        secondary index, the secondary index values must be unique for
        entry-by-entry traversal with
        <code class="function">find_next()</code>/<code class="function">find_next_object()</code>
        to be possible. Thus we can not pass <code class="constant">-1</code> for
        the <em class="parameter"><code>next</code></em> parameter to
        <code class="function">confd_data_reply_next_key()</code> in this case if
        the secondary index values are not unique.</p></div><p>To signal that no entry matching the request exists,
        i.e. we have reached the end of the list while evaluating the
        request, we reply with a NULL pointer as the key value in the
        <code class="function">confd_data_reply_next_key()</code>
        function.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For a list that does not specify a non-default sort
        order by means of a <code class="code">ordered-by user</code> or
        <code class="code">tailf:sort-order</code> statement, ConfD assumes that list
        entries are ordered strictly by increasing key
        values.</p></div><p>If we have registered <code class="function">find_next()</code> (or
        <code class="function">find_next_object()</code>), it is not strictly
        necessary to also register <code class="function">get_next()</code> (or
        <code class="function">get_next_object()</code>) - except for the case of
        traversal by secondary index when the secondary index values are
        not unique, see above. If a northbound agent does a get_next
        request, and neither <code class="function">get_next()</code> nor
        <code class="function">get_next_object()</code> is registered, ConfD will
        instead invoke <code class="function">find_next()</code> (or
        <code class="function">find_next_object()</code>), the same way as if
        <code class="constant">-1</code> had been passed for the
        <em class="parameter"><code>next</code></em> parameter to
        <code class="function">confd_data_reply_next_key()</code> as described
        above - the actual <em class="parameter"><code>next</code></em> value passed is
        ignored. The very first get_next request for a traversal
        (i.e. where the <em class="parameter"><code>next</code></em> parameter would be
        <code class="constant">-1</code>) will cause a find_next invocation with
        <em class="parameter"><code>type</code></em> <code class="constant">CONFD_FIND_NEXT</code>
        and <em class="parameter"><code>nkeys</code></em> == 0, i.e. no keys
        provided.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error or CONFD_DELAYED_RESPONSE if the reply value is not
        yet available. In the latter case the application must at a
        later stage call
        <code class="function">confd_data_reply_next_key()</code>.</p></dd><dt><span class="term"><code class="function">num_instances()</code></span></dt><dd><p>This callback can optionally be implemented. The purpose
        is to return the number of entries in a list, or the number of
        elements in a leaf-list. If
        the callback is set to NULL, whenever ConfD needs to calculate
        the number of entries in a certain list, ConfD
        will iterate through the entries by means of consecutive
        calls to the <code class="function">get_next()</code> callback.</p><p>If we have a large number of entries
        <span class="emphasis"><em>and</em></span> it is computationally cheap to
        calculate the number of entries  in a list, it may
        be worth the effort to implement this callback for performance
        reasons.</p><p>The number of entries is returned in an
        <span class="type">confd_value_t</span> value of type C_INT32. The value is
        returned through a call to
        <code class="function">confd_data_reply_value()</code>, see code
        example below:</p><div class="informalexample"><pre class="programlisting">    int num_instances;
    confd_value_t v;

    CONFD_SET_INT32(&amp;v, num_instances);
    confd_data_reply_value(trans_ctx, &amp;v);
    return CONFD_OK;</pre></div><p>Must return CONFD_OK on success, CONFD_ERR on error or
        CONFD_DELAYED_RESPONSE.</p></dd><dt><span class="term"><code class="function">get_object()</code></span></dt><dd><p>The implementation of this callback is also optional. The
        purpose of the callback is to return an entire object, i.e. a
        list entry, in one
        swoop. If the callback is not implemented, ConfD will retrieve
        the whole object through a series of calls to
        <code class="function">get_elem()</code>.</p><p>By default, the callback will only be called for list entries
        - i.e. <code class="function">get_elem()</code> is still needed for
        leafs that are not defined in a list, but if there are no such
        leafs in the part of the data model covered by a given
        callpoint, the <code class="function">get_elem()</code> callback may be
        omitted when <code class="function">get_object()</code> is
        registered. This has the drawback that ConfD will have to invoke
        get_object() even if only a single leaf in a list entry is
        needed though, e.g. for the existence test mentioned for
        <code class="function">get_elem()</code>.</p><p>However, if the
        <code class="constant">CONFD_DAEMON_FLAG_BULK_GET_CONTAINER</code> flag
        is set via <code class="function">confd_set_daemon_flags()</code>,
        <code class="function">get_object()</code> will also be used for the
        toplevel ancestor container (if any) when no ancestor list node
        exists. I.e. in this case, <code class="function">get_elem()</code> is
        only needed for toplevel leafs - if there are any such leafs in
        the part of the data model covered by a given callpoint.</p><p>When ConfD invokes the
        <code class="function">get_elem()</code> callback, it is the
        responsibility of the application to issue calls to the reply
        function <code class="function">confd_data_reply_value()</code>.  The
        <code class="function">get_object()</code> callback cannot use this
        function since it needs to return a sequence of values. The
        <code class="function">get_object()</code> callback must use either the
        <code class="function">confd_data_reply_value_array()</code> function
        or the <code class="function">confd_data_reply_tag_value_array()</code>
        function.  See the description of these functions below for
        the details of the arguments passed. If the entry requested
        does not exist, the callback must call
        <code class="function">confd_data_reply_not_found()</code>.</p><p>Remember, the callback
        <code class="function">exists_optional()</code> must always be
        implemented when we have <code class="code">presence</code> containers or leafs of
        type <code class="code">empty</code>. If we also choose to implement the
        <code class="function">get_object()</code> callback, ConfD can
        sometimes derive the existence of such a node through a
        previous call to <code class="function">get_object()</code>. This is
        however not always the case, thus even if we implement
        <code class="function">get_object()</code>, we must also implement
        <code class="function">exists_optional()</code>if we have such nodes.</p><p>If we pass an array of values which does not comply with
        the rules for the above functions, ConfD will notice and an
        error is reported to the agent which issued the request. A
        message is also logged to ConfD's developerLog.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error or CONFD_DELAYED_RESPONSE if the reply value is not
        yet available.</p></dd><dt><span class="term"><code class="function">get_next_object()</code></span></dt><dd><p>The implementation of this callback is also
        optional. Similar to the <code class="function">get_object()</code>
        callback the purpose of this callback is to return an entire
        object, or even multiple objects, in one swoop. It combines the
        functionality of <code class="function">get_next()</code> and
        <code class="function">get_object()</code> into a single callback, and
        adds the possibility to return multiple objects. Thus
        we need only implement this callback if it very important to
        be able to traverse a list very fast.  If the callback is not
        implemented, ConfD will retrieve the whole object through a
        series of calls to <code class="function">get_next()</code> and
        consecutive calls to either <code class="function">get_elem()</code> or
        <code class="function">get_object()</code>.</p><p>When we have registered
        <code class="function">get_next_object()</code>, it is not strictly
        necessary to also register <code class="function">get_next()</code>, but
        omitting <code class="function">get_next()</code> may have a serious
        performance impact, since there are cases (e.g. CLI tab
        completion) when ConfD only wants to retrieve the keys for a
        list. In such a case, if we have only registered
        <code class="function">get_next_object()</code>, all the data for the
        list will be retrieved, but everything except the keys will be
        discarded. Also note that even if we have registered
        <code class="function">get_next_object()</code>, at least one of
        the <code class="function">get_elem()</code> and
        <code class="function">get_object()</code> callbacks must be
        registered.</p><p>Similar to the <code class="function">get_next()</code> callback,
        if the <em class="parameter"><code>next</code></em> parameter is
        <code class="option">-1</code> ConfD wants to retrieve the first entry
        in the list.</p><p>Similar to the <code class="function">get_next()</code> callback,
        if the <code class="varname">tctx-&gt;secondary_index</code> parameter is
        greater than <code class="constant">0</code> ConfD wants to retrieve the
        entries in the order defined by the secondary index.</p><p>Similar to the <code class="function">get_object()</code>
        callback, <code class="function">get_next_object()</code> needs to
        reply with an entire object expressed as either an array of
        <span class="type">confd_value_t</span> values or an array of
        <span class="type">confd_tag_value_t</span> values. It must also indicate
        which is the <span class="emphasis"><em>next</em></span> entry in the list
        similar to the <code class="function">get_next()</code> callback.  The
        two functions
        <code class="function">confd_data_reply_next_object_array()</code> and
        <code class="function">confd_data_reply_next_object_tag_value_array()</code>
        are use to convey the return values for one object from the
        <code class="function">get_next_object()</code> callback.</p><p>If we want to reply with multiple objects, we must instead
        use one of the functions
        <code class="function">confd_data_reply_next_object_arrays()</code> and
        <code class="function">confd_data_reply_next_object_tag_value_arrays()</code>.
        These functions take an "array of object arrays", where each
        element in the array corresponds to the reply for a single
        object with
        <code class="function">confd_data_reply_next_object_array()</code> and
        <code class="function">confd_data_reply_next_object_tag_value_array()</code>,
        respectively.</p><p>If we pass an array of values which does not comply with
        the rules for the above functions, ConfD will notice and an
        error is reported to the agent which issued the request. A
        message is also logged to ConfD's developerLog.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error or CONFD_DELAYED_RESPONSE if the reply value is not
        yet available.</p></dd><dt><span class="term"><code class="function">find_next_object()</code></span></dt><dd><p>The implementation of this callback is also
        optional. It relates to <code class="function">get_next_object()</code>
        in exactly the same way as <code class="function">find_next()</code>
        relates to <code class="function">get_next()</code>. I.e. instead of a
        parameter <em class="parameter"><code>next</code></em>, we get a
        <em class="parameter"><code>type</code></em> parameter and a set of key values,
        or secondary index-leaf values, to indicate which object or
        objects to return to ConfD via one of the reply functions.</p><p>Similar to the <code class="function">get_next_object()</code>
        callback, if the <code class="varname">tctx-&gt;secondary_index</code>
        parameter is greater than <code class="constant">0</code> ConfD wants to
        retrieve the entries in the order defined by the secondary
        index. And as described for the
        <code class="function">find_next()</code> callback, in this case the
        <em class="parameter"><code>keys</code></em> and <em class="parameter"><code>nkeys</code></em>
        parameters represent values for the index leafs specified by the
        <code class="code">tailf:index-leafs</code> statement for the secondary
        index.</p><p>Similar to the <code class="function">get_next_object()</code>
        callback, the callback can use any of the functions
        <code class="function">confd_data_reply_next_object_array()</code>,
        <code class="function">confd_data_reply_next_object_tag_value_array()</code>,
        <code class="function">confd_data_reply_next_object_arrays()</code>, and
        <code class="function">confd_data_reply_next_object_tag_value_arrays()</code>
        to return one or more objects to ConfD.</p><p>If we pass an array of values which does not comply with
        the rules for the above functions, ConfD will notice and an
        error is reported to the agent which issued the request. A
        message is also logged to ConfD's developerLog.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error or CONFD_DELAYED_RESPONSE if the reply value is not
        yet available.</p></dd><dt><span class="term"><code class="function">get_case()</code></span></dt><dd><p>This callback only needs to be implemented if we use the
        YANG <code class="code">choice</code> statement in the part of the data model
        that our data provider is responsible for, but when we use
        choice, the callback is required. It should return the
        currently selected <code class="code">case</code> for the choice given by the
        <em class="parameter"><code>choice</code></em> argument -
        <em class="parameter"><code>kp</code></em> is the path to the container or list
        entry where the choice is defined.</p><p>In the general case, where there may be multiple levels of
        <code class="code">choice</code> statements without intervening
        <code class="code">container</code> or <code class="code">list</code> statements in the
        data model, the choice is represented as an array of
        <span class="type">confd_value_t</span> elements with the type C_XMLTAG,
        terminated by an element with the type C_NOEXISTS. This array
        gives a reversed path with alternating choice and case names,
        from the data node given by <em class="parameter"><code>kp</code></em> to the
        specific choice that the callback request pertains to - similar
        to how a <span class="type">confd_hkeypath_t</span> gives a path through the
        data tree.</p><p>If we don't have such "nested" choices in the data model,
        we can ignore this array aspect, and just treat the
        <em class="parameter"><code>choice</code></em> argument as a single
        <span class="type">confd_value_t</span> value. The case is always represented
        as a <span class="type">confd_value_t</span> with the type C_XMLTAG. I.e. we
        can use CONFD_GET_XMLTAG() to get the choice tag from
        <em class="parameter"><code>choice</code></em> and CONFD_SET_XMLTAG() to set the
        case tag for the reply value. The callback should use
        <code class="function">confd_data_reply_value()</code> to return the case
        value to ConfD, or
        <code class="function">confd_data_reply_not_found()</code> for an
        optional choice without default case if no case is currently
        selected. If an optional choice with default case does not have
        a selected case, the callback should use
        <code class="function">confd_data_reply_value()</code> with a value of
        type C_DEFAULT.</p><p>Must return CONFD_OK on success, CONFD_ERR on error, or
        CONFD_DELAYED_RESPONSE.</p></dd><dt><span class="term"><code class="function">set_case()</code></span></dt><dd><p>This callback is completely optional, and will only be
        invoked (if registered) if we use the YANG <code class="code">choice</code>
        statement and provide configuration data. The callback sets the
        currently selected <code class="code">case</code> for the choice given by the
        <em class="parameter"><code>kp</code></em> and <em class="parameter"><code>choice</code></em>
        arguments, and is mainly intended to make it easier to support
        the <code class="function">get_case()</code> callback. ConfD will
        additionally invoke the <code class="function">remove()</code> callback
        for all nodes in the previously selected case, i.e. if we
        register <code class="function">set_case()</code>, we
        do not need to analyze <code class="function">set_elem()</code>
        callbacks to determine the currently selected case, or figure
        out which nodes that should be deleted.</p><p>For a choice without a <code class="code">mandatory true</code>
        statement, it is possible to have no case at all selected.  To
        indicate that the previously selected case should be deleted
        without selecting another case, the callback will be invoked
        with NULL for the <em class="parameter"><code>caseval</code></em>
        argument.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE.</p></dd><dt><span class="term"><code class="function">get_attrs()</code></span></dt><dd><p>This callback only needs to be implemented for callpoints
        specified for configuration data, and only if attributes are
        enabled in the ConfD configuration
        (<code class="sgmltag-element">/confdConfig/enableAttributes</code> set to
        <code class="constant">true</code>). These
        are the currently supported attributes:</p><div class="informalexample"><pre class="programlisting">/* CONFD_ATTR_TAGS: value is C_LIST of C_BUF/C_STR */
#define CONFD_ATTR_TAGS       0x80000000
/* CONFD_ATTR_ANNOTATION: value is C_BUF/C_STR */
#define CONFD_ATTR_ANNOTATION 0x80000001
/* CONFD_ATTR_INACTIVE: value is C_BOOL 1 (i.e. "true") */
#define CONFD_ATTR_INACTIVE   0x00000000
/* CONFD_ATTR_BACKPOINTER: value is C?LIST of C_BUF/C_STR */
#define CONFD_ATTR_BACKPOINTER 0x80000003


          </pre></div><p>The <em class="parameter"><code>attrs</code></em> parameter is an array of
        attributes of length <em class="parameter"><code>num_attrs</code></em>, giving
        the requested attributes - if <em class="parameter"><code>num_attrs</code></em>
        is 0, all attributes are requested. If the node given by
        <em class="parameter"><code>kp</code></em> does not exist, the callback should
        reply by calling
        <code class="function">confd_data_reply_not_found()</code>, otherwise it
        should call <code class="function">confd_data_reply_attrs()</code>, even
        if no attributes are set.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is very important to observe this distinction,
        i.e. to use <code class="function">confd_data_reply_not_found()</code>
        when the node doesn't exist, since ConfD may use
        <code class="function">get_attrs()</code> as an existence check when
        attributes are enabled. (This avoids doing one callback request
        for existence check and another to collect the
        attributes.)</p></div><p>Must return CONFD_OK on success, CONFD_ERR on error, or
        CONFD_DELAYED_RESPONSE.</p></dd><dt><span class="term"><code class="function">set_attr()</code></span></dt><dd><p>This callback also only needs to be implemented for
        callpoints specified for configuration data, and only if
        attributes are enabled in the ConfD configuration
        (<code class="sgmltag-element">/confdConfig/enableAttributes</code> set to
        <code class="constant">true</code>). See
        <code class="function">get_attrs()</code> above for the supported
        attributes.</p><p>The callback should set the attribute
        <em class="parameter"><code>attr</code></em> for the node given by
        <em class="parameter"><code>kp</code></em> to the value
        <em class="parameter"><code>v</code></em>. If the callback is invoked with NULL
        for the value argument, it means that the attribute should be
        deleted.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE.</p></dd><dt><span class="term"><code class="function">move_after()</code></span></dt><dd><p>This callback only needs to be implemented if we provide
        configuration data that has YANG lists or leaf-lists with a
        <code class="code">ordered-by user</code> statement.  The callback moves the
        list entry or leaf-list element given by
        <em class="parameter"><code>kp</code></em>. If <em class="parameter"><code>prevkeys</code></em> is
        NULL, the entry/element is moved first in the list/leaf-list,
        otherwise it is moved after the entry/element given by
        <em class="parameter"><code>prevkeys</code></em>.  In this case, for a list,
        <em class="parameter"><code>prevkeys</code></em> is a pointer to an array of key
        values identifying an entry in the list. The array is terminated
        with an element that has type C_NOEXISTS. For a leaf-list,
        <em class="parameter"><code>prevkeys</code></em> is a pointer to an array with
        the leaf-list element followed by an element that has type
        C_NOEXISTS.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error, CONFD_DELAYED_RESPONSE or CONFD_ACCUMULATE.</p></dd><dt><span class="term"><code class="function">write_all()</code></span></dt><dd><p>This callback will only be invoked for a transaction hook
        specified with <code class="code">tailf:invocation-mode
        per-transaction;</code> - see the chapter <a class="link" href="ch10.html" title="Chapter&nbsp;10.&nbsp;Transformations, Hooks, Hidden Data and Symlinks">Transformations, Hooks, Hidden
        Data and Symlinks</a> in the User Guide. It is also the only
        callback that is invoked for such a hook. The callback is
        expected to make all the modifications to the current
        transaction that hook functionality requires. The
        <em class="parameter"><code>kp</code></em> parameter is currently always NULL,
        since the callback does not pertain to any particular data
        node.</p><p>The callback must return CONFD_OK on success, CONFD_ERR
        on error, or CONFD_DELAYED_RESPONSE.</p></dd></dl></div><p>The six write callbacks (excluding
        <code class="function">write_all()</code>), namely
        <code class="function">set_elem()</code>,
        <code class="function">create()</code>, <code class="function">remove()</code>,
        <code class="function">set_case()</code>, <code class="function">set_attr()</code>,
        and <code class="function">move_after()</code>
        may return the
        value CONFD_ACCUMULATE.  If CONFD_ACCUMULATE is returned the
        library will accumulate the written values as a linked list of
        operations.  This list can later be traversed in either of the
        transaction callbacks <code class="function">prepare()</code> or
        <code class="function">commit()</code>.</p><p>This provides trivial transaction support for
        applications that want to implement the ConfD two-phase commit
        protocol but lacks an underlying database with proper
        transaction support.  The write operations are available as a
        linked list of confd_tr_item structs:</p><div class="informalexample"><a name="struct.confd_tr_item"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_tr_item {
    <strong class="hl-keyword">char</strong> *callpoint;
    <strong class="hl-keyword">enum</strong> confd_tr_op op;
    confd_hkeypath_t *hkp;
    confd_value_t *val;
    confd_value_t *choice;  <em class="hl-comment" style="color: silver">/* only for set_case */</em>
    u_int32_t attr;         <em class="hl-comment" style="color: silver">/* only for set_attr */</em>
    <strong class="hl-keyword">struct</strong> confd_tr_item *next;
};</pre></div><p>The list is available in the transaction context in the
        field <code class="varname">accumulated</code>. The entire list and
        its content will be automatically freed by the library once the
        transaction finishes.</p><div class="funcsynopsis"><a name="fn.confd_register_range_data_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int  <b class="fsfunc">confd_register_range_data_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_data_cbs *<var class="pdparam">data</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">lower</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">upper</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">numkeys</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This is a variant of
  <code class="function">confd_register_data_cb()</code> which registers a set
  of callbacks for a range of list entries. There can thus be multiple
  sets of C functions registered on the same callpoint, even by
  different daemons.  The <em class="parameter"><code>lower</code></em> and
  <em class="parameter"><code>upper</code></em> parameters are two
  <em class="parameter"><code>numkeys</code></em> long arrays of key values, which define
  the endpoints of the list range.
  It is also possible to do a "default" registration, by
  giving <em class="parameter"><code>lower</code></em> and <em class="parameter"><code>upper</code></em>
  as NULL (<em class="parameter"><code>numkeys</code></em> is ignored). The callbacks for
  the default registration will be invoked when the keys are not in any
  of the explicitly registered ranges.</p><p>The <em class="parameter"><code>fmt</code></em> and remaining
  parameters specify a string path for the list that the
  keys apply to, in the same form as for the
  <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a> and
  <a class="link" href="rn02re09.html" title="confd_lib_cdb">confd_lib_cdb(3)</a>
  functions. However if the list is a sublist to another list, the key
  element for the parent list(s) may be completely omitted, to indicate
  that the registration applies to all entries for the parent list(s)
  (similar to CDB subscription paths).</p><p>An example that registers one set of callbacks for the range
  <code class="sgmltag-element">/servers/server{aaa}</code> -
  <code class="sgmltag-element">/servers/server{mzz}</code> and another set for
  <code class="sgmltag-element">/servers/server{naa}</code> -
  <code class="sgmltag-element">/servers/server{zzz}</code>:</p><div class="informalexample"><pre class="programlisting">confd_value_t lower, upper;

CONFD_SET_STR(&amp;lower, "aaa");
CONFD_SET_STR(&amp;upper, "mzz");
if (confd_register_range_data_cb(dctx, &amp;data_cb1, &amp;lower, &amp;upper, 1,
                                 "/servers/server") == CONFD_ERR)
    confd_fatal("Failed to register data cb\n");

CONFD_SET_STR(&amp;lower, "naa");
CONFD_SET_STR(&amp;upper, "zzz");
if (confd_register_range_data_cb(dctx, &amp;data_cb2, &amp;lower, &amp;upper, 1,
                                 "/servers/server") == CONFD_ERR)
    confd_fatal("Failed to register data cb\n");</pre></div><p>In this example, as in most cases where this function is used,
  the data model defines a list with a single key, and
  <em class="parameter"><code>numkeys</code></em> is thus always
  <code class="constant">1</code>. However it can also be used for lists that
  have multiple keys, in which case the <em class="parameter"><code>upper</code></em> and
  <em class="parameter"><code>lower</code></em> arrays may be populated with multiple
  keys, upto however many keys the data model specifies for the list,
  and <em class="parameter"><code>numkeys</code></em> gives the number of keys in the
  arrays. If fewer keys than specified in the data model are given, the
  registration covers all possible values for the remaining keys, i.e.
  they are effectively wildcarded.</p><p>While traversal of a list with range registrations will always
  invoke e.g. <code class="function">get_next()</code> only for actually
  registered ranges, it is also possible that a request from a
  northbound interface is made for data in a specific list entry. If the
  registrations do not cover all possible key values, such a request
  could be for a list entry that does not fall in any of the registered
  ranges, which will result in a "no registration" error. To avoid the
  error, we can either restrict the type of the keys such that only
  values that fall in the registered ranges are valid, or, for
  operational data, use a "default" registration as described above.  In
  this case the daemon with the "default" registration would just reply
  with <code class="function">confd_data_reply_not_found()</code> for all
  requests for specific data, and
  <code class="function">confd_data_reply_next_key()</code> with NULL for the key
  values for all <code class="function">get_next()</code> etc requests.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For a given callpoint name, there can only be either one
  non-range registration or a number of range registrations that all
  pertain to the same list. If a range registration is done after a
  non-range registration or vice versa, or if a range registration is
  done with a different list path than earlier range registrations, the
  latest registration completely replaces the earlier one(s). If we want
  to register for the same ranges in different lists, we must thus have
  a unique callpoint for each list.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Range registrations can not be used for lists that have
  the <code class="code">tailf:secondary-index</code> extension, since there is no
  way for ConfD to traverse the registrations in secondary-index
  order.</p></div><div class="funcsynopsis"><a name="fn.confd_register_usess_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_usess_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_usess_cbs *<var class="pdparam">ucb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to register information callbacks
  that are invoked for user session start and stop. The
  <span class="type">struct confd_usess_cbs</span> is defined as:</p><div class="informalexample"><a name="struct.confd_usess_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_usess_cbs {
    <strong class="hl-keyword">void</strong> (*start)(<strong class="hl-keyword">struct</strong> confd_daemon_ctx *dx,
                  <strong class="hl-keyword">struct</strong> confd_user_info *uinfo);
    <strong class="hl-keyword">void</strong> (*stop)(<strong class="hl-keyword">struct</strong> confd_daemon_ctx *dx,
                 <strong class="hl-keyword">struct</strong> confd_user_info *uinfo);
};</pre></div><p>Both callbacks are optional. They can be used e.g. for a
  multi-threaded daemon to manage a pool of worker threads, by
  allocating worker threads to user sessions. In this case we would
  ideally allocate a worker thread the first time an
  <code class="function">init()</code> callback for a given user session
  requires a worker socket to be assigned, and use only the
  <code class="function">stop()</code> usess callback to release the worker
  thread - using the <code class="function">start()</code> callback to allocate
  a worker thread would often mean that we allocated a thread that was
  never used. The <code class="varname">u_opaque</code> element in the
  <span class="type">struct confd_user_info</span> can be used to manage
  such allocations.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These callbacks will only be invoked if the daemon has
  also registered other callbacks. Furthermore, as an optimization,
  ConfD will delay the invocation of the <code class="function">start()</code>
  callback until some other callback is invoked. This means that if no
  other callbacks for the daemon are invoked for the duration of a user
  session, neither <code class="function">start()</code> nor
  <code class="function">stop()</code> will be invoked for that user session.
  If we want timely notification of start and stop for all user
  sessions, we can subscribe to <code class="constant">CONFD_NOTIF_AUDIT</code>
  events, see <a class="link" href="rn02re11.html" title="confd_lib_events">confd_lib_events(3)</a>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When we call <code class="function">confd_register_done()</code>
  (see below), the <code class="function">start()</code> callback (if
  registered) will be invoked for each user session that already
  exists.</p></div><div class="funcsynopsis"><a name="fn.confd_register_done"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_done</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>When we have registered all the callbacks for a daemon
  (including the other types described below if we have them), we must
  call this function to synchronize with ConfD. No callbacks will be
  invoked until it has been called, and after the call, no further
  registrations are allowed.</p><div class="funcsynopsis"><a name="fn.confd_fd_ready"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_fd_ready</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">fd</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The database application owns all data provider sockets to
    ConfD and is responsible for the polling of these sockets. When
    one of the ConfD sockets has I/O ready to read, the application
    must invoke <code class="function">confd_fd_ready()</code> on the
    socket. This function will:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Read data from ConfD</p></li><li class="listitem"><p>Unmarshal this data</p></li><li class="listitem"><p>Invoke the right callback with the right arguments</p></li></ul></div><p>When this function reads the request from from ConfD it will
    block on <code class="function">read()</code>, thus if it is important for
    the application to have nonblocking I/O, the application must
    dispatch I/O from ConfD in a separate thread.</p><p>The function returns the return value from the callback
    function, normally CONFD_OK (0), or CONFD_ERR (-1) on error and
    CONFD_EOF (-2) when the socket to ConfD has been closed. Thus
    CONFD_ERR can mean either that the callback function that was
    invoked returned CONFD_ERR, or that some error condition occurred
    within the <code class="function">confd_fd_ready()</code> function. These
    cases can be distinguished via <code class="varname">confd_errno</code>, which
    will be set to CONFD_ERR_EXTERNAL if CONFD_ERR comes from the
    callback function. Thus a correct call to
    <code class="function">confd_fd_ready()</code> looks like:</p><div class="informalexample"><pre class="programlisting">struct pollfd set[n];
/* ...... */

if (set[0].revents &amp; POLLIN) {
    if ((ret = confd_fd_ready(dctx, mysock)) == CONFD_EOF) {
        confd_fatal("ConfD socket closed\n");
    } else if (ret == CONFD_ERR &amp;&amp;
               confd_errno != CONFD_ERR_EXTERNAL) {
        confd_fatal("Error on ConfD socket request: %s (%d): %s\n",
                    confd_strerror(confd_errno), confd_errno,
                    confd_lasterr());
    }
}</pre></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_PROTOUSAGE, CONFD_ERR_EXTERNAL</p><div class="funcsynopsis"><a name="fn.confd_trans_set_fd"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_trans_set_fd</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Associate a worker socket with the transaction, or validation
  phase. This function must be called in the transaction and validation
  <code class="function">init()</code> callbacks - a minimal implementation of a
  transaction <code class="function">init()</code> callback looks like:</p><div class="informalexample"><pre class="programlisting">static int init(struct confd_trans_ctx *tctx)
{
    confd_trans_set_fd(tctx, workersock);
    return CONFD_OK;
}</pre></div><div class="funcsynopsis"><a name="fn.confd_data_reply_value"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_value</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">v</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used to return a single data item to ConfD.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE</p><div class="funcsynopsis"><a name="fn.confd_data_reply_value_array"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_value_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">vs</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used to return an array of values,
  corresponding to a complete list entry, to ConfD. It can be
  used by the optional <code class="function">get_object()</code> callback.  The
  <em class="parameter"><code>vs</code></em> array is populated with
  <em class="parameter"><code>n</code></em> values according to the specification of the
  Value Array format in the <a class="link" href="rn02re15.html#man.3.confd_types.xml_structures" title="XML STRUCTURES">XML STRUCTURES</a>
  section of the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
  page.</p><p>In the easiest case, similar to the "servers" example above,
  we can construct a reply array as follows:</p><div class="informalexample"><pre class="programlisting">struct in_addr ip4 = my_get_ip(.....);
confd_value_t ret[3];

CONFD_SET_STR(&amp;ret[0], "www");
CONFD_SET_IPV4(&amp;ret[1], ip4);
CONFD_SET_UINT16(&amp;ret[2], 80);
confd_data_reply_value_array(tctx, ret, 3);</pre></div><p>Any containers inside the object must also be passed in the
  array.  For example an entry in the <code class="sgmltag-element">b</code> list used in the explanation for
  <code class="function">exists_optional()</code> would have to be passed
  as:</p><div class="informalexample"><pre class="programlisting">confd_value_t ret[4];

CONFD_SET_STR(&amp;ret[0], "b_name");
CONFD_SET_XMLTAG(&amp;ret[1], myprefix_opt, myprefix__ns);
CONFD_SET_INT32(&amp;ret[2], 77);
CONFD_SET_NOEXISTS(&amp;ret[3]);

confd_data_reply_value_array(tctx, ret, 4);</pre></div><p>Thus, a container or a leaf of type <code class="code">empty</code> must be
  passed as its equivalent XML tag if it exists. If a
  <code class="code">presence</code> container or leaf of type <code class="code">empty</code>
  does not exist, it must be passed as a
  value of C_NOEXISTS.  In the example above, the leaf <code class="sgmltag-element">foo</code> does
  not exist, thus the contents of position <code class="constant">3</code> in the
  array.</p><p>If a <code class="code">presence</code> container does not exist, its non existing
  values must not be passed - it suffices to say that the container
  itself does not exist. In the example above, the <code class="sgmltag-element">opt</code> container did
  exist and thus we also had to pass the contained value(s), the <code class="sgmltag-element">ii</code>
  leaf.</p><p>Hence, the above example represents:</p><div class="informalexample"><pre class="programlisting">&lt;b&gt;
   &lt;name&gt;b_name&lt;/name&gt;
   &lt;opt&gt;
      &lt;ii&gt;77&lt;/ii&gt;
   &lt;/opt&gt;
&lt;/b&gt;</pre></div><div class="funcsynopsis"><a name="fn.confd_data_reply_tag_value_array"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_tag_value_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">tvs</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used to return an array of values,
  corresponding to a complete list entry, to ConfD. It can be
  used by the optional <code class="function">get_object()</code> callback.  The
  <em class="parameter"><code>tvs</code></em> array is populated with
  <em class="parameter"><code>n</code></em> values according to the specification of the
  Tagged Value Array format in the <a class="link" href="rn02re15.html#man.3.confd_types.xml_structures" title="XML STRUCTURES">XML STRUCTURES</a>
  section of the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
  page.</p><p>I.e. the difference from
  <code class="function">confd_data_reply_value_array()</code> is that the
  values are tagged with the node names from the data model - this means
  that non-existing values can simply be omitted from the array, per the
  specification above. Additionally the key leafs can be omitted,
  since they are already known by ConfD - if the key leafs are
  included, they will be ignored. Finally, in e.g. the case of a
  container with both config and non-config data, where the config
  data is in CDB and only the non-config data provided by the
  callback, the config elements can be omitted (for
  <code class="function">confd_data_reply_value_array()</code> they must be
  included as C_NOEXISTS elements).</p><p>However, although the tagged value array format can represent
  nested lists, these must not be passed via this
  function, since the <code class="function">get_object()</code> callback only
  pertains to a single entry of one list. Nodes
  representing sub-lists must thus be omitted from the
  array, and ConfD will issue separate
  <code class="function">get_object()</code> invocations to retrieve the data
  for those.</p><p>Using the same examples as above, in the "servers" case, we
  can construct a reply array as follows:</p><div class="informalexample"><pre class="programlisting">struct in_addr ip4 = my_get_ip(.....);
confd_tag_value_t ret[2];
int n = 0;

CONFD_SET_TAG_IPV4(&amp;ret[n], myprefix_ip, ip4); n++;
CONFD_SET_TAG_UINT16(&amp;ret[n], myprefix_port, 80); n++;
confd_data_reply_tag_value_array(tctx, ret, n);</pre></div><p>An entry in the <code class="sgmltag-element">b</code> list used in the explanation for
  <code class="function">exists_optional()</code> would be passed as:</p><div class="informalexample"><pre class="programlisting">confd_tag_value_t ret[3];
int n = 0;

CONFD_SET_TAG_XMLBEGIN(&amp;ret[n], myprefix_opt, myprefix__ns); n++;
CONFD_SET_TAG_INT32(&amp;ret[n], myprefix_ii, 77); n++;
CONFD_SET_TAG_XMLEND(&amp;ret[n], myprefix_opt, myprefix__ns); n++;
confd_data_reply_tag_value_array(tctx, ret, n);</pre></div><p>The C_XMLEND element is not strictly necessary in this case,
  since there are no subsequent elements in the array. However it
  would have been required if the optional <code class="sgmltag-element">foo</code> leaf had existed,
  thus it is good practice to always include both the C_XMLBEGIN and
  C_XMLEND elements for nested containers (if they exist, that is -
  otherwise neither must be included).</p><div class="funcsynopsis"><a name="fn.confd_data_reply_next_key"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_key</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_vals_in_key</var>, </td></tr><tr><td>&nbsp;</td><td>long <var class="pdparam">next</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the <code class="function">get_next()</code> and
  <code class="function">find_next()</code> callbacks to return the next key, or
  the next leaf-list element in case <code class="function">get_next()</code> is
  invoked for a leaf-list.
  A list may have multiple
  key leafs specified in the data model. The parameter
  <em class="parameter"><code>num_vals_in_key</code></em> indicates the number of key
  values, i.e. the length of the <em class="parameter"><code>v</code></em> array. In
  the typical case with a list having just a single key
  leaf specified, <em class="parameter"><code>num_vals_in_key</code></em> is always 1.
  For a leaf-list, <em class="parameter"><code>num_vals_in_key</code></em> is always
  1.</p><p>The <em class="parameter"><code>long next</code></em> will be passed into the
  next invocation of the <code class="function">get_next()</code>
  callback if it has a value other than <code class="constant">-1</code>.
  Thus this value provides a means for the application to
  traverse the data. Since this is <span class="type">long</span> it is
  possible to pass a <span class="type">void*</span> pointing to the next
  list entry in the application - effectively passing a pointer to
  confd and getting it back in the next invocation of
  <code class="function">get_next()</code>.</p><p>To indicate that no more entries exist, we reply with a NULL
  pointer for the <em class="parameter"><code>v</code></em> array. The values of the
  <em class="parameter"><code>num_vals_in_key</code></em> and <em class="parameter"><code>next</code></em>
  parameters are ignored in this case.</p><p>Passing the value <code class="constant">-1</code> for
  <em class="parameter"><code>next</code></em> has a special meaning. It tells ConfD that
  we want the next request for this list traversal to use the
  <code class="function">find_next()</code> (or
  <code class="function">find_next_object()</code>) callback instead of
  <code class="function">get_next()</code> (or
  <code class="function">get_next_object()</code>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the case of list traversal by means of a secondary
  index, the secondary index values must be unique for entry-by-entry
  traversal with
  <code class="function">find_next()</code>/<code class="function">find_next_object()</code>
  to be possible. Thus we can not pass <code class="constant">-1</code> for the
  <em class="parameter"><code>next</code></em> parameter in this case if the secondary
  index values are not unique.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE</p><div class="funcsynopsis"><a name="fn.confd_data_reply_not_found"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_not_found</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the <code class="function">get_elem()</code>
  and <code class="function">exists_optional()</code> callbacks to indicate to
  ConfD that a list entry or node does not exist.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.confd_data_reply_found"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_found</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the
  <code class="function">exists_optional()</code> callback to indicate to ConfD
  that a node does exist.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.confd_data_reply_next_object_array"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>long <var class="pdparam">next</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the optional
  <code class="function">get_next_object()</code> and
  <code class="function">find_next_object()</code> callbacks to return an entire
  object including its keys, as well as the <em class="parameter"><code>next</code></em>
  parameter that has the same function as for
  <code class="function">confd_data_reply_next_key()</code>.
  It combines the functions of
  <code class="function">confd_data_reply_next_key()</code> and
  <code class="function">confd_data_reply_value_array()</code>.</p><p>The array of <span class="type">confd_value_t</span> elements must be
  populated in exactly the same manner as for
  <code class="function">confd_data_reply_value_array()</code> and the
  <em class="parameter"><code>long next</code></em> is used in the same manner as the
  equivalent <em class="parameter"><code>next</code></em> parameter in
  <code class="function">confd_data_reply_next_key()</code>.  To indicate the
  end of the list we - similar to
  <code class="function">confd_data_reply_next_key()</code> - pass a NULL
  pointer for the value array.</p><p>If we are replying to a <code class="function">get_next_object()</code>
  or <code class="function">find_next_object()</code>
  request for an operational data list without keys (see the <a class="link" href="ch06.html#ug.opdata.without_keys" title="6.11.&nbsp;Operational data lists without keys">Operational Data chapter in the
  User Guide</a>), we must include the "pseudo" key in the array, as
  the first element (i.e. preceding the actual leafs from the data
  model).</p><p>If we are replying to a <code class="function">get_next_object()</code>
  request for a leaf-list, we must pass the value of the leaf-list
  element as the only element in the array.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE</p><div class="funcsynopsis"><a name="fn.confd_data_reply_next_object_tag_value_array"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_tag_value_array</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">tv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>long <var class="pdparam">next</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the optional
  <code class="function">get_next_object()</code> and
  <code class="function">find_next_object()</code> callbacks to return an entire
  object including its keys, as well as the <em class="parameter"><code>next</code></em>
  parameter that has the same function as for
  <code class="function">confd_data_reply_next_key()</code>.
  It combines the functions of
  <code class="function">confd_data_reply_next_key()</code> and
  <code class="function">confd_data_reply_tag_value_array()</code>.</p><p>Similar to how the
  <code class="function">confd_data_reply_value_array()</code> has its
  companion function
  <code class="function">confd_data_reply_tag_value_array()</code> if we want
  to return an object as an array of <span class="type">confd_tag_value_t</span>
  values instead of an array of <span class="type">confd_value_t</span> values, we
  can use this function instead of
  <code class="function">confd_data_reply_next_object_array()</code> when we
  wish to return values from the
  <code class="function">get_next_object()</code> callback.</p><p>The array of <span class="type">confd_tag_value_t</span> elements must be
  populated in exactly the same manner as for
  <code class="function">confd_data_reply_tag_value_array()</code> (except that
  the key values must be included), and the <em class="parameter"><code>long
  next</code></em> is used in the same manner as the equivalent
  <em class="parameter"><code>next</code></em> parameter in
  <code class="function">confd_data_reply_next_key()</code>.
  The key leafs must always be given as the first
  elements of the array, and in the order specified in the data model.
  To indicate the end of the list we - similar to
  <code class="function">confd_data_reply_next_key()</code> - pass a NULL pointer
  for the value array.</p><p>If we are replying to a <code class="function">get_next_object()</code>
  or <code class="function">find_next_object()</code>
  request for an operational data list without keys (see the <a class="link" href="ch06.html#ug.opdata.without_keys" title="6.11.&nbsp;Operational data lists without keys">Operational Data chapter in the
  User Guide</a>), the "pseudo" key must be included, as the first
  element in the array, with a tag value of 0 - i.e. it can be set with
  code like this:</p><div class="informalexample"><pre class="programlisting">confd_tag_value_t tv[7];

CONFD_SET_TAG_INT64(&amp;tv[0], 0, 42);
</pre></div><p>Similarly, if we are replying to a
  <code class="function">get_next_object()</code> request for a leaf-list, we
  must pass the value of the leaf-list element as the only element in the
  array, with a tag value of 0.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE</p><div class="funcsynopsis"><a name="fn.confd_data_reply_next_object_arrays"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_arrays</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_next_object *<var class="pdparam">obj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nobj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_millisecs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the optional
  <code class="function">get_next_object()</code> and
  <code class="function">find_next_object()</code> callbacks to return multiple
  objects including their keys, in <span class="type">confd_value_t</span> form.
  The <span class="type">struct confd_next_object</span> is defined as:</p><div class="informalexample"><a name="struct.confd_next_object"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_next_object {
    confd_value_t *v;
    <strong class="hl-keyword">int</strong> n;
    <strong class="hl-keyword">long</strong> next;
};</pre></div><p>I.e. it corresponds exactly to the data provided for a call of
  <code class="function">confd_data_reply_next_object_array()</code>. The
  parameter <em class="parameter"><code>obj</code></em> is a pointer to an
  <em class="parameter"><code>nobj</code></em> elements long array of such structs. We
  can also pass a timeout value for ConfD's caching of the returned data
  via <em class="parameter"><code>timeout_millisecs</code></em>. If we pass 0 for this
  parameter, the value configured via
  <code class="sgmltag-element">/confdConfig/capi/objectCacheTimeout</code> in
  <code class="filename">confd.conf</code> (see <a class="link" href="rn03re17.html" title="confd.conf">confd.conf(5)</a>) will be
  used.</p><p>The cache in ConfD may become invalid (e.g. due to timeout)
  before all the returned list entries have been used, and ConfD may
  then need to issue a new callback request based on an "intermediate"
  <code class="varname">next</code> value. This is done exactly as for the
  single-entry case, i.e. if <code class="varname">next</code> is
  <code class="constant">-1</code>, <code class="function">find_next_object()</code> (or
  <code class="function">find_next()</code>) will be used, with the keys from the
  "previous" entry, otherwise <code class="function">get_next_object()</code> (or
  <code class="function">get_next()</code>) will be used, with the given
  <code class="varname">next</code> value.</p><p>Thus a data provider can choose to give <code class="varname">next</code>
  values that uniquely identify list entries if that is convenient, or
  otherwise use <code class="constant">-1</code> for all <code class="varname">next</code>
  elements - or a combination, e.g. <code class="constant">-1</code> for all but
  the last entry. If any <code class="varname">next</code> value is given as
  <code class="constant">-1</code>, at least one of the
  <code class="function">find_next()</code> and
  <code class="function">find_next_object()</code> callbacks must be
  registered.</p><p>To indicate the end of the list we can either pass a NULL
  pointer for the <em class="parameter"><code>obj</code></em> array, or pass an array
  where the last <span class="type">struct confd_next_object</span> element has the
  <code class="varname">v</code> element set to NULL. The latter is preferable,
  since we can then combine the final list entries with the end-of-list
  indication in the reply to a single callback invocation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When <code class="varname">next</code> values other than
  <code class="constant">-1</code> are used, these must remain valid even after
  the end of the list has been reached, since ConfD may still need to
  issue a new callback request based on an "intermediate"
  <code class="varname">next</code> value as described above. They can be
  discarded (e.g. allocated memory released) when a new
  <code class="function">get_next_object()</code> or
  <code class="function">find_next_object()</code> callback request for the same
  list in the same transaction has been received, or at the end of the
  transaction.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the case of list traversal by means of a secondary
  index, the secondary index values must be unique for entry-by-entry
  traversal with
  <code class="function">find_next_object()</code>/<code class="function">find_next()</code>
  to be possible. Thus we can not use <code class="constant">-1</code> for the
  <code class="varname">next</code> element in this case if the
  secondary index values are not unique.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE</p><div class="funcsynopsis"><a name="fn.confd_data_reply_next_object_tag_value_arrays"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_next_object_tag_value_arrays</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_tag_next_object *<var class="pdparam">tobj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nobj</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_millisecs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the optional
  <code class="function">get_next_object()</code> and
  <code class="function">find_next_object()</code> callbacks to return multiple
  objects including their keys, in <span class="type">confd_tag_value_t</span> form.
  The <span class="type">struct confd_tag_next_object</span> is defined as:</p><div class="informalexample"><a name="struct.confd_tag_next_object"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_tag_next_object {
    confd_tag_value_t *tv;
    <strong class="hl-keyword">int</strong> n;
    <strong class="hl-keyword">long</strong> next;
};</pre></div><p>I.e. it corresponds exactly to the data provided for a call of
  <code class="function">confd_data_reply_next_object_tag_value_array()</code>. The
  parameter <em class="parameter"><code>tobj</code></em> is a pointer to an
  <em class="parameter"><code>nobj</code></em> elements long array of such structs. We
  can also pass a timeout value for ConfD's caching of the returned data
  via <em class="parameter"><code>timeout_millisecs</code></em>. If we pass 0 for this
  parameter, the value configured via
  <code class="sgmltag-element">/confdConfig/capi/objectCacheTimeout</code> in
  <code class="filename">confd.conf</code> (see <a class="link" href="rn03re17.html" title="confd.conf">confd.conf(5)</a>) will be
  used.</p><p>The cache in ConfD may become invalid (e.g. due to timeout)
  before all the returned list entries have been used, and ConfD may
  then need to issue a new callback request based on an "intermediate"
  <code class="varname">next</code> value. This is done exactly as for the
  single-entry case, i.e. if <code class="varname">next</code> is
  <code class="constant">-1</code>, <code class="function">find_next_object()</code> (or
  <code class="function">find_next()</code>) will be used, with the keys from the
  "previous" entry, otherwise <code class="function">get_next_object()</code> (or
  <code class="function">get_next()</code>) will be used, with the given
  <code class="varname">next</code> value.</p><p>Thus a data provider can choose to give <code class="varname">next</code>
  values that uniquely identify list entries if that is convenient, or
  otherwise use <code class="constant">-1</code> for all <code class="varname">next</code>
  elements - or a combination, e.g. <code class="constant">-1</code> for all but
  the last entry. If any <code class="varname">next</code> value is given as
  <code class="constant">-1</code>, at least one of the
  <code class="function">find_next()</code> and
  <code class="function">find_next_object()</code> callbacks must be
  registered.</p><p>To indicate the end of the list we can either pass a NULL
  pointer for the <em class="parameter"><code>tobj</code></em> array, or pass an array
  where the last <span class="type">struct confd_tag_next_object</span> element has the
  <code class="varname">tv</code> element set to NULL. The latter is preferable,
  since we can then combine the final list entries with the end-of-list
  indication in the reply to a single callback invocation.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When <code class="varname">next</code> values other than
  <code class="constant">-1</code> are used, these must remain valid even after
  the end of the list has been reached, since ConfD may still need to
  issue a new callback request based on an "intermediate"
  <code class="varname">next</code> value as described above. They can be
  discarded (e.g. allocated memory released) when a new
  <code class="function">get_next_object()</code> or
  <code class="function">find_next_object()</code> callback request for the same
  list in the same transaction has been received, or at the end of the
  transaction.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the case of list traversal by means of a secondary
  index, the secondary index values must be unique for entry-by-entry
  traversal with
  <code class="function">find_next_object()</code>/<code class="function">find_next()</code>
  to be possible. Thus we can not use <code class="constant">-1</code> for the
  <code class="varname">next</code> element in this case if the
  secondary index values are not unique.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE</p><div class="funcsynopsis"><a name="fn.confd_data_reply_attrs"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_reply_attrs</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_attr_value_t *<var class="pdparam">attrs</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_attrs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the <code class="function">get_attrs()</code>
  callback to return the requested attribute values. The
  <em class="parameter"><code>attrs</code></em> array should be populated with
  <em class="parameter"><code>num_attrs</code></em> elements of type
  <span class="type">confd_attr_value_t</span>, which is defined as:</p><div class="informalexample"><a name="struct.confd_attr_value"></a><pre class="programlisting"><strong class="hl-keyword">typedef</strong> <strong class="hl-keyword">struct</strong> confd_attr_value {
    u_int32_t attr;
    confd_value_t v;
} confd_attr_value_t;</pre></div><p>If multiple attributes were requested in the callback
  invocation, they should be given in the same order in the reply as in
  the request. Requested attributes that are not set should be omitted
  from the array. If none of the requested attributes are set, or no
  attributes at all are set when all attributes are requested,
  <em class="parameter"><code>num_attrs</code></em> should be given as 0, and the value
  of <em class="parameter"><code>attrs</code></em> is ignored.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADTYPE</p><div class="funcsynopsis"><a name="fn.confd_delayed_reply_ok"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_delayed_reply_ok</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function must be used to return the equivalent of CONFD_OK
  when the actual callback returned CONFD_DELAYED_RESPONSE. I.e. it is
  appropriate for a transaction callback, a data callback for a write
  operation, or a validation callback, when the result is
  successful.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.confd_delayed_reply_error"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_delayed_reply_error</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">errstr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function must be used to return an error when the actual
  callback returned CONFD_DELAYED_RESPONSE. There are two cases where
  the value of <em class="parameter"><code>errstr</code></em> has a special
  significance:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">"locked" after invocation of
    <code class="function">trans_lock()</code></span></dt><dd><p>This is equivalent to returning CONFD_ALREADY_LOCKED
    from the callback.</p></dd><dt><span class="term">"in_use" after invocation of
    <code class="function">write_start()</code> or
    <code class="function">prepare()</code></span></dt><dd><p>This is equivalent to returning CONFD_IN_USE from
    the callback.</p></dd></dl></div><p>In all other cases, calling
  <code class="function">confd_delayed_reply_error()</code> is equivalent to
  calling <code class="function">confd_trans_seterr()</code> with the
  <em class="parameter"><code>errstr</code></em> value and returning CONFD_ERR from the
  callback. It is also possible to first call
  <code class="function">confd_trans_seterr()</code> (for the varargs format) or
  <code class="function">confd_trans_seterr_extended()</code> etc (for <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> as described in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>), and then
  call <code class="function">confd_delayed_reply_error()</code> with NULL for
  <em class="parameter"><code>errstr</code></em>.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.confd_data_set_timeout"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_data_set_timeout</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>A data callback should normally complete "quickly", since
  e.g. the execution of a 'show' command in the CLI may require many
  data callback invocations. Thus it should be possible to set the
  <code class="sgmltag-element">/confdConfig/capi/queryTimeout</code> in
  <code class="filename">confd.conf</code> (see above) such that it covers the
  longest possible execution time for any data callback. In some rare
  cases it may still be necessary for a data callback to have a longer
  execution time, and then this function can be used to extend (or
  shorten) the timeout for the current callback invocation. The timeout
  is given in seconds from the point in time when the function is
  called.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.confd_trans_seterr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_trans_seterr</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the application to set an error
  string.  The next transaction or data callback which returns CONFD_ERR will
  have this error description attached to it.  This error may
  propagate to the CLI, the NETCONF manager, the Web UI or the log
  files depending on the situation. We also use this function to
  propagate warning messages from the <code class="function">validate()</code>
  callback if we are doing semantic validation in C. The
  <em class="parameter"><code>fmt</code></em> argument is a printf style format string.</p><div class="funcsynopsis"><a name="fn.confd_trans_seterr_extended"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_trans_seterr_extended</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide more structured error
  information from a transaction or data callback, see the section
  <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_trans_seterr_extended_info"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_trans_seterr_extended_info</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide structured error
  information in the same way as
  <code class="function">confd_trans_seterr_extended()</code>, and additionally
  provide contents for the NETCONF &lt;error-info&gt; element. See the
  section <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_db_seterr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_db_seterr</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is used by the application to set an error
  string.  The next db callback function which returns CONFD_ERR will
  have this error description attached to it.  This error may
  propagate to the CLI, the NETCONF manager, the Web UI or the log
  files depending on the situation.  The <em class="parameter"><code>fmt</code></em>
  argument is a printf style format string.</p><div class="funcsynopsis"><a name="fn.confd_db_seterr_extended"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_db_seterr_extended</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide more structured error
  information from a db callback, see the section
  <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_db_seterr_extended_info"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_db_seterr_extended_info</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide structured error
  information in the same way as
  <code class="function">confd_db_seterr_extended()</code>, and additionally
  provide contents for the NETCONF &lt;error-info&gt; element. See the
  section <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_db_set_timeout"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_db_set_timeout</b>(</code></td><td>struct confd_db_ctx *<var class="pdparam">dbx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Some of the DB callbacks registered via
  <code class="function">confd_register_db_cb()</code>, e.g.
  <code class="function">copy_running_to_startup()</code>, may require a longer
  execution time than others, and in these cases the timeout specified
  for <code class="sgmltag-element">/confdConfig/capi/newSessionTimeout</code> may be
  insufficient. This function can then be used to extend the timeout for
  the current callback invocation. The timeout is given in seconds from
  the point in time when the function is called.</p><div class="funcsynopsis"><a name="fn.confd_aaa_reload"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_aaa_reload</b>(</code></td><td>const struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>When the ConfD AAA tree is populated by an external data
  provider (see the <a class="link" href="ch14.html#ug.aaa.authentication" title="14.4.&nbsp;Authentication">AAA
  chapter in the User Guide</a>), this function can be used by the
  data provider to notify ConfD when there is a change to the AAA data.
  I.e. it is an alternative to executing the command <span class="command"><strong>confd
  --clear-aaa-cache</strong></span>. See also
  <code class="function">maapi_aaa_reload()</code> in <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_install_crypto_keys"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_install_crypto_keys</b>(</code></td><td>struct confd_daemon_ctx* <var class="pdparam">dtx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>It is possible to define DES3 and AES keys inside
  confd.conf. These keys are used by ConfD to encrypt data which is
  entered into the system which has either of the two builtin types
  <span class="type">tailf:des3-cbc-encrypted-string</span> or
  <span class="type">tailf:aes-cfb-128-encrypted-string</span>. See
  <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a>.</p><p>This function will copy those keys from ConfD (which reads
  confd.conf) into memory in the library. The parameter
  <em class="parameter"><code>dtx</code></em> is a daemon context which is connected
  through a call to <code class="function">confd_connect()</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The function must be called before
  <code class="function">confd_register_done()</code> is called. If this is
  impractical, or if the application doesn't otherwise use a daemon
  context, the equivalent function
  <code class="function">maapi_install_crypto_keys()</code> may be more
  convenient to use, see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>.</p></div></div><div class="refsect1"><a name="man.3.confd_lib_dp.service_callbacks"></a><h2>NCS SERVICE CALLBACKS</h2><p>NCS service callbacks are invoked in a manner similar to the
  data callbacks described above, but require a registration for a
  service point, specified as <code class="code">ncs:servicepoint</code> in the data
  model. The <code class="function">init()</code> transaction callback must also
  be registered, and must use the
  <code class="function">confd_trans_set_fd()</code> function to assign a worker
  socket for the transaction.</p><div class="funcsynopsis"><a name="fn.ncs_register_service_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ncs_register_service_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct ncs_service_cbs *<var class="pdparam">scb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function registers the service callbacks. The <span class="type">struct
  ncs_service_cbs</span> is defined as:</p><div class="informalexample"><a name="struct.ncs_name_value"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> ncs_name_value {
    <strong class="hl-keyword">char</strong> *name;
    <strong class="hl-keyword">char</strong> *value;
};</pre><a name="enum.ncs_service_operation"></a><pre class="programlisting"><strong class="hl-keyword">enum</strong> ncs_service_operation {
    NCS_SERVICE_CREATE = <span class="hl-number">0</span>,
    NCS_SERVICE_UPDATE = <span class="hl-number">1</span>,
    NCS_SERVICE_DELETE = <span class="hl-number">2</span>
};</pre><a name="struct.ncs_service_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> ncs_service_cbs {
    <strong class="hl-keyword">char</strong> servicepoint[MAX_CALLPOINT_LEN];

    <strong class="hl-keyword">int</strong> (*pre_modification)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                            <strong class="hl-keyword">enum</strong> ncs_service_operation op,
                            confd_hkeypath_t *kp,
                            <strong class="hl-keyword">struct</strong> ncs_name_value *proplist,
                            <strong class="hl-keyword">int</strong> num_props);
    <strong class="hl-keyword">int</strong> (*pre_lock_create)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                           confd_hkeypath_t *kp,
                           <strong class="hl-keyword">struct</strong> ncs_name_value *proplist,
                           <strong class="hl-keyword">int</strong> num_props, <strong class="hl-keyword">int</strong> fastmap_thandle);
    <strong class="hl-keyword">int</strong> (*create)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx, confd_hkeypath_t *kp,
                  <strong class="hl-keyword">struct</strong> ncs_name_value *proplist, <strong class="hl-keyword">int</strong> num_props,
                  <strong class="hl-keyword">int</strong> fastmap_thandle);
    <strong class="hl-keyword">int</strong> (*post_modification)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                             <strong class="hl-keyword">enum</strong> ncs_service_operation op,
                             confd_hkeypath_t *kp,
                             <strong class="hl-keyword">struct</strong> ncs_name_value *proplist,
                             <strong class="hl-keyword">int</strong> num_props);
    <strong class="hl-keyword">void</strong> *cb_opaque; <em class="hl-comment" style="color: silver">/* private user data    */</em>
};</pre></div><p>The <code class="function">create()</code> callback is invoked inside NCS
  FASTMAP when creation or update of a service instance is committed.
  It should attach to the FASTMAP transaction by means of
  <code class="function">maapi_attach2()</code> (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>),
  passing the <em class="parameter"><code>fastmap_thandle</code></em> transaction handle
  as the <em class="parameter"><code>thandle</code></em> parameter to
  <code class="function">maapi_attach2()</code>. The <em class="parameter"><code>usid</code></em>
  parameter for <code class="function">maapi_attach2()</code> should be given as
  0. To modify data in the FASTMAP transaction, the NCS-specific
  <code class="function">maapi_shared_xxx()</code> functions must be used, see
  the section NCS SPECIFIC
  FUNCTIONS in the <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a> manual
  page.</p><p>The <code class="function">pre_lock_create()</code> callback is invoked
  in the same way as the <code class="function">create()</code> callback. The
  difference is that this callback is invoked outside the transaction
  lock of the current transaction, and may thus run in parallel with
  <code class="function">pre_lock_create()</code> invocations in other
  transactions.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A service can only register one of the two
  functions <code class="function">create()</code> and
  <code class="function">pre_lock_create()</code></p></div><p>The <code class="function">pre_modification()</code> and
  <code class="function">post_modification()</code> callbacks are optional, and
  are invoked outside FASTMAP. <code class="function">pre_modification()</code>
  is invoked before create, update, or delete of the service, as
  indicated by the <em class="parameter"><code>enum ncs_service_operation op</code></em>
  parameter.  Conversely <code class="function">post_modification()</code> is
  invoked after create, update, or delete of the service. These
  functions can be useful e.g. for allocations that should be stored and
  existing also when the service instance is removed.</p><p>All the callbacks receive a property list via the
  <em class="parameter"><code>proplist</code></em> and <em class="parameter"><code>num_props</code></em>
  parameters. This list is initially empty
  (<em class="parameter"><code>proplist</code></em> == NULL and
  <em class="parameter"><code>num_props</code></em> == 0), but it can be used to store
  and later modify persistent data outside the service model that might
  be needed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We must call the
  <code class="function">confd_register_done()</code> function when we are done
  with all registrations for a daemon, see above.</p></div><div class="funcsynopsis"><a name="fn.ncs_service_reply_proplist"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ncs_service_reply_proplist</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct ncs_name_value *<var class="pdparam">proplist</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_props</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function must be called with the new property list,
  immediately prior to returning from the callback, if the stored
  property list should be updated. If a callback returns without calling
  <code class="function">ncs_service_reply_proplist()</code>, the previous
  property list is retained. To completely delete the property list,
  call this function with the <em class="parameter"><code>num_props</code></em> parameter
  given as 0.</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.validation_callbacks"></a><h2>VALIDATION CALLBACKS</h2><p>This library also supports the registration of callback
  functions on validation points in the data model. A validation point
  is a point in the data model where ConfD will invoke an external
  function to validate the associated data. The validation occurs before a
  transaction is committed.  Similar to the state machine described
  for "external data bases" above where we install callback functions
  in the <span class="type">struct confd_trans_cbs</span>, we have to
  install callback functions for each validation point. It does not
  matter if the database is CDB or an external database, the
  validation callbacks described here work equally well for both
  cases.</p><div class="funcsynopsis"><a name="fn.confd_register_trans_validate_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_register_trans_validate_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_trans_validate_cbs *<var class="pdparam">vcbs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function installs two callback functions for the
  <span class="type">struct confd_daemon_ctx</span>.  One function that
  gets called when the validation phase starts in a transaction and
  one when the validation phase stops in a transaction. In the
  <code class="function">init()</code> callback we can use the MAAPI api to
  attach to the running transaction, this way we can later on, freely
  traverse the configuration and read data. The data we will be
  reading through MAAPI (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>)
  will be read from the shadow storage containing the
  <span class="emphasis"><em>not-yet-committed</em></span> data.</p><p>The <span class="type">struct confd_trans_validate_cbs</span> is
  defined as:</p><div class="informalexample"><a name="struct.confd_trans_validate_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_trans_validate_cbs {
    <strong class="hl-keyword">int</strong> (*init)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
    <strong class="hl-keyword">int</strong> (*stop)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx);
};</pre></div><p>It must thus be populated with two function pointers when we
  call this function.</p><p>The <code class="function">init()</code> callback is conceptually
  invoked at the start of the validation phase, but just as for
  transaction callbacks, ConfD will as far as possible delay the
  actual invocation of the validation <code class="function">init()</code>
  callback for a given daemon until it is required.  This means that
  if none of the daemon's <code class="function">validate()</code> callbacks
  need to be invoked (see below), <code class="function">init()</code> and
  <code class="function">stop()</code> will not be invoked either.</p><p>If we need to allocate memory or other resources for the
  validation this can also be done in the <code class="function">init()</code>
  callback, with the resources being freed in the
  <code class="function">stop()</code> callback.  We can use the
  <code class="varname">t_opaque</code> element in the <span class="type">struct
  confd_trans_ctx</span> to manage this, but in a daemon that
  implements both data and validation callbacks it is better to use
  the <code class="varname">v_opaque</code> element for validation, to be able
  to manage the allocations independently.</p><p>Similar to the <code class="function">init()</code> callback for
  external data bases, we must in the <code class="function">init()</code>
  callback associate a file descriptor with the transaction.  This
  file descriptor will be used for the actual validation. Thus in a
  multi threaded application, we can have one thread performing
  validation for a transaction in parallel with other threads
  executing e.g. data callbacks. Thus a typical implementation of an
  <code class="function">init()</code> callback for validation looks as:</p><div class="informalexample"><pre class="programlisting">static int init_validation(struct confd_trans_ctx *tctx)
{
    maapi_attach(maapi_socket, mtest__ns, tctx);
    confd_trans_set_fd(tctx, workersock);
    return CONFD_OK;
}</pre></div><div class="funcsynopsis"><a name="fn.confd_register_valpoint_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_valpoint_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_valpoint_cb *<var class="pdparam">vcb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>We must also install an actual validation function for each
  validation point, i.e. for each <code class="code">tailf:validate</code> statement
  in the YANG data model.</p><p>A validation point has a name and an
  associated function pointer.  The struct which must be populated for
  each validation point looks like:</p><div class="informalexample"><a name="struct.confd_valpoint_cb"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_valpoint_cb {
    <strong class="hl-keyword">char</strong> valpoint[MAX_CALLPOINT_LEN];
    <strong class="hl-keyword">int</strong> (*validate)(<strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx,
                    confd_hkeypath_t *kp,
                    confd_value_t *newval);
    <strong class="hl-keyword">void</strong> *cb_opaque;        <em class="hl-comment" style="color: silver">/* private user data */</em>
};</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We must call the
  <code class="function">confd_register_done()</code> function when we are done
  with all registrations for a daemon, see above.</p></div><p>See the user guide chapter "Semantic validation" for code
  examples.  The <code class="function">validate()</code> callback can return
  CONFD_OK if all is well, or CONFD_ERROR if the validation fails. If we
  wish a message to accompany the error we must prior to returning
  from the callback, call <code class="function">confd_trans_seterr()</code> or
  <code class="function">confd_trans_seterr_extended()</code>.</p><p>The <code class="varname">cb_opaque</code> element can be used to pass
  arbitrary data to the callback, e.g. when the same callback is used
  for multiple validation points. It is made available to the callback
  via the element <code class="varname">vcb_opaque</code> in the transaction
  context (<em class="parameter"><code>tctx</code></em> argument), see the structure
  definition above.</p><p>If the <code class="code">tailf:opaque</code> substatement has been used with
  the <code class="code">tailf:validate</code> statement in the data model, the
  argument string is made available to the callback via the
  <code class="varname">validate_opaque</code> element in the transaction
  context.</p><p>We also have yet another special return value which can be
  used (only) from the <code class="function">validate()</code> callback which
  is CONFD_VALIDATION_WARN. Prior to return of this value we must call
  <code class="function">confd_trans_seterr()</code> which provides a string
  describing the warning. The warnings will get propagated to the
  transaction engine, and depending on where the transaction
  originates, ConfD may or may not act on the warnings. If the
  transaction originates from the CLI or the Web UI, ConfD will
  interactively present the user with a choice - whereby the
  transaction can be aborted.</p><p>If the transaction originates from NETCONF - which does not
  have any interactive capabilities - the warnings are ignored. The
  warnings are primarily intended to alert inexperienced users that
  attempt to make - dangerous - configuration changes. There can be
  multiple warnings from multiple validation points in the same
  transaction.</p><p>It is also possible to let the <code class="function">validate()</code>
  callback return CONFD_DELAYED_RESPONSE in which case the application
  at a later stage must invoke either
  <code class="function">confd_delayed_reply_ok()</code>,
  <code class="function">confd_delayed_reply_error()</code> or
  <code class="function">confd_delayed_reply_validation_warn()</code>.</p><p>In some cases it may be necessary for the validation callbacks
  to verify the availability of resources that will be needed if the
  new configuration is committed. To support this kind of
  verification, the <code class="varname">validation_info</code> element in
  the <span class="type">struct confd_trans_ctx</span> can carry one of
  these flags:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">CONFD_VALIDATION_FLAG_TEST</span></dt><dd><p>When this flag is set, the current validation phase is a
        "test" validation, as in e.g. the CLI 'validate' command, and
        the transaction will return to the READ state regardless of
        the validation result.  This flag is available in all of the
        <code class="function">init()</code>, <code class="function">validate()</code>,
        and <code class="function">stop()</code> callbacks.</p></dd><dt><span class="term">CONFD_VALIDATION_FLAG_COMMIT</span></dt><dd><p>When this flag is set, all requirements for a commit
        have been met, i.e. all validation as well as the write_start
        and prepare transitions have been successful, and the actual
        commit will follow.  This flag is only available in the
        <code class="function">stop()</code> callback.</p></dd></dl></div><div class="funcsynopsis"><a name="fn.confd_register_range_valpoint_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_range_valpoint_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_valpoint_cb *<var class="pdparam">vcb</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">lower</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">upper</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">numkeys</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>A variant of <code class="function">confd_register_valpoint_cb()</code>
  which registers a validation function for a range of key values. The
  <em class="parameter"><code>lower</code></em>, <em class="parameter"><code>upper</code></em>,
  <em class="parameter"><code>numkeys</code></em>, <em class="parameter"><code>fmt</code></em>, and
  remaining parameters are the same as for
  <code class="function">confd_register_range_data_cb()</code>, see above.</p><div class="funcsynopsis"><a name="fn.confd_delayed_reply_validation_warn"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_delayed_reply_validation_warn</b>(</code></td><td>struct confd_trans_ctx *<var class="pdparam">tctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function must be used to return the equivalent of
  CONFD_VALIDATION_WARN when the <code class="function">validate()</code>
  callback returned CONFD_DELAYED_RESPONSE. Before calling this
  function, we must call
  <code class="function">confd_trans_seterr()</code> to provide a string
  describing the warning.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_PROTOUSAGE,
  CONFD_ERR_MALLOC, CONFD_ERR_OS</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.notification_streams"></a><h2>NOTIFICATION STREAMS</h2><p>The application can generate notifications that are sent via
  the northbound protocols. Currently NETCONF notification streams are
  supported. The application generates the content for each
  notification and sends it via a socket to ConfD, which in turn
  manages the stream subscriptions and distributes the notifications
  accordingly.</p><p>A stream always has a "live feed", which is the sequence of
  new notifications, sent in real time as they are
  generated. Subscribers may also request "replay" of older, logged
  notifications if the stream supports this, perhaps transitioning to
  the live feed when the end of the log is reached. There may be one
  or more replays active simultaneously with the live feed. ConfD
  forwards replay requests from subscribers to the application via
  callbacks if the stream supports replay.</p><p>Each notification has an associated time stamp, the "event
  time". This is the time when the event that generated the
  notification occurred, rather than the time the notification is
  logged or sent, in case these times differ. The application must
  pass the event time to ConfD when sending a notification, and it is
  also needed when replaying logged events, see below.</p><div class="funcsynopsis"><a name="fn.confd_register_notification_stream"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_notification_stream</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_notification_stream_cbs *<var class="pdparam">ncbs</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_notification_ctx **<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function registers the notification stream and optionally
  two callback functions used for the replay functionality.  If the
  stream does not support replay, the callback elements in the
  <span class="type">struct confd_notification_stream_cbs</span> are set to
  NULL. A context pointer is returned via the
  <em class="parameter"><code>**nctx</code></em> argument - this must be used by the
  application for the sending of live notifications via
  <code class="function">confd_notification_send()</code> (see below).</p><p>The <span class="type">confd_notification_stream_cbs</span>
  structure is defined as:</p><div class="informalexample"><a name="struct.confd_notification_stream_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_notification_stream_cbs {
    <strong class="hl-keyword">char</strong> streamname[MAX_STREAMNAME_LEN];
    <strong class="hl-keyword">int</strong> fd;
    <strong class="hl-keyword">int</strong> (*get_log_times)(
        <strong class="hl-keyword">struct</strong> confd_notification_ctx *nctx);
    <strong class="hl-keyword">int</strong> (*replay)(<strong class="hl-keyword">struct</strong> confd_notification_ctx *nctx,
                  <strong class="hl-keyword">struct</strong> confd_datetime *start,
                  <strong class="hl-keyword">struct</strong> confd_datetime *stop);
    <strong class="hl-keyword">void</strong> *cb_opaque;        <em class="hl-comment" style="color: silver">/* private user data */</em>
};</pre></div><p>The <code class="varname">fd</code> element must be set to a
  previously connected worker socket.  This socket may be used for
  multiple notification streams, but not for any of the callback
  processing described above. Since it is only used for sending data
  to ConfD, there is no need for the application to poll the
  socket. Note that the control socket must be connected before
  registration even if the callbacks are not registered.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We must call the
  <code class="function">confd_register_done()</code> function when we are done
  with all registrations for a daemon, see above.</p></div><p>The <code class="function">get_log_times()</code> callback is called by
  ConfD to find out a) the creation time of the current log and b) the
  event time of the last notification aged out of the log, if any.
  The application provides the times via the
  <code class="function">confd_notification_reply_log_times()</code> function
  (see below) and returns CONFD_OK.</p><p>The <code class="function">replay()</code> callback is called by ConfD
  to request replay. The <em class="parameter"><code>nctx</code></em> context pointer
  must be saved by the application and used when sending the replay
  notifications via <code class="function">confd_notification_send()</code>, as
  well as for the
  <code class="function">confd_notification_replay_complete()</code> (or
  <code class="function">confd_notification_replay_failed()</code>) call (see
  below) - the callback should return without waiting for the replay
  to complete.  The pointer references allocated memory, which is
  freed by the
  <code class="function">confd_notification_replay_complete()</code> (or
  <code class="function">confd_notification_replay_failed()</code>)
  call.</p><p>The times given by <em class="parameter"><code>*start</code></em> and
  <em class="parameter"><code>*stop</code></em> specify the extent of the replay. The
  start time will always be given and specify a time in the past,
  however the stop time may be either in the past or in the future or
  even omitted, i.e. the <em class="parameter"><code>stop</code></em> argument is
  NULL. This means that the subscriber has requested that the
  subscription continues indefinitely with the live feed when the
  logged notifications have been sent.</p><p>If the stop time is given:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The application sends all logged notifications
    that have an event time later than the start time but not later
    than the stop time, and then calls
    <code class="function">confd_notification_replay_complete()</code>. Note
    that if the stop time is in the future when the replay request
    arrives, this includes notifications logged while the replay is in
    progress (if any), as long as their event time is not later than
    the stop time.</p></li></ul></div><p>If the stop time is <span class="emphasis"><em>not</em></span> given:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The application sends all logged notifications
    that have an event time later than the start time, and then calls
    <code class="function">confd_notification_replay_complete()</code>. Note
    that this includes notifications logged after the request was
    received (if any).</p></li></ul></div><p>ConfD will if needed switch the subscriber over to the live
  feed and then end the subscription when the stop time is
  reached. The callback may analyze the <em class="parameter"><code>start</code></em> and
  <em class="parameter"><code>stop</code></em> arguments to determine start and stop
  positions in the log, but if the analysis is postponed until after
  the callback has returned, the <span class="type">confd_datetime</span>
  structure(s) must be copied by the callback.</p><p>The <code class="function">replay()</code> callback may optionally
  select a separate worker socket to be used for the replay
  notifications. In this case it must call
  <code class="function">confd_notification_set_fd()</code> to indicate which
  socket should be used.</p><p>Note that unlike the callbacks for external data bases and
  validation, these callbacks do not use a worker socket for the
  callback processing, and consequently there is no
  <code class="function">init()</code> callback to request one. The callbacks
  are invoked, and the reply is sent, via the daemon control
  socket.</p><p>The <code class="varname">cb_opaque</code> element in the
  <span class="type">confd_notification_stream_cbs</span> structure can be
  used to pass arbitrary data to the callbacks in much the same way as
  for callpoint and validation point registrations, see the
  description of the <span class="type">struct confd_data_cbs</span>
  structure above. However since the callbacks are not associated with
  a transaction, this element is instead made available in the
  <span class="type">confd_notification_ctx</span> structure.</p><div class="funcsynopsis"><a name="fn.confd_notification_send"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_send</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">time</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is called by the application to send a
  notification, whether "live" or replay. The
  <em class="parameter"><code>nctx</code></em> pointer is provided by ConfD as described
  above. The <em class="parameter"><code>time</code></em> argument specifies the event
  time for the notification. The <em class="parameter"><code>values</code></em> argument
  is an array of length <em class="parameter"><code>nvalues</code></em>, populated with
  the content of the notification as described for the Tagged Value
  Array format in the <a class="link" href="rn02re15.html#man.3.confd_types.xml_structures" title="XML STRUCTURES">XML STRUCTURES</a>
  section of the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
  page.</p><p>For example, a NETCONF notification of the form</p><div class="informalexample"><pre class="programlisting">&lt;ncn:notification
 xmlns:ncn="urn:ietf:params:xml:ns:netconf:notification:1.0"&gt;
  &lt;linkUp xmlns="http://example.com/ns/test/1.0"&gt;
    &lt;ncn:eventTime&gt;2007-08-17T08:56:05Z&lt;/ncn:eventTime&gt;
    &lt;ifIndex&gt;3&lt;/ifIndex&gt;
  &lt;/linkUp&gt;
&lt;/ncn:notification&gt;</pre></div><p>could be sent with the following code:</p><div class="informalexample"><pre class="programlisting">struct confd_notification_ctx *nctx;
struct confd_datetime event_time = {2007, 8, 17, 8, 56, 5, 0, 0, 0};
confd_tag_value_t notif[3];
int n = 0;

CONFD_SET_TAG_XMLBEGIN(&amp;notif[n], test_linkUp, test__ns); n++;
CONFD_SET_TAG_UINT32(&amp;notif[n], test_ifIndex, 3); n++;
CONFD_SET_TAG_XMLEND(&amp;notif[n], test_linkUp, test__ns); n++;
confd_notification_send(nctx, &amp;event_time, notif, n);</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While it is possible to use separate threads to send
  live and replay notifications for a given stream, or to send
  different streams on a given worker socket, this is not
  recommended. This is because it involves rather complex
  synchronization problems that can only be fully solved by the
  application, in particular in the case where a replay switches over
  to the live feed.</p></div><div class="funcsynopsis"><a name="fn.confd_notification_replay_complete"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_replay_complete</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The application calls this function to notify ConfD that the
  replay is complete, using the <em class="parameter"><code>nctx</code></em> pointer
  received in the corresponding <code class="function">replay()</code> callback
  invocation.</p><div class="funcsynopsis"><a name="fn.confd_notification_replay_failed"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_replay_failed</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>In case the application fails to complete the replay as
  requested (e.g. the log gets overwritten while the replay is in
  progress), the application should call this function
  <span class="emphasis"><em>instead</em></span> of
  <code class="function">confd_notification_replay_complete()</code>.  An error
  message describing the reason for the failure can be supplied by
  first calling <code class="function">confd_notification_seterr()</code> or
  <code class="function">confd_notification_seterr_extended()</code>, see
  below. The <em class="parameter"><code>nctx</code></em> pointer received in the
  corresponding <code class="function">replay()</code> callback invocation is
  used for both calls.</p><div class="funcsynopsis"><a name="fn.confd_notification_set_fd"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_set_fd</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">fd</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function may optionally be called by the
  <code class="function">replay()</code> callback to request that the worker
  socket given by <em class="parameter"><code>fd</code></em> should be used for the
  replay. Otherwise the socket specified in the
  <span class="type">confd_notification_stream_cbs</span> at registration
  will be used.</p><div class="funcsynopsis"><a name="fn.confd_notification_reply_log_times"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_reply_log_times</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">creation</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">aged</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Reply function for use in the
  <code class="function">get_log_times()</code> callback invocation.  If no
  notifications have been aged out of the log, give NULL for the
  <em class="parameter"><code>aged</code></em> argument.</p><div class="funcsynopsis"><a name="fn.confd_notification_seterr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_seterr</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>In some cases the callbacks may be unable to carry out the
  requested actions, e.g. the capacity for simultaneous replays might
  be exceeded, and they can then return CONFD_ERR. This function
  allows the callback to associate an error message with the
  failure. It can also be used to supply an error message before
  calling <code class="function">confd_notification_replay_failed()</code>.</p><div class="funcsynopsis"><a name="fn.confd_notification_seterr_extended"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_seterr_extended</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide more structured error
  information from a notification callback, see the section
  <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_notification_seterr_extended_info"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_seterr_extended_info</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide structured error
  information in the same way as
  <code class="function">confd_notification_seterr_extended()</code>, and additionally
  provide contents for the NETCONF &lt;error-info&gt; element. See the
  section <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_register_snmp_notification"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_snmp_notification</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notify_name</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">ctx_name</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_notification_ctx **<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>SNMP notifications can also be sent via the notification
  framework, however most aspects of the stream concept described
  above do not apply for SNMP.  This function is used to register a
  worker socket, the snmpNotifyName
  (<em class="parameter"><code>notify_name</code></em>), and SNMP context
  (<em class="parameter"><code>ctx_name</code></em>) to be used for the
  notifications.</p><p>The <em class="parameter"><code>fd</code></em> parameter must give a previously
  connected worker socket. This socket may be used for different
  notifications, but not for any of the callback processing described
  above. Since it is only used for sending data to ConfD, there is no
  need for the application to poll the socket. Note that the control
  socket must be connected before registration, even if none of the
  callbacks described below are registered.</p><p>The context pointer returned via the
  <em class="parameter"><code>**nctx</code></em> argument must be used by the application
  for the subsequent sending of the notifications via
  <code class="function">confd_notification_send_snmp()</code> or
  <code class="function">confd_notification_send_snmp_inform()</code> (see
  below).</p><p>When a notification is sent using one of these functions, it
  is delivered to the management targets defined for the
  <code class="code">snmpNotifyName</code> in the
  <code class="code">snmpNotifyTable</code> in SNMP-NOTIFICATION-MIB for
  the specified SNMP context.  If <em class="parameter"><code>notify_name</code></em> is
  NULL or the empty string (""), the notification is sent to all
  management targets.  If <em class="parameter"><code>ctx_name</code></em> is NULL or the
  empty string (""), the default context ("") is used.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We must call the
  <code class="function">confd_register_done()</code> function when we are done
  with all registrations for a daemon, see above.</p></div><div class="funcsynopsis"><a name="fn.confd_notification_send_snmp"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_send_snmp</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notification</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_snmp_varbind *<var class="pdparam">varbinds</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_vars</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Sends the SNMP notification specified by
  <em class="parameter"><code>notification</code></em>, without requesting inform-request
  delivery information.  This is equivalent to calling
  <code class="function">confd_notification_send_snmp_inform()</code> (see
  below) with NULL as the <em class="parameter"><code>cb_id</code></em> argument. I.e. if
  the common arguments are the same, the two functions will send the
  exact same set of traps and inform-requests.</p><div class="funcsynopsis"><a name="fn.confd_register_notification_snmp_inform_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_notification_snmp_inform_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_notification_snmp_inform_cbs *<var class="pdparam">cb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>If we want to receive information about the delivery of SNMP
  inform-requests, we must register two callbacks for this.  The
  <span class="type">struct confd_notification_snmp_inform_cbs</span> is
  defined as:</p><div class="informalexample"><a name="struct.confd_notification_snmp_inform_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_notification_snmp_inform_cbs {
    <strong class="hl-keyword">char</strong> cb_id[MAX_CALLPOINT_LEN];
    <strong class="hl-keyword">void</strong> (*targets)(<strong class="hl-keyword">struct</strong> confd_notification_ctx *nctx,
                    <strong class="hl-keyword">int</strong> ref, <strong class="hl-keyword">struct</strong> confd_snmp_target *targets,
                    <strong class="hl-keyword">int</strong> num_targets);
    <strong class="hl-keyword">void</strong> (*result)(<strong class="hl-keyword">struct</strong> confd_notification_ctx *nctx,
                   <strong class="hl-keyword">int</strong> ref, <strong class="hl-keyword">struct</strong> confd_snmp_target *target,
                   <strong class="hl-keyword">int</strong> got_response);
    <strong class="hl-keyword">void</strong> *cb_opaque;        <em class="hl-comment" style="color: silver">/* private user data */</em>
};</pre></div><p>The callback identifier <em class="parameter"><code>cb_id</code></em> can be
  chosen arbitrarily, it is only used when sending SNMP notifications
  with <code class="function">confd_notification_send_snmp_inform()</code> -
  however each inform callback registration must use a unique
  <em class="parameter"><code>cb_id</code></em>.  The callbacks are invoked via the
  control socket, i.e. the application must poll it and invoke
  <code class="function">confd_fd_ready()</code> when data is available.</p><p>When a notification is sent, the <code class="function">target()</code>
  callback will be invoked once with <em class="parameter"><code>num_targets</code></em>
  (possibly 0) inform-request targets in the
  <em class="parameter"><code>targets</code></em> array, followed by
  <em class="parameter"><code>num_targets</code></em> invocations of the
  <code class="function">result()</code> callback, one for each target. The
  <em class="parameter"><code>ref</code></em> argument (passed from the
  <code class="function">confd_notification_send_snmp_inform()</code> call)
  allows for tracking the result of multiple notifications with
  delivery overlap.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We must call the
  <code class="function">confd_register_done()</code> function when we are done
  with all registrations for a daemon, see above.</p></div><div class="funcsynopsis"><a name="fn.confd_notification_send_snmp_inform"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_send_snmp_inform</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notification</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_snmp_varbind *<var class="pdparam">varbinds</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">num_vars</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">cb_id</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">ref</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Sends the SNMP notification specified by
  <em class="parameter"><code>notification</code></em>.  If <em class="parameter"><code>cb_id</code></em> is
  not NULL, the callbacks registered for <em class="parameter"><code>cb_id</code></em>
  will be invoked with the <em class="parameter"><code>ref</code></em> argument as
  described above, otherwise no inform-request delivery information
  will be provided.  The <em class="parameter"><code>varbinds</code></em> array should be
  populated with <em class="parameter"><code>num_vars</code></em> elements as described
  in the Notifications section of the SNMP Agent chapter in the User
  Guide.</p><p>If <em class="parameter"><code>notification</code></em> is the empty string, no
  notification is looked up; instead <em class="parameter"><code>varbinds</code></em>
  defines the notification, including the notification id (variable
  name "snmpTrapOID"). This is especially useful for forwarding a
  notification which has been received from the SNMP gateway (see
  <code class="function">confd_register_notification_sub_snmp_cb()</code>
  below).</p><p>If <em class="parameter"><code>varbinds</code></em> does not contain a timestamp
  (variable name "sysUpTime"), one will be supplied by the
  agent.</p><div class="funcsynopsis"><a name="fn.confd_notification_set_snmp_src_addr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_notification_set_snmp_src_addr</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_ip *<var class="pdparam">src_addr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p> By default, the source address for the SNMP notifications that
  are sent by the above functions is chosen by the IP stack of the OS.
  This function may be used to select a specific source address, given
  by <em class="parameter"><code>src_addr</code></em>, for the SNMP notifications
  subsequently sent using the <em class="parameter"><code>nctx</code></em> context. The
  default can be restored by calling the function with a
  <em class="parameter"><code>src_addr</code></em> where the <code class="varname">af</code>
  element is set to <code class="constant">AF_UNSPEC</code>.</p><div class="funcsynopsis"><a name="fn.confd_notification_set_snmp_notify_name"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_set_snmp_notify_name</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">notify_name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to change the snmpNotifyName
  (<em class="parameter"><code>notify_name</code></em>) for the
  <em class="parameter"><code>nctx</code></em> context. The new snmpNotifyName is used
  for notifications sent by subsequent calls to
  <code class="function">confd_notification_send_snmp()</code> and
  <code class="function">confd_notification_send_snmp_inform()</code> that use
  the <em class="parameter"><code>nctx</code></em> context.</p><div class="funcsynopsis"><a name="fn.confd_register_notification_sub_snmp_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_notification_sub_snmp_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_notification_sub_snmp_cb *<var class="pdparam">cb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Registers a callback function to be called when an SNMP
  notification is received by the SNMP gateway.</p><p>The <span class="type">struct confd_notification_sub_snmp_cb</span>
  is defined as:</p><div class="informalexample"><a name="struct.confd_notification_sub_snmp_cb"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_notification_sub_snmp_cb {
    <strong class="hl-keyword">char</strong> sub_id[MAX_CALLPOINT_LEN];
    <strong class="hl-keyword">int</strong> (*recv)(<strong class="hl-keyword">struct</strong> confd_notification_ctx *nctx,
                <strong class="hl-keyword">char</strong> *notification,
                <strong class="hl-keyword">struct</strong> confd_snmp_varbind *varbinds, <strong class="hl-keyword">int</strong> num_vars,
                confd_value_t *src_addr, u_int16_t src_port);
    <strong class="hl-keyword">void</strong> *cb_opaque;        <em class="hl-comment" style="color: silver">/* private user data */</em>
};</pre></div><p>The <code class="varname">sub_id</code> element is the subscription id
  for the notifications.  The <code class="function">recv()</code> callback
  will be called when a notification is received.  See the section
  "Receiving and Forwarding Traps" in the chapter "The SNMP gateway"
  in the Users Guide.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We must call the
  <code class="function">confd_register_done()</code> function when we are done
  with all registrations for a daemon, see above.</p></div><div class="funcsynopsis"><a name="fn.confd_notification_flush"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_notification_flush</b>(</code></td><td>struct confd_notification_ctx *<var class="pdparam">nctx</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Notifications are sent asynchronously, i.e. normally without
  blocking the caller of the send functions described above. This means
  that in some cases, ConfD's sending of the notifications on the
  northbound interfaces may lag behind the send calls. If we want to
  make sure that the notifications have actually been sent out, e.g. in
  some shutdown procedure, we can call
  <code class="function">confd_notification_flush()</code>. This function will
  block until all notifications sent using the given
  <em class="parameter"><code>nctx</code></em> context have been fully processed by
  ConfD. It can be used both for notification streams and for SNMP
  notifications (however it will not wait for replies to SNMP
  inform-requests to arrive).</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.confd_actions"></a><h2>CONFD ACTIONS</h2><p>The use of action callbacks can be specified either via a
  <code class="code">rpc</code> statement or via a <code class="code">tailf:action</code>
  statement in the YANG data model, see the YANG specification and <a class="link" href="rn03re20.html" title="tailf_yang_extensions">tailf_yang_extensions(5)</a>.
  In both cases the use of a <code class="code">tailf:actionpoint</code> statement
  specifies that the action is implemented as a callback function.
  This section describes
  how such callback functions should be implemented and registered
  with ConfD.</p><p>Unlike the callbacks for data and validation, there is not
  always a transaction associated with an action callback. However an
  action is always associated with a user session (NETCONF, CLI, etc),
  and only one action at a time can be invoked from a given user
  session. Hence a pointer to the associated <span class="type">struct
  confd_user_info</span> is passed to the callbacks.</p><p>The action callback mechanism is also used for command and
  completion callbacks configured for the CLI, either in a YANG module
  using tailf extension statements, or in a <a class="link" href="rn03re16.html" title="clispec">clispec(5)</a>.  As the parameter
  structure is significantly different, special callbacks are used for
  these functions.</p><div class="funcsynopsis"><a name="fn.confd_register_action_cbs"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_action_cbs</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_action_cbs *<var class="pdparam">acb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function registers up to five callback functions, two of
  which will be called in sequence when an action is invoked.  The
  <span class="type">struct confd_action_cbs</span> is defined as:</p><div class="informalexample"><a name="struct.confd_action_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_action_cbs {
    <strong class="hl-keyword">char</strong> actionpoint[MAX_CALLPOINT_LEN];
    <strong class="hl-keyword">int</strong> (*init)(<strong class="hl-keyword">struct</strong> confd_user_info *uinfo);
    <strong class="hl-keyword">int</strong> (*abort)(<strong class="hl-keyword">struct</strong> confd_user_info *uinfo);
    <strong class="hl-keyword">int</strong> (*action)(<strong class="hl-keyword">struct</strong> confd_user_info *uinfo,
                  <strong class="hl-keyword">struct</strong> xml_tag *name,
                  confd_hkeypath_t *kp,
                  confd_tag_value_t *params,
                  <strong class="hl-keyword">int</strong> nparams);
    <strong class="hl-keyword">int</strong> (*command)(<strong class="hl-keyword">struct</strong> confd_user_info *uinfo,
                   <strong class="hl-keyword">char</strong> *path, <strong class="hl-keyword">int</strong> argc, <strong class="hl-keyword">char</strong> **argv);
    <strong class="hl-keyword">int</strong> (*completion)(<strong class="hl-keyword">struct</strong> confd_user_info *uinfo,
                      <strong class="hl-keyword">int</strong> cli_style, <strong class="hl-keyword">char</strong> *token, <strong class="hl-keyword">int</strong> completion_char,
                      confd_hkeypath_t *kp,
                      <strong class="hl-keyword">char</strong> *cmdpath, <strong class="hl-keyword">char</strong> *cmdparam_id,
                      <strong class="hl-keyword">struct</strong> confd_qname *simpleType, <strong class="hl-keyword">char</strong> *extra);
    <strong class="hl-keyword">void</strong> *cb_opaque;        <em class="hl-comment" style="color: silver">/* private user data */</em>
};</pre></div><p>The <code class="function">init()</code> callback, and at least one of
  the <code class="function">action()</code>, <code class="function">command()</code>,
  and <code class="function">completion()</code> callbacks, must be specified.
  It is in principle possible to use a single "point name" for more
  than one of these callback types, and have the corresponding
  callback invoked in each case, but in typical usage we would only
  register one of the callbacks <code class="function">action()</code>,
  <code class="function">command()</code>, and
  <code class="function">completion()</code>.  Below, the term "action
  callback" is used to refer to any of these three.</p><p>Similar to the <code class="function">init()</code> callback for
  external data bases, we must in the <code class="function">init()</code>
  callback associate a worker socket with the action.  This socket
  will be used for the invocation of the action callback, which
  actually carries out the action. Thus in a multi threaded
  application, actions can be dispatched to different threads.</p><p>However note that unlike the callbacks for external data bases
  and validation, both <code class="function">init()</code> and action
  callbacks are registered for each action point (i.e. different
  action points can have different <code class="function">init()</code>
  callbacks), and there is no <code class="function">finish()</code> callback -
  the action is completed when the action callback returns.</p><p>The <span class="type">struct confd_action_ctx actx</span> element inside the
  <span class="type">struct confd_user_info</span> holds action-specific data, in
  particular the <code class="varname">t_opaque</code> element could be used to
  pass data from the <code class="function">init()</code> callback to the action
  callback, if needed. If the action is associated with a transaction,
  the <code class="varname">thandle</code> element is set to the transaction
  handle, and can be used with a call to
  <code class="function">maapi_attach2()</code> (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>),
  otherwise <code class="varname">thandle</code> will be -1.

  It is up to the northbound interface whether to invoke the action
  with a transaction handle, and the action implementer must check if
  the thandle is -1 or a proper transaction handle if the action
  intends to use it. The CLI will always invoke an action with a
  transaction handle (it will pass a handle to a read_write
  transaction when in configure mode, and a read transaction
  otherwise). The NETCONF interface will do so if the tailf extension
  <code class="code"> &lt;start-transaction/&gt; </code> was used before the action
  was invoked. A transaction handle will also be passed to the
  callback when invoked via
  <code class="function">maapi_request_action_th()</code> (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>).</p><p>The <code class="varname">cb_opaque</code> element in the
  <span class="type">confd_action_cbs</span> structure can be used to pass
  arbitrary data to the callbacks in much the same way as for
  callpoint and validation point registrations, see the description of
  the <span class="type">struct confd_data_cbs</span> structure above.
  This element is made available in the
  <span class="type">confd_action_ctx</span> structure.</p><p>If the <code class="code">tailf:opaque</code> substatement has been used with
  the <code class="code">tailf:actionpoint</code> statement in the data model, the
  argument string is made available to the callbacks via the
  <code class="varname">actionpoint_opaque</code> element in the
  <span class="type">confd_action_ctx</span> structure.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We must call the
  <code class="function">confd_register_done()</code> function when we are done
  with all registrations for a daemon, see above.</p></div><p>The <code class="function">action()</code> callback receives all the
  parameters pertaining to the action: The <em class="parameter"><code>name</code></em>
  argument is a pointer to the action name as defined in the data model,
  the <em class="parameter"><code>kp</code></em> argument gives the path
  through the data model for an action defined via
  <code class="code">tailf:action</code> (it is a NULL pointer for an action defined
  via <code class="code">rpc</code>), and finally the
  <em class="parameter"><code>params</code></em> argument is a representation of the
  inout parameters provided when the action is invoked.
  The <em class="parameter"><code>params</code></em>
  argument is an array of length <em class="parameter"><code>nparams</code></em>,
  populated as described for the Tagged Value Array format in the
  <a class="link" href="rn02re15.html#man.3.confd_types.xml_structures" title="XML STRUCTURES">XML
  STRUCTURES</a> section of the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
  page.</p><p>The <code class="function">command()</code> callback is invoked for CLI
  callback commands.  It must always result in a call of
  <code class="function">confd_action_reply_command()</code>.  As the
  parameters in this case are all in string form, they are passed in
  the traditional Unix <em class="parameter"><code>argc</code></em>,
  <em class="parameter"><code>argv</code></em> manner -
  i.e. <em class="parameter"><code>argv</code></em> is an array of
  <em class="parameter"><code>argc</code></em> pointers to NUL-terminated strings plus
  a final NULL pointer element, and <em class="parameter"><code>argv[0]</code></em> is
  the name of the command. Additionally the full path of the command
  is available via the <em class="parameter"><code>path</code></em> argument.</p><p>The <code class="function">completion()</code> callback is invoked for
  CLI completion and information. It must result in a call of
  <code class="function">confd_action_reply_completion()</code>, except for the
  case when the callback is invoked via a
  <code class="code">tailf:cli-custom-range-enumerator</code> statement in the data
  model (see below). The
  <em class="parameter"><code>cli_style</code></em> argument gives the style of the CLI
  session as a character: 'J', 'C', or 'I'. The
  <em class="parameter"><code>token</code></em> argument is a NUL-terminated string
  giving the parameter of the CLI command line that the callback
  invocation pertains to, and <em class="parameter"><code>completion_char</code></em>
  is the character that the user typed, i.e. TAB ('\t'), SPACE (' '),
  or '?'.  If the callback pertains to a data model element,
  <em class="parameter"><code>kp</code></em> identifies that element, otherwise it is
  NULL. The <em class="parameter"><code>cmdpath</code></em> is a NUL-terminated string
  giving the full path of the command.  If a
  <code class="code">cli-completion-id</code> is specified in the YANG module, or a
  <code class="code">completionId</code> is specified in the clispec, it is given
  as a NUL-terminated string via <em class="parameter"><code>cmdparam_id</code></em>,
  otherwise this argument is NULL.  If the invocation pertains to an
  element that has a type definition, the
  <em class="parameter"><code>simpleType</code></em> argument identifies the type with
  namespace and type name, otherwise it is NULL.  The
  <em class="parameter"><code>extra</code></em> argument is currently unused (always
  NULL).</p><p>When <code class="function">completion()</code> is invoked via a
  <code class="code">tailf:cli-custom-range-enumerator</code> statement in the data
  model, it is a request to provide possible key values for creation of
  an entry in a list with a custom range specification. The callback
  must in this case result in a call of
  <code class="function">confd_action_reply_range_enum()</code>. Refer to the
  <code class="filename">cli/range_create</code> example in the bundled examples
  collection to see an implementation of such a callback.</p><p>The action callbacks must return CONFD_OK, CONFD_ERR, or
  CONFD_DELAYED_RESPONSE. CONFD_DELAYED_RESPONSE implies that the
  application must later reply asynchronously.</p><p>The optional <code class="function">abort()</code> callback is called
  whenever an action is aborted, e.g. when a user invokes an action
  from one of the northbound agents and aborts it before it has
  completed.  The <code class="function">abort()</code> callback will be
  invoked on the control socket.  It is the responsibility of the
  <code class="function">abort()</code> callback to make sure that the pending
  reply from the action callback is sent.  This is required to allow
  the worker socket to be used for further queries.  There are several
  possible ways for an application to support aborting.  E.g. the
  application can return CONFD_DELAYED_RESPONSE from the action
  callback. Then, when the <code class="function">abort()</code> callback is
  called, it can terminate the executing action and use
  e.g. <code class="function">confd_action_delayed_reply_error()</code>.
  Alternatively an application can use threads where the action
  callback is executed in a separate thread.  In this case the
  <code class="function">abort()</code> callback could inform the thread
  executing the action that it should be terminated, and that thread
  can just return from the action callback.
  </p><div class="funcsynopsis"><a name="fn.confd_register_range_action_cbs"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_range_action_cbs</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_action_cbs *<var class="pdparam">acb</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">lower</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">upper</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">numkeys</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>A variant of <code class="function">confd_register_action_cbs()</code>
  which registers action callbacks for a range of key values. The
  <em class="parameter"><code>lower</code></em>, <em class="parameter"><code>upper</code></em>,
  <em class="parameter"><code>numkeys</code></em>, <em class="parameter"><code>fmt</code></em>, and
  remaining parameters are the same as for
  <code class="function">confd_register_range_data_cb()</code>, see above.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function can not be used for registration of the
  <code class="function">command()</code> or <code class="function">completion()</code>
  callbacks - only actions specified in the data model are invoked via a
  keypath that can be used for selection of the corresponding
  callbacks.</p></div><div class="funcsynopsis"><a name="fn.confd_action_set_fd"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_action_set_fd</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Associate a worker socket with the action. This function must
  be called in the <code class="function">init()</code> callback - a typical
  implementation of an <code class="function">init()</code> callback looks
  as:</p><div class="informalexample"><pre class="programlisting">static int init_action(struct confd_user_info *uinfo)
{
    confd_action_set_fd(uinfo, workersock);
    return CONFD_OK;
}</pre></div><div class="funcsynopsis"><a name="fn.confd_action_reply_values"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_values</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>If the action definition specifies that the action should
  return data, it must invoke this function in response to the
  <code class="function">action()</code> callback.  The
  <em class="parameter"><code>values</code></em> argument points to an array of length
  <em class="parameter"><code>nvalues</code></em>, populated with the output parameters
  in the same way as the
  <em class="parameter"><code>params</code></em> array above.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function must only be called for an
  <code class="function">action()</code> callback.</p></div><div class="funcsynopsis"><a name="fn.confd_action_reply_command"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_command</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>If a CLI callback command should return data, it must invoke
  this function in response to the <code class="function">command()</code>
  callback.  The <em class="parameter"><code>values</code></em> argument points to an
  array of length <em class="parameter"><code>nvalues</code></em>, populated with
  pointers to NUL-terminated strings.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function must only be called for a
  <code class="function">command()</code> callback.</p></div><div class="funcsynopsis"><a name="fn.confd_action_reply_rewrite"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_rewrite</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">unhides</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nunhides</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be called instead of
  <code class="function">confd_action_reply_command()</code> as a response to a
  show path rewrite callback invocation. The <em class="parameter"><code>values</code></em>
  argument points to an
  array of length <em class="parameter"><code>nvalues</code></em>, populated with
  pointers to NUL-terminated strings representing the tokens of the
  new path. The <em class="parameter"><code>unhides</code></em>
  argument points to an
  array of length <em class="parameter"><code>nunhides</code></em>, populated with
  pointers to NUL-terminated strings representing hide groups to
  temporarily unhide during evaluation of the show command.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function must only be called for a
  <code class="function">command()</code> callback.</p></div><div class="funcsynopsis"><a name="fn.confd_action_reply_rewrite2"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_rewrite2</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">unhides</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nunhides</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_rewrite_select **<var class="pdparam">selects</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nselects</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>
    This function can be called instead of
    <code class="function">confd_action_reply_command()</code> as a response to a
    show path rewrite callback invocation. The
    <em class="parameter"><code>values</code></em> argument points to an array of length
    <em class="parameter"><code>nvalues</code></em>, populated with pointers to
    NUL-terminated strings representing the tokens of the new path.
    The <em class="parameter"><code>unhides</code></em> argument points to an array of
    length <em class="parameter"><code>nunhides</code></em>, populated with pointers to
    NUL-terminated strings representing hide groups to temporarily
    unhide during evaluation of the show command.
    The <em class="parameter"><code>selects</code></em> argument points to an array of
    length <em class="parameter"><code>nselects</code></em>, populated with pointers
    to confd_rewrite_select structs representing additional select
    targets.
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function must only be called for a
  <code class="function">command()</code> callback.</p></div><div class="funcsynopsis"><a name="fn.confd_action_reply_completion"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_completion</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_completion_value *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function must normally be called in response to the
  <code class="function">completion()</code> callback. The
  <em class="parameter"><code>values</code></em> argument points to an
  <em class="parameter"><code>nvalues</code></em> long array of
  <span class="type">confd_completion_value</span> elements:</p><div class="informalexample"><a name="enum.confd_completion_type"></a><pre class="programlisting"><strong class="hl-keyword">enum</strong> confd_completion_type {
    CONFD_COMPLETION,
    CONFD_COMPLETION_INFO,
    CONFD_COMPLETION_DESC,
    CONFD_COMPLETION_DEFAULT
};</pre><a name="struct.confd_completion_value"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_completion_value {
    <strong class="hl-keyword">enum</strong> confd_completion_type type;
    <strong class="hl-keyword">char</strong> *value;
    <strong class="hl-keyword">char</strong> *extra;
};</pre></div><p>For a completion alternative, <code class="varname">type</code> is set
  to CONFD_COMPLETION, <code class="varname">value</code> gives the
  alternative as a NUL-terminated string, and
  <code class="varname">extra</code> gives explanatory text as a
  NUL-terminated string - if there is no such text,
  <code class="varname">extra</code> is set to NULL. For "info" or "desc"
  elements, <code class="varname">type</code> is set to CONFD_COMPLETION_INFO
  or CONFD_COMPLETION_DESC, respectively, and
  <code class="varname">value</code> gives the text as a NUL-terminated string
  (the <code class="varname">extra</code> element is ignored).</p><p> In order to fallback to the normal completion behavior,
  <code class="varname">type</code> should be set to
  CONFD_COMPLETION_DEFAULT. CONFD_COMPLETION_DEFAULT cannot be
  combined with the other completion types, implying the
  <em class="parameter"><code>values</code></em> array always must have length
  <code class="varname">1</code> which is indicated by
  <em class="parameter"><code>nvalues</code></em> setting.
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function must only be called for a
  <code class="function">completion()</code> callback.</p></div><div class="funcsynopsis"><a name="fn.confd_action_reply_range_enum"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_reply_range_enum</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">keysize</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nkeys</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function must be called in response to the
  <code class="function">completion()</code> callback when it is invoked via a
  <code class="code">tailf:cli-custom-range-enumerator</code> statement in the data
  model. The <em class="parameter"><code>values</code></em> argument points to a
  <em class="parameter"><code>keysize</code></em> <code class="code">*</code>
  <em class="parameter"><code>nkeys</code></em> long array of strings giving the possible
  key values, where <em class="parameter"><code>keysize</code></em> is the number of keys
  for the list in the data model and <em class="parameter"><code>nkeys</code></em> is the
  number of list entries for which keys are provided. I.e. the array
  gives entry1-key1, entry1-key2, ..., entry2-key1, entry2-key2, ... and
  so on. See the <code class="filename">cli/range_create</code> example in the
  bundled examples collection for details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function must only be called for a
  <code class="function">completion()</code> callback.</p></div><div class="funcsynopsis"><a name="fn.confd_action_seterr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_action_seterr</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>If action callback encounters fatal problems that can not be
  expressed via the reply function, it may call this function with an
  appropriate message and return CONFD_ERR instead of CONFD_OK.</p><div class="funcsynopsis"><a name="fn.confd_action_seterr_extended"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_action_seterr_extended</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide more structured error
  information from an action callback, see the section
  <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_action_seterr_extended_info"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_seterr_extended_info</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide structured error
  information in the same way as
  <code class="function">confd_action_seterr_extended()</code>, and additionally
  provide contents for the NETCONF &lt;error-info&gt; element. See the
  section <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
  ERROR REPORTING</a> in <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>.</p><div class="funcsynopsis"><a name="fn.confd_action_delayed_reply_ok"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_delayed_reply_ok</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><div class="funcsynopsis"><a name="fn.confd_action_delayed_reply_error"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_delayed_reply_error</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">errstr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>If we use the CONFD_DELAYED_RESPONSE as a return value from
  the action callback, we must later asynchronously reply. If we use
  one of the <code class="function">confd_action_reply_xxx()</code> functions,
  this is a complete reply.  Otherwise we must use the
  <code class="function">confd_action_delayed_reply_ok()</code> function to
  signal success, or the
  <code class="function">confd_action_delayed_reply_error()</code> function
  to signal an error.</p><div class="funcsynopsis"><a name="fn.confd_action_set_timeout"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_action_set_timeout</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Some action callbacks may require a significantly longer
  execution time than others, and this time may not even be possible to
  determine statically (e.g. a file download). In such cases the
  <code class="sgmltag-element">/confdConfig/capi/queryTimeout</code> setting in
  <code class="filename">confd.conf</code> (see above) may be insufficient, and
  this function can be used to extend (or shorten) the timeout for the
  current callback invocation. The timeout is given in seconds from the
  point in time when the function is called.</p><p>Examples on how to work with actions are available in the User
  Guide and in the bundled examples collection.</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.authentication_callback"></a><h2>AUTHENTICATION CALLBACK</h2><p>We can register a callback with ConfD's AAA subsystem, to
  be invoked whenever AAA has completed processing of an
  authentication attempt. In the case where the authentication was
  otherwise successful, the callback can still cause it to be rejected.
  This can be used to implement specific access policies, as an
  alternative to using PAM or "External" authentication for this
  purpose. The callback will only be invoked if it is both enabled via
  <code class="sgmltag-element">/confdConfig/aaa/authenticationCallback/enabled</code> in
  <code class="filename">confd.conf</code> (see <a class="link" href="rn03re17.html" title="confd.conf">confd.conf(5)</a>) and registered as
  described here.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If the callback is enabled in
  <code class="filename">confd.conf</code> but not registered, or invocation
  keeps failing for some reason, <span class="emphasis"><em>all</em></span> authentication
  attempts will fail.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This callback can not be used to actually
  <span class="emphasis"><em>perform</em></span> the authentication. If we want to
  implement the authentication outside of ConfD, we need to use PAM or
  "External" authentication, see the <a class="link" href="ch14.html#ug.aaa.authentication" title="14.4.&nbsp;Authentication">AAA chapter in the User
  Guide</a>.</p></div><div class="funcsynopsis"><a name="fn.confd_register_auth_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_auth_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_auth_cb *<var class="pdparam">acb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Registers the authentication callback. The <span class="type">struct
  confd_auth_cb</span> is defined as:</p><div class="informalexample"><a name="struct.confd_auth_cb"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_auth_cb {
    <strong class="hl-keyword">int</strong> (*auth)(<strong class="hl-keyword">struct</strong> confd_auth_ctx *actx);
};</pre></div><p>The <code class="function">auth()</code> callback is invoked with a
  pointer to an authentication context that provides information about
  the result of the authentication so far. The callback must return
  CONFD_OK or CONFD_ERR, see below. The <span class="type">struct
  confd_auth_ctx</span> is defined as:</p><div class="informalexample"><a name="struct.confd_auth_ctx"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_auth_ctx {
    <strong class="hl-keyword">struct</strong> confd_user_info *uinfo;
    <strong class="hl-keyword">char</strong> *method;
    <strong class="hl-keyword">int</strong> success;
    <strong class="hl-keyword">union</strong> {
        <strong class="hl-keyword">struct</strong> {         <em class="hl-comment" style="color: silver">/* if success */</em>
            <strong class="hl-keyword">int</strong> ngroups;
            <strong class="hl-keyword">char</strong> **groups;
        } succ;
        <strong class="hl-keyword">struct</strong> {         <em class="hl-comment" style="color: silver">/* if !success */</em>
            <strong class="hl-keyword">int</strong> logno;   <em class="hl-comment" style="color: silver">/* number from confd_logsyms.h */</em>
            <strong class="hl-keyword">char</strong> *reason;
        } fail;
    } ainfo;
    <em class="hl-comment" style="color: silver">/* ConfD internal fields */</em>
    <strong class="hl-keyword">char</strong> *errstr;
};</pre></div><p>The <code class="varname">uinfo</code> element points to a <span class="type">struct
  confd_user_info</span> with details about the user logging in,
  specifically user name, password (if used), source IP address,
  context, and protocol. Note that the user session does not actually
  exist at this point, even if the AAA authentication was successful - it
  will only be created if the callback accepts the authentication, hence
  e.g. the <code class="varname">usid</code> element is always 0.</p><p>The <code class="varname">method</code> string gives the authentication
  method used, as follows:

  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">"password"</span></dt><dd><p>Password authentication. This generic term is used
    if the authentication failed.</p></dd><dt><span class="term">"local", "pam", "external"</span></dt><dd><p>Password authentication. On successful
    authentication, the specific method that succeeded is given. See the
    <a class="link" href="ch14.html#ug.aaa.authentication" title="14.4.&nbsp;Authentication">AAA chapter in the User
    Guide</a> for an explanation of these methods.</p></dd><dt><span class="term">"publickey"</span></dt><dd><p>Public key authentication via the internal SSH
    server.</p></dd><dt><span class="term">Other</span></dt><dd><p>Authentication with an unknown or unsupported method
    with this name was attempted via the internal SSH
    server.</p></dd></dl></div><p>If <code class="varname">success</code> is non-zero, the AAA
  authentication succeeded, and <code class="varname">groups</code> is an array of
  length <code class="varname">ngroups</code> that gives the groups that will be
  assigned to the user at login. If the callback returns CONFD_OK, the
  complete authentication succeeds and the user is logged in. If it
  returns CONFD_ERR (or an invalid return value), the authentication
  fails.</p><p>If <code class="varname">success</code> is zero, the AAA authentication
  failed (with <code class="varname">logno</code> set
  to <code class="constant">CONFD_AUTH_LOGIN_FAIL</code>), and the
  explanatory string <code class="varname">reason</code>. This invocation is
  only for informational purposes - the callback return value has no
  effect on the authentication, and should normally be
  CONFD_OK.</p><div class="funcsynopsis"><a name="fn.confd_auth_seterr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_auth_seterr</b>(</code></td><td>struct confd_auth_ctx *<var class="pdparam">actx</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be used to provide a text message when the
  callback returns CONFD_ERR. If used when rejecting a successful
  authentication, the message will be logged in ConfD's audit log
  (otherwise a generic "rejected by application callback" message is
  logged).</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.authorization_callbacks"></a><h2>AUTHORIZATION CALLBACKS</h2><p>We can register two authorization callbacks with ConfD's AAA
  subsystem. These will be invoked when the northbound agents check that
  a command or a data access is allowed by the AAA access rules. The
  callbacks can partially or completely replace the access checks done
  within the AAA subsystem, and they may accept or reject the access.
  Typically many access checks are done during the processing of
  commands etc, and using these callbacks can thus have a significant
  performance impact. Unless it is a requirement to query an external
  authorization mechanism, it is far better to only configure access
  rules in the AAA data model (see the <a class="link" href="ch14.html" title="Chapter&nbsp;14.&nbsp;The AAA infrastructure">AAA
  chapter in the User Guide</a>).</p><p>The callbacks will only be invoked if they are both enabled via
  <code class="sgmltag-element">/confdConfig/aaa/authorization/callback/enabled</code> in
  <code class="filename">confd.conf</code> (see <a class="link" href="rn03re17.html" title="confd.conf">confd.conf(5)</a>) and registered as
  described here.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If the callbacks are enabled in
  <code class="filename">confd.conf</code> but no registration has been done, or
  if invocation keeps failing for some reason, <span class="emphasis"><em>all</em></span>
  access checks will be rejected.</p></div><div class="funcsynopsis"><a name="fn.confd_register_authorization_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_authorization_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_authorization_cbs *<var class="pdparam">acb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Registers the authorization callbacks. The <span class="type">struct
  confd_authorization_cbs</span> is defined as:</p><div class="informalexample"><a name="struct.confd_authorization_cbs"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_authorization_cbs {
    <strong class="hl-keyword">int</strong> cmd_filter;
    <strong class="hl-keyword">int</strong> data_filter;
    <strong class="hl-keyword">int</strong> (*chk_cmd_access)(<strong class="hl-keyword">struct</strong> confd_authorization_ctx *actx,
                          <strong class="hl-keyword">char</strong> **cmdtokens, <strong class="hl-keyword">int</strong> ntokens, <strong class="hl-keyword">int</strong> cmdop);
    <strong class="hl-keyword">int</strong> (*chk_data_access)(<strong class="hl-keyword">struct</strong> confd_authorization_ctx *actx,
                           u_int32_t hashed_ns, confd_hkeypath_t *hkp,
                           <strong class="hl-keyword">int</strong> dataop, <strong class="hl-keyword">int</strong> how);
};</pre></div><p>Both callbacks are optional, i.e. we can set the function
  pointer in <span class="type">struct confd_authorization_cbs</span> to NULL if we
  don't want the corresponding callback invocation. In this case the AAA
  subsystem will handle the access check as if the callback was
  registered, but always replied with
  <code class="constant">CONFD_ACCESS_RESULT_DEFAULT</code> (see below).</p><p>The <code class="varname">cmd_filter</code> and
  <code class="varname">data_filter</code> elements can be used to prevent access
  checks from causing invocation of a callback even though it is
  registered. If we do not want any filtering, they must be set to
  zero. The value is a bitmask obtained by ORing together values: For
  <code class="varname">cmd_filter</code>, we can use the possible values for
  <em class="parameter"><code>cmdop</code></em> (see below), preventing the corresponding
  invocations of <code class="function">chk_cmd_access()</code>. For
  <code class="varname">data_filter</code>, we can use the possible values for
  <em class="parameter"><code>dataop</code></em> and <em class="parameter"><code>how</code></em> (see
  below), preventing the corresponding invocation of
  <code class="function">chk_data_access()</code>. If the callback invocation is
  prevented by filtering, the AAA subsystem will handle the access check
  as if the callback had replied with
  <code class="constant">CONFD_ACCESS_RESULT_CONTINUE</code> (see below).</p><p>Both callbacks are invoked with a pointer to an authorization
  context that provides information about the user session that the
  access check pertains to, and the group list for that session. The
  <span class="type">struct confd_authorization_ctx</span> is defined as:</p><div class="informalexample"><a name="struct.confd_authorization_ctx"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_authorization_ctx {
    <strong class="hl-keyword">struct</strong> confd_user_info *uinfo;
    <strong class="hl-keyword">int</strong> ngroups;
    <strong class="hl-keyword">char</strong> **groups;
    <strong class="hl-keyword">struct</strong> confd_daemon_ctx *dx;
    <em class="hl-comment" style="color: silver">/* ConfD internal fields */</em>
    <strong class="hl-keyword">int</strong> result;
    <strong class="hl-keyword">int</strong> query_ref;
};</pre></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">chk_cmd_access()</code></span></dt><dd><p>This callback is invoked for command authorization, i.e.
        it corresponds to the rules under
        <code class="sgmltag-element">/aaa/authorization/cmdrules</code> in the AAA data
        model. <em class="parameter"><code>cmdtokens</code></em> is an array of
        <em class="parameter"><code>ntokens</code></em> NUL-terminated strings
        representing the command to be checked, corresponding to the
        <code class="sgmltag-element">command</code> leaf in the <code class="sgmltag-element">cmdrule</code> list. If
        <code class="sgmltag-element">/confdConfig/cli/modeInfoInAAA</code> is enabled in
        <code class="filename">confd.conf</code> (see <a class="link" href="rn03re17.html" title="confd.conf">confd.conf(5)</a>), mode names
        will be prepended in the <em class="parameter"><code>cmdtokens</code></em> array.
        The <em class="parameter"><code>cmdop</code></em> parameter gives the operation,
        corresponding to the <code class="sgmltag-element">ops</code> leaf in the
        <code class="sgmltag-element">cmdrule</code> list. The possible values for
        <em class="parameter"><code>cmdop</code></em> are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_READ</code></span></dt><dd><p>Read access. The CLI will use this during
            command completion, to filter out alternatives that are
            disallowed by AAA.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_EXECUTE</code></span></dt><dd><p>Execute access. This is used when a command
            is about to be executed.</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This callback may be invoked with <code class="code">actx-&gt;uinfo
        == NULL</code>, meaning that no user session has been
        established for the user yet. This will occur e.g. when the CLI
        checks whether a user attempting to log in is allowed to
        (implicitly) execute the command "request system logout user"
        (J-CLI) or "logout" (C/I-CLI) when the maximum number of
        sessions has already been reached (if allowed, the CLI will ask
        whether the user wants to terminate one of the existing
        sessions).</p></div></dd><dt><span class="term"><code class="function">chk_data_access()</code></span></dt><dd><p>This callback is invoked for data authorization, i.e.  it
        corresponds to the rules under
        <code class="sgmltag-element">/aaa/authorization/datarules</code> in the AAA data
        model. <em class="parameter"><code>hashed_ns</code></em> and
        <em class="parameter"><code>hkp</code></em> give the namespace and hkeypath of
        the data node to to be checked, corresponding to the
        <code class="sgmltag-element">namespace</code> and <code class="sgmltag-element">keypath</code> leafs in the
        <code class="sgmltag-element">datarule</code> list. The <em class="parameter"><code>hkp</code></em>
        parameter may be NULL, which means that access to the entire
        namespace given by <em class="parameter"><code>hashed_ns</code></em> is
        requested. When a hkeypath is provided, some key elements in the
        path may be without key values (i.e. hkp-&gt;v[n][0].type ==
        C_NOEXISTS). This indicates "wildcard" keys, used for CLI tab
        completion when keys are not fully specified. The
        <em class="parameter"><code>dataop</code></em> parameter gives the operation,
        corresponding the <code class="sgmltag-element">ops</code> leaf in the <code class="sgmltag-element">datarule</code>
        list. The possible values for <em class="parameter"><code>dataop</code></em>
        are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_READ</code></span></dt><dd><p>Read access.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_EXECUTE</code></span></dt><dd><p>Execute access.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_CREATE</code></span></dt><dd><p>Create access.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_UPDATE</code></span></dt><dd><p>Update access.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_DELETE</code></span></dt><dd><p>Delete access.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_OP_WRITE</code></span></dt><dd><p>Write access. This is used when the specific
            write operation (create/update/delete) isn't known yet,
            e.g. in CLI command completion or processing of a NETCONF
            <span class="command"><strong>edit-config</strong></span>.</p></dd></dl></div><p>The <em class="parameter"><code>how</code></em> parameter is one of:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_ACCESS_CHK_INTERMEDIATE</code></span></dt><dd><p>Access to the given data node
            <span class="emphasis"><em>or</em></span> its descendants is requested. This
            is used e.g. in CLI command completion or processing of a
            NETCONF <span class="command"><strong>edit-config</strong></span>.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_CHK_FINAL</code></span></dt><dd><p>Access to the specific data node is
            requested.</p></dd></dl></div></dd></dl></div><div class="funcsynopsis"><a name="fn.confd_access_reply_result"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_access_reply_result</b>(</code></td><td>struct confd_authorization_ctx *<var class="pdparam">actx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">result</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The callbacks must call this function to report the result of
  the access check to ConfD, and should normally return CONFD_OK. If any
  other value is returned, it will cause the access check to be
  rejected. The <em class="parameter"><code>actx</code></em> parameter is the pointer to
  the authorization context passed in the callback invocation, and
  <em class="parameter"><code>result</code></em> must be one of:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_ACCESS_RESULT_ACCEPT</code></span></dt><dd><p>The access is allowed. This is a "final verdict",
      analogous to a "full match" when the AAA rules are
      used.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_RESULT_REJECT</code></span></dt><dd><p>The access is denied.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_RESULT_CONTINUE</code></span></dt><dd><p>The access is allowed "so far". I.e. access to
      sub-elements is not necessarily allowed. This result is mainly
      useful when <code class="function">chk_cmd_access()</code> is called with
      <em class="parameter"><code>cmdop</code></em> ==
      <code class="constant">CONFD_ACCESS_OP_READ</code> or
      <code class="function">chk_data_access()</code> is called with
      <em class="parameter"><code>how</code></em> ==
      <code class="constant">CONFD_ACCESS_CHK_INTERMEDIATE</code>.</p></dd><dt><span class="term"><code class="constant">CONFD_ACCESS_RESULT_DEFAULT</code></span></dt><dd><p>The request should be handled according to the
      rules configured in the AAA data model.</p></dd></dl></div><div class="funcsynopsis"><a name="fn.confd_authorization_set_timeout"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_authorization_set_timeout</b>(</code></td><td>struct confd_authorization_ctx *<var class="pdparam">actx</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The authorization callbacks are invoked on the daemon control
  socket, and as such are expected to complete quickly, within the
  timeout specified for
  <code class="sgmltag-element">/confdConfig/capi/newSessionTimeout</code>. However in case they
  send requests to a remote server, and such a request needs to be
  retried, this function can be used to extend the timeout for the
  current callback invocation. The timeout is given in seconds from the
  point in time when the function is called.</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.error_formatting_callback"></a><h2>ERROR FORMATTING CALLBACK</h2><p>It is possible to register a callback function to generate
  customized error messages for ConfD's internally generated
  errors. All the customizable errors are defined with a type and a code
  in the XML document
  <code class="filename">$CONFD_DIR/src/confd/errors/errcode.xml</code> in the
  ConfD release. To use this functionality, the application must
  <code class="code">#include</code> the file <code class="filename">confd_errcode.h</code>,
  which defines C constants for the types and codes.</p><div class="funcsynopsis"><a name="fn.confd_register_error_cb"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">confd_register_error_cb</b>(</code></td><td>struct confd_daemon_ctx *<var class="pdparam">dx</var>, </td></tr><tr><td>&nbsp;</td><td>const struct confd_error_cb *<var class="pdparam">ecb</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Registers the error formatting callback. The <span class="type">struct
  confd_error_cb</span> is defined as:</p><div class="informalexample"><a name="struct.confd_error_cb"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_error_cb {
    <strong class="hl-keyword">int</strong> error_types;
    <strong class="hl-keyword">void</strong> (*format_error)(<strong class="hl-keyword">struct</strong> confd_user_info *uinfo,
                         <strong class="hl-keyword">struct</strong> confd_errinfo *errinfo,
                         <strong class="hl-keyword">char</strong> *default_msg);
};</pre></div><p>The <code class="varname">error_types</code> element is the logical OR of
  the error types that the callback should handle. An application daemon
  can only register one error formatting callback, and only one daemon
  can register for each error type. The available types are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CONFD_ERRTYPE_VALIDATION</code></span></dt><dd><p>Errors detected by ConfD's internal semantic
    validation of the data model constraints, e.g. mandatory elements
    that are unset, dangling references, etc. The codes for this type
    are the <code class="varname">confd_errno</code> values corresponding to the
    validation errors, as resulting e.g. from a call to
    <code class="function">maapi_apply_trans()</code> (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>).
    I.e. CONFD_ERR_NOTSET, CONFD_ERR_BAD_KEYREF, etc - see the 'id'
    attribute in <code class="filename">errcode.xml</code>.</p></dd><dt><span class="term"><code class="constant">CONFD_ERRTYPE_BAD_VALUE</code></span></dt><dd><p>Type errors, i.e. errors generated when an invalid
    value is given for a leaf in the data model. The codes for this type
    are defined in <code class="filename">confd_errcode.h</code> as
    CONFD_BAD_VALUE_XXX, where "XXX" is the all-uppercase form of the code
    name given in <code class="filename">errcode.xml</code>.</p></dd><dt><span class="term"><code class="constant">CONFD_ERRTYPE_CLI</code></span></dt><dd><p>CLI-specific errors. The codes for this type are
    defined in <code class="filename">confd_errcode.h</code> as CONFD_CLI_XXX in
    the same way as for
    <code class="constant">CONFD_ERRTYPE_BAD_VALUE</code>.</p></dd><dt><span class="term"><code class="constant">CONFD_ERRTYPE_MISC</code></span></dt><dd><p>Miscellaneous errors, which do not fit into the
    other categories. The codes for this type are defined in
    <code class="filename">confd_errcode.h</code> as CONFD_MISC_XXX in the same
    way as for
    <code class="constant">CONFD_ERRTYPE_BAD_VALUE</code>.</p></dd><dt><span class="term"><code class="constant">CONFD_ERRTYPE_OPERATION</code></span></dt><dd><p>The same set of errors and codes as for
    <code class="constant">CONFD_ERRTYPE_VALIDATION</code>, but detected in
    validation of input parameters for an rpc or action.</p></dd></dl></div><p>The <code class="function">format_error()</code> callback is invoked with
  a pointer to a <span class="type">struct confd_errinfo</span>, which gives the error
  type and type-specific structured information about the details of the
  error. It is defined as:</p><div class="informalexample"><a name="struct.confd_errinfo"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_errinfo {
    <strong class="hl-keyword">int</strong> type;  <em class="hl-comment" style="color: silver">/* CONFD_ERRTYPE_XXX */</em>
    <strong class="hl-keyword">union</strong> {
        <strong class="hl-keyword">struct</strong> confd_errinfo_validation validation;
        <strong class="hl-keyword">struct</strong> confd_errinfo_bad_value bad_value;
        <strong class="hl-keyword">struct</strong> confd_errinfo_cli cli;
        <strong class="hl-keyword">struct</strong> confd_errinfo_misc misc;
    } info;
};</pre></div><p>For <code class="constant">CONFD_ERRTYPE_VALIDATION</code> and
  <code class="constant">CONFD_ERRTYPE_OPERATION</code>, the
  <code class="varname">struct confd_errinfo_validation validation</code>
  gives the detailed information, using an <code class="varname">info</code>
  union that has a specific struct member for each code:</p><div class="informalexample"><a name="struct.confd_errinfo_validation"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_errinfo_validation {
    <strong class="hl-keyword">int</strong> code;  <em class="hl-comment" style="color: silver">/* CONFD_ERR_NOTSET, CONFD_ERR_TOO_FEW_ELEMS, ... */</em>
    <strong class="hl-keyword">union</strong> {
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the element given by kp is not set */</em>
            confd_hkeypath_t *kp;
        } notset;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* kp has n instances, must be at least min */</em>
            confd_hkeypath_t *kp;
            <strong class="hl-keyword">int</strong> n, min;
        } too_few_elems;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* kp has n instances, must be at most max */</em>
            confd_hkeypath_t *kp;
            <strong class="hl-keyword">int</strong> n, max;
        } too_many_elems;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the elements given by kps1 have the same set
               of values vals as the elements given by kps2
               (kps1, kps2, and vals point to n_elems long arrays) */</em>
            <strong class="hl-keyword">int</strong> n_elems;
            confd_hkeypath_t *kps1;
            confd_hkeypath_t *kps2;
            confd_value_t *vals;
        } non_unique;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the element given by kp references
               the non-existing element given by ref
               Note: 'ref' may be NULL or have key elements without values
               (ref-&gt;v[n][0].type == C_NOEXISTS) if it cannot be instantiated */</em>
            confd_hkeypath_t *kp;
            confd_hkeypath_t *ref;
        } bad_keyref;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the mandatory 'choice' statement choice in the
               container kp does not have a selected 'case' */</em>
            confd_value_t *choice;
            confd_hkeypath_t *kp;
        } unset_choice;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the 'must' expression expr for element kp is not satisfied
               - error_message and and error_app_tag are NULL if not given
               in the 'must'; val points to the value of the element if it
               has one, otherwise it is NULL */</em>
            <strong class="hl-keyword">char</strong> *expr;
            confd_hkeypath_t *kp;
            <strong class="hl-keyword">char</strong> *error_message;
            <strong class="hl-keyword">char</strong> *error_app_tag;
            confd_value_t *val;
        } must_failed;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the element kp has the instance-identifier value instance,
               which doesn't exist, but require-instance is 'true' */</em>
            confd_hkeypath_t *kp;
            confd_hkeypath_t *instance;
        } missing_instance;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the element kp has the instance-identifier value instance,
               which doesn't conform to the specified path filters */</em>
            confd_hkeypath_t *kp;
            confd_hkeypath_t *instance;
        } invalid_instance;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the expression for a configuration policy rule evaluated to
               'false' - error_message is the associated error message */</em>
            <strong class="hl-keyword">char</strong> *error_message;
        } policy_failed;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the XPath expression expr, for the configuration policy
               rule with key name, could not be compiled due to msg */</em>
            <strong class="hl-keyword">char</strong> *name;
            <strong class="hl-keyword">char</strong> *expr;
            <strong class="hl-keyword">char</strong> *msg;
        } policy_compilation_failed;
        <strong class="hl-keyword">struct</strong> {
            <em class="hl-comment" style="color: silver">/* the expression expr, for the configuration policy rule
               with key name, failed XPath evaluation due to msg */</em>
            <strong class="hl-keyword">char</strong> *name;
            <strong class="hl-keyword">char</strong> *expr;
            <strong class="hl-keyword">char</strong> *msg;
        } policy_evaluation_failed;
    } info;
    <em class="hl-comment" style="color: silver">/* These are only provided for CONFD_ERRTYPE_VALIDATION */</em>
    <strong class="hl-keyword">int</strong> test;            <em class="hl-comment" style="color: silver">/* 1 if 'validate', 0 if 'commit' */</em>
    <strong class="hl-keyword">struct</strong> confd_trans_ctx *tctx; <em class="hl-comment" style="color: silver">/* only valid for duration of callback */</em>
};</pre></div><p>The member structs are named as the
  <code class="varname">confd_errno</code> values that are used for the
  <code class="varname">code</code> elements, i.e. <code class="varname">notset</code> for
  CONFD_ERR_NOTSET, etc. For <code class="constant">CONFD_ERRTYPE_VALIDATION</code>,
  the callback also has full
  information about the transaction that failed validation via the
  <code class="varname">struct confd_trans_ctx *tctx</code> element - it is even
  possible to use <code class="function">maapi_attach()</code> (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>) to
  attach to the transaction and read arbitrary data from it, in case the
  data directly related to the error (as given in the code-specific
  struct) is not sufficient.</p><p>For the other error types, the corresponding
  <code class="varname">confd_errinfo_xxx</code> struct gives the code and an
  array with the parameters for the default error message, as defined by
  the <code class="sgmltag-element">&lt;fmt&gt;</code> element in
  <code class="filename">errcode.xml</code>:</p><div class="informalexample"><a name="enum.confd_errinfo_ptype"></a><pre class="programlisting"><strong class="hl-keyword">enum</strong> confd_errinfo_ptype {
    CONFD_ERRINFO_KEYPATH,
    CONFD_ERRINFO_STRING
};</pre><a name="struct.confd_errinfo_param"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_errinfo_param {
    <strong class="hl-keyword">enum</strong> confd_errinfo_ptype type;
    <strong class="hl-keyword">union</strong> {
        confd_hkeypath_t *kp;
        <strong class="hl-keyword">char</strong> *str;
    } val;
};</pre><a name="struct.confd_errinfo_bad_value"></a><pre class="programlisting"><strong class="hl-keyword">struct</strong> confd_errinfo_bad_value {
    <strong class="hl-keyword">int</strong> code;
    <strong class="hl-keyword">int</strong> n_params;
    <strong class="hl-keyword">struct</strong> confd_errinfo_param *params;
};</pre></div><p>The parameters in the <code class="varname">params</code> array are given
  in the order they appear in the <code class="sgmltag-element">&lt;fmt&gt;</code> specification.
  Parameters that are specified as <code class="code">{path}</code> have
  <code class="varname">params[n].type</code> set to
  <code class="constant">CONFD_ERRINFO_KEYPATH</code>, and are represented as a
  <span class="type">confd_hkeypath_t</span> that can be accessed via
  <code class="varname">params[n].val.kp</code>. All other parameters are
  represented as strings, i.e. <code class="varname">params[n].type</code> is
  <code class="constant">CONFD_ERRINFO_STR</code> and the string value can be
  accessed via <code class="varname">params[n].val.str</code>. The <code class="varname">struct
  confd_errinfo_cli cli</code> and <code class="varname">struct confd_errinfo_misc
  misc</code> union members have the same form as <code class="varname">struct
  confd_errinfo_bad_value</code> shown above.</p><p>Finally, the <em class="parameter"><code>default_msg</code></em> callback
  parameter gives the default error message that will be reported to the
  user if the <code class="function">format_error()</code> function does not
  generate a replacement.</p><div class="funcsynopsis"><a name="fn.confd_error_seterr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">confd_error_seterr</b>(</code></td><td>struct confd_user_info *<var class="pdparam">uinfo</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function must be called by
  <code class="function">format_error()</code> to provide a replacement of the
  default error message. If <code class="function">format_error()</code> returns
  without calling <code class="function">confd_error_seterr()</code>, the default
  message will be used.</p><p>Here is an example that targets a specific validation error for
  a specific element in the data model. For this case only, it replaces
  ConfD's internally generated messages of the form:</p><p><code class="literal">"too many 'protocol bgp', 2 configured, at
  most 1 must be configured"</code></p><p>with</p><p><code class="literal">"Only 1 bgp instance is supported, cannot define
  2"</code></p><div class="informalexample"><pre class="programlisting">#include &lt;confd_lib.h&gt;
#include &lt;confd_dp.h&gt;
#include &lt;confd_errcode.h&gt;
.
.
int main(int argc, char **argv)
{
     struct confd_error_cb ecb;
     .
     .
     memset(&amp;ecb, 0, sizeof(ecb));
     ecb.error_types = CONFD_ERRTYPE_VALIDATION;
     ecb.format_error = format_error;
     if (confd_register_error_cb(dctx, &amp;ecb) != CONFD_OK)
          confd_fatal("Couldn't register error callback\n");
     .
}

static void format_error(struct confd_user_info *uinfo,
                         struct confd_errinfo *errinfo,
                         char *default_msg)
{
     struct confd_errinfo_validation *err;
     confd_hkeypath_t *kp;

     err = &amp;errinfo-&gt;info.validation;
     if (err-&gt;code == CONFD_ERR_TOO_MANY_ELEMS) {
          kp = err-&gt;info.too_many_elems.kp;
          if (CONFD_GET_XMLTAG(&amp;kp-&gt;v[0][0]) == myns_bgp &amp;&amp;
              CONFD_GET_XMLTAG(&amp;kp-&gt;v[1][0]) == myns_protocol) {
              confd_error_seterr(uinfo,
                                 "Only %d bgp instance is supported, "
                                 "cannot define %d",
                                 err-&gt;info.too_many_elems.max,
                                 err-&gt;info.too_many_elems.n);
          }
     }
}</pre></div><p>The CLI-specific "Aborted: " prefix is not included in the
  message for this error type - if we wanted to replace that too, we
  could include the <code class="constant">CONFD_ERRTYPE_CLI</code> error type in
  the registration and process the
  <code class="constant">CONFD_CLI_COMMAND_ABORTED</code> error code for this
  type, see <code class="filename">errcode.xml</code>.</p></div><div class="refsect1"><a name="man.3.confd_lib_dp.see_also"></a><h2>SEE ALSO</h2><p><span class="citerefentry"><span class="refentrytitle">confd.conf</span>(5)</span> - ConfD daemon configuration file format</p><p>The ConfD User Guide</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rn02re09.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="rn02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="rn02re11.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">confd_lib_cdb&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;confd_lib_events</td></tr></table></div></body></html>