'\" t
.\"     Title: confd_lib_cdb
.\"    Author:  <support@tail-f.com>
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 03/02/2018
.\"    Manual: ConfD Manual
.\"    Source: Tail-f Systems
.\"  Language: English
.\"
.TH "CONFD_LIB_CDB" "3" "03/02/2018" "Tail-f Systems" "ConfD Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
confd_lib_cdb \- library for connecting to ConfD built\-in XML database (CDB)
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <confd_lib\&.h>
#include <confd_cdb\&.h>
      
.fi
.ft
.nr wf \w'int\ cdb_connect('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sock_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr*\ srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ srv_sz);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_connect("
.br
.BI "int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_connect(int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.nr wf \w'int\ cdb_connect_name('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sock_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr*\ srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ srv_sz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_connect_name("
.br
.BI "int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ", const\ char\ *" "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_connect_name(int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ", const\ char\ *" "name" ");" \}
.nr wf \w'int\ cdb_mandatory_subscriber('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_mandatory_subscriber("
.br
.BI "int\ " "sock" ", const\ char\ *" "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_mandatory_subscriber(int\ " "sock" ", const\ char\ *" "name" ");" \}
.nr wf \w'int\ cdb_set_namespace('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_namespace("
.br
.BI "int\ " "sock" ", int\ " "hashed_ns" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_namespace(int\ " "sock" ", int\ " "hashed_ns" ");" \}
.nr wf \w'int\ cdb_end_session('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_end_session("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_end_session(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_start_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_db_type\ db);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_start_session("
.br
.BI "int\ " "sock" ", enum\ cdb_db_type\ " "db" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_start_session(int\ " "sock" ", enum\ cdb_db_type\ " "db" ");" \}
.nr wf \w'int\ cdb_start_session2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_db_type\ db,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_start_session2("
.br
.BI "int\ " "sock" ", enum\ cdb_db_type\ " "db" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_start_session2(int\ " "sock" ", enum\ cdb_db_type\ " "db" ", int\ " "flags" ");" \}
.nr wf \w'int\ cdb_close('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_close("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_close(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_wait_start('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_wait_start("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_wait_start(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_get_phase('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_phase\ *phase);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_phase("
.br
.BI "int\ " "sock" ", struct\ cdb_phase\ *" "phase" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_phase(int\ " "sock" ", struct\ cdb_phase\ *" "phase" ");" \}
.nr wf \w'int\ cdb_get_txid('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_txid\ *txid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_txid("
.br
.BI "int\ " "sock" ", struct\ cdb_txid\ *" "txid" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_txid(int\ " "sock" ", struct\ cdb_txid\ *" "txid" ");" \}
.nr wf \w'int\ cdb_initiate_journal_compaction('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_initiate_journal_compaction("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_initiate_journal_compaction(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_load_file('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *filename,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_load_file("
.br
.BI "int\ " "sock" ", const\ char\ *" "filename" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_load_file(int\ " "sock" ", const\ char\ *" "filename" ", int\ " "flags" ");" \}
.nr wf \w'int\ cdb_load_str('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *xml_str,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_load_str("
.br
.BI "int\ " "sock" ", const\ char\ *" "xml_str" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_load_str(int\ " "sock" ", const\ char\ *" "xml_str" ", int\ " "flags" ");" \}
.nr wf \w'int\ cdb_get_user_session('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_user_session("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_user_session(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_get_transaction_handle('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_transaction_handle("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_transaction_handle(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_set_timeout('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_timeout("
.br
.BI "int\ " "sock" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_timeout(int\ " "sock" ", int\ " "timeout_secs" ");" \}
.nr wf \w'int\ cdb_exists('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_exists("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_exists(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_cd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_cd("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_cd(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_pushd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_pushd("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_pushd(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_popd('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_popd("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_popd(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_getcwd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'size_t\ strsz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *curdir);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_getcwd("
.br
.BI "int\ " "sock" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_getcwd(int\ " "sock" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.nr wf \w'int\ cdb_getcwd_kpath('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **kp);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_getcwd_kpath("
.br
.BI "int\ " "sock" ", confd_hkeypath_t\ **" "kp" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_getcwd_kpath(int\ " "sock" ", confd_hkeypath_t\ **" "kp" ");" \}
.nr wf \w'int\ cdb_num_instances('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_num_instances("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_num_instances(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_next_index('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_next_index("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_next_index(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_index('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_index("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_index(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_is_default('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_is_default("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_is_default(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_subscribe2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sub_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ priority,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *spoint,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nspace,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_subscribe2("
.br
.BI "int\ " "sock" ", enum\ cdb_sub_type\ " "type" ", int\ " "flags" ", int\ " "priority" ", int\ *" "spoint" ", int\ " "nspace" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_subscribe2(int\ " "sock" ", enum\ cdb_sub_type\ " "type" ", int\ " "flags" ", int\ " "priority" ", int\ *" "spoint" ", int\ " "nspace" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_subscribe('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ priority,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nspace,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *spoint,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_subscribe("
.br
.BI "int\ " "sock" ", int\ " "priority" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_subscribe(int\ " "sock" ", int\ " "priority" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_oper_subscribe('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nspace,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *spoint,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_oper_subscribe("
.br
.BI "int\ " "sock" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_oper_subscribe(int\ " "sock" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_subscribe_done('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_subscribe_done("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_subscribe_done(int\ " "sock" ");" \}
.nr wf \w'int\ cdb_trigger_subscriptions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ len);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_trigger_subscriptions("
.br
.BI "int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_trigger_subscriptions(int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.nr wf \w'int\ cdb_trigger_oper_subscriptions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ len,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_trigger_oper_subscriptions("
.br
.BI "int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_trigger_oper_subscriptions(int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ", int\ " "flags" ");" \}
.nr wf \w'int\ cdb_diff_match('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ xml_tag\ tags[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ tagslen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_diff_match("
.br
.BI "int\ " "sock" ", int\ " "subid" ", struct\ xml_tag\ " "tags[]" ", int\ " "tagslen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_diff_match(int\ " "sock" ", int\ " "subid" ", struct\ xml_tag\ " "tags[]" ", int\ " "tagslen" ");" \}
.nr wf \w'int\ cdb_read_subscription_socket('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *resultlen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_read_subscription_socket("
.br
.BI "int\ " "sock" ", int\ " "sub_points[]" ", int\ *" "resultlen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_read_subscription_socket(int\ " "sock" ", int\ " "sub_points[]" ", int\ *" "resultlen" ");" \}
.nr wf \w'int\ cdb_read_subscription_socket2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sub_notification\ *type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *subpoints[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *resultlen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_read_subscription_socket2("
.br
.BI "int\ " "sock" ", enum\ cdb_sub_notification\ *" "type" ", int\ *" "flags" ", int\ *" "subpoints[]" ", int\ *" "resultlen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_read_subscription_socket2(int\ " "sock" ", enum\ cdb_sub_notification\ *" "type" ", int\ *" "flags" ", int\ *" "subpoints[]" ", int\ *" "resultlen" ");" \}
.nr wf \w'int\ cdb_replay_subscriptions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_txid\ *txid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ len);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_replay_subscriptions("
.br
.BI "int\ " "sock" ", struct\ cdb_txid\ *" "txid" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_replay_subscriptions(int\ " "sock" ", struct\ cdb_txid\ *" "txid" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.nr wf \w'int\ cdb_get_replay_txids('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_txid\ **txid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *resultlen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_replay_txids("
.br
.BI "int\ " "sock" ", struct\ cdb_txid\ **" "txid" ", int\ *" "resultlen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_replay_txids(int\ " "sock" ", struct\ cdb_txid\ **" "txid" ", int\ *" "resultlen" ");" \}
.nr wf \w'int\ cdb_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "subid" ", enum\ cdb_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_diff_iterate(int\ " "sock" ", int\ " "subid" ", enum\ cdb_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.nr wf \w'int\ cdb_diff_iterate_resume('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_ret\ reply,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_ret\ (*iter)(\ confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *resumestate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_diff_iterate_resume("
.br
.BI "int\ " "sock" ", enum\ cdb_iter_ret\ " "reply" ", enum\ cdb_iter_ret\ (*" "iter" ")(\ confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_diff_iterate_resume(int\ " "sock" ", enum\ cdb_iter_ret\ " "reply" ", enum\ cdb_iter_ret\ (*" "iter" ")(\ confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.nr wf \w'int\ cdb_cli_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'cli_diff_iter_function_t\ *iter,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_cli_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "subid" ", cli_diff_iter_function_t\ *" "iter" ", int\ " "flags" ", void\ *" "initstate" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_cli_diff_iterate(int\ " "sock" ", int\ " "subid" ", cli_diff_iter_function_t\ *" "iter" ", int\ " "flags" ", void\ *" "initstate" ");" \}
.nr wf \w'int\ cdb_get_modifications('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_modifications("
.br
.BI "int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_modifications(int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_modifications_iter('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_modifications_iter("
.br
.BI "int\ " "sock" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_modifications_iter(int\ " "sock" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ");" \}
.nr wf \w'int\ cdb_get_modifications_cli('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **str);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_modifications_cli("
.br
.BI "int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", char\ **" "str" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_modifications_cli(int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", char\ **" "str" ");" \}
.nr wf \w'int\ cdb_sync_subscription_socket('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_subscription_sync_type\ st);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sync_subscription_socket("
.br
.BI "int\ " "sock" ", enum\ cdb_subscription_sync_type\ " "st" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sync_subscription_socket(int\ " "sock" ", enum\ cdb_subscription_sync_type\ " "st" ");" \}
.nr wf \w'int\ cdb_sub_progress('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sub_progress("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sub_progress(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_sub_abort_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sub_abort_trans("
.br
.BI "int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sub_abort_trans(int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_sub_abort_trans_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sub_abort_trans_info("
.br
.BI "int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sub_abort_trans_info(int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_case('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *rcase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_case("
.br
.BI "int\ " "sock" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_case(int\ " "sock" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get(int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_int8('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int8_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int8("
.br
.BI "int\ " "sock" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int8(int\ " "sock" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_int16('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int16_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int16("
.br
.BI "int\ " "sock" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int16(int\ " "sock" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_int32('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int32("
.br
.BI "int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int32(int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_int64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int64("
.br
.BI "int\ " "sock" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int64(int\ " "sock" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_u_int8('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int8_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int8("
.br
.BI "int\ " "sock" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int8(int\ " "sock" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_u_int16('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int16_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int16("
.br
.BI "int\ " "sock" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int16(int\ " "sock" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_u_int32('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int32("
.br
.BI "int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int32(int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_u_int64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int64("
.br
.BI "int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int64(int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_bit32('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bit32("
.br
.BI "int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bit32(int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_bit64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bit64("
.br
.BI "int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bit64(int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_bitbig('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bitbig("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bitbig(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_ipv4('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ in_addr\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv4("
.br
.BI "int\ " "sock" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv4(int\ " "sock" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_ipv6('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ in6_addr\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv6("
.br
.BI "int\ " "sock" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv6(int\ " "sock" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_double('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'double\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_double("
.br
.BI "int\ " "sock" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_double(int\ " "sock" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_bool('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bool("
.br
.BI "int\ " "sock" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bool(int\ " "sock" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_datetime('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_datetime("
.br
.BI "int\ " "sock" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_datetime(int\ " "sock" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_date('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_date\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_date("
.br
.BI "int\ " "sock" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_date(int\ " "sock" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_time('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_time\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_time("
.br
.BI "int\ " "sock" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_time(int\ " "sock" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_duration('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_duration\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_duration("
.br
.BI "int\ " "sock" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_duration(int\ " "sock" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_enum_value('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_enum_value("
.br
.BI "int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_enum_value(int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_objectref('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_objectref("
.br
.BI "int\ " "sock" ", confd_hkeypath_t\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_objectref(int\ " "sock" ", confd_hkeypath_t\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_oid('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_snmp_oid\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_oid("
.br
.BI "int\ " "sock" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_oid(int\ " "sock" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_buf('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_buf("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_buf(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_buf2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_buf2("
.br
.BI "int\ " "sock" ", unsigned\ char\ *" "rval" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_buf2(int\ " "sock" ", unsigned\ char\ *" "rval" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_str('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_str("
.br
.BI "int\ " "sock" ", char\ *" "rval" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_str(int\ " "sock" ", char\ *" "rval" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_binary('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_binary("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_binary(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_hexstr('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_hexstr("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_hexstr(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_qname('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **prefix,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *prefixsz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *namesz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_qname("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_qname(int\ " "sock" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_list('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_list("
.br
.BI "int\ " "sock" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_list(int\ " "sock" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_ipv4prefix('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv4_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv4prefix("
.br
.BI "int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv4prefix(int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_ipv6prefix('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv6_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv6prefix("
.br
.BI "int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv6prefix(int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_decimal64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_decimal64\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_decimal64("
.br
.BI "int\ " "sock" ", struct\ confd_decimal64\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_decimal64(int\ " "sock" ", struct\ confd_decimal64\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_identityref('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_identityref\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_identityref("
.br
.BI "int\ " "sock" ", struct\ confd_identityref\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_identityref(int\ " "sock" ", struct\ confd_identityref\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_ipv4_and_plen('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv4_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv4_and_plen("
.br
.BI "int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv4_and_plen(int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_ipv6_and_plen('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv6_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv6_and_plen("
.br
.BI "int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv6_and_plen(int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_dquad('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_dotted_quad\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_dquad("
.br
.BI "int\ " "sock" ", struct\ confd_dotted_quad\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_dquad(int\ " "sock" ", struct\ confd_dotted_quad\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_vget('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_vget("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_vget(int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.nr wf \w'int\ cdb_get_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_object("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_object(int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_objects('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ ix,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_objects("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ " "ix" ", int\ " "nobj" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_objects(int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ " "ix" ", int\ " "nobj" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_get_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_values("
.br
.BI "int\ " "sock" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_values(int\ " "sock" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_set_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *val,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_elem("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_elem(int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_set_elem2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *strval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_elem2("
.br
.BI "int\ " "sock" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_elem2(int\ " "sock" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_vset_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *val,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_vset_elem("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_vset_elem(int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.nr wf \w'int\ cdb_set_case('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *scase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_case("
.br
.BI "int\ " "sock" ", const\ char\ *" "choice" ", const\ char\ *" "scase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_case(int\ " "sock" ", const\ char\ *" "choice" ", const\ char\ *" "scase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_create('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_create("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_create(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_delete('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_delete("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_delete(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_set_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_object("
.br
.BI "int\ " "sock" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_object(int\ " "sock" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_set_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_values("
.br
.BI "int\ " "sock" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_values(int\ " "sock" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.SH "LIBRARY"
.PP
ConfD Library, (libconfd,
\fB\-lconfd\fR)
.SH "DESCRIPTION"
.PP
The
libconfd
shared library is used to connect to the ConfD built\-in XML database, CDB\&. The purpose of this API is to provide a read and subscription API to CDB\&.
.PP
CDB owns and stores the configuration data and the user of the API wants to read that configuration data and also get notified when someone through either NETCONF, SNMP, the CLI, the Web UI or the MAAPI modifies the data so that the application can re\-read the configuration data and act accordingly\&.
.PP
CDB can also store operational data, i\&.e\&. data which is designated with a
"config false"
statement in the YANG data model\&. Operational data can be both read and written by the applications, but NETCONF and the other northbound agents can only read the operational data\&.
.SH "PATHS"
.PP
The majority of the functions described here take as their two last arguments a format string and a variable number of extra arguments as in:
\fBchar *\fR\fIfmt\fR,
\fI\&.\&.\&.\fR);
.PP
The
\fIfmt\fR
is a printf style format string which is used to format a path into the XML data tree\&. Assume the following YANG fragment:
.sp
.if n \{\
.RS 4
.\}
.nf
container hosts {
  list host {
    key name;
    leaf name {
      type string;
    }
    leaf domain {
      type string;
    }
    leaf defgw {
      type inet:ipv4\-address;
    }
    container interfaces {
      list interface {
        key name;
        leaf name {
          type string;
        }
        leaf ip {
          type inet:ipv4\-address;
        }
        leaf mask {
          type inet:ipv4\-address;
        }
        leaf enabled {
          type boolean;
        }
      }
    }
  }
}
.fi
.if n \{\
.RE
.\}
.PP
Furthermore, assuming our database is populated with the following data\&.
.sp
.if n \{\
.RS 4
.\}
.nf
<hosts xmlns="http://example\&.com/ns/hst/1\&.0">
  <host>
    <name>buzz</name>
    <domain>tail\-f\&.com</domain>
    <defgw>192\&.168\&.1\&.1</defgw>
    <interfaces>
      <interface>
        <name>eth0</name>
        <ip>192\&.168\&.1\&.61</ip>
        <mask>255\&.255\&.255\&.0</mask>
        <enabled>true</enabled>
      </interface>
      <interface>
        <name>eth1</name>
        <ip>10\&.77\&.1\&.44</ip>
        <mask>255\&.255\&.0\&.0</mask>
        <enabled>false</enabled>
      </interface>
    </interfaces>
  </host>
</hosts>
.fi
.if n \{\
.RE
.\}
.PP
The format path
/hosts/host{buzz}/defgw
refers to the leaf called
defgw
of the host whose key (name
leaf) is
buzz\&.
.PP
The format path
/hosts/host{buzz}/interfaces/interface{eth0}/ip
refers to the leaf called
ip
in the
eth0
interface of the host called
buzz\&.
.PP
It is possible loop through all entries in a list as in:
.sp
.if n \{\
.RS 4
.\}
.nf
n = cdb_num_instances(sock, "/hosts/host");
for (i=0; i<n; i++) {
    cdb_cd(sock, "/hosts/host[%d]", i)
    \&.\&.\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.PP
Thus instead of an actually instantiated key inside a pair of curly braces
{key}, we can use a temporary integer key inside a pair of brackets
[n]\&.
.PP
We can use the following modifiers:
.PP
%d
.RS 4
requiring an integer parameter (type
\fBint\fR) to be substituted\&.
.RE
.PP
%u
.RS 4
requiring an unsigned integer parameter (type
\fBunsigned int\fR) to be substituted\&.
.RE
.PP
%s
.RS 4
requiring a
\fBchar*\fR
string parameter to be substituted\&.
.RE
.PP
%ip4
.RS 4
requiring a
\fBstruct in_addr*\fR
to be substituted\&.
.RE
.PP
%ip6
.RS 4
requiring a
\fBstruct in6_addr*\fR
to be substituted\&.
.RE
.PP
%x
.RS 4
requiring a
\fBconfd_value_t*\fR
to be substituted\&.
.RE
.PP
%*x
.RS 4
requiring an array length and a
\fBconfd_value_t*\fR
pointing to an array of values to be substituted\&.
.RE
.PP
%h
.RS 4
requiring a
\fBconfd_hkeypath_t*\fR
to be substituted\&.
.RE
.PP
%*h
.RS 4
requiring a length and a
\fBconfd_hkeypath_t*\fR
to be substituted\&.
.RE
.PP
Thus,
.sp
.if n \{\
.RS 4
.\}
.nf
char *hname = "earth";
struct in_addr ip;
ip\&.s_addr = inet_addr("127\&.0\&.0\&.1");

cdb_cd(sock, "/hosts/host{%s}/bar{%ip4}", hname, &ip);
.fi
.if n \{\
.RE
.\}
.PP
would change the current position to the path:
"/hosts/host{earth}/bar{127\&.0\&.0\&.1}"
.PP
It is also possible to use the different \*(Aq%\*(Aq modifiers outside the curly braces, thus the above example could have been written as:
.sp
.if n \{\
.RS 4
.\}
.nf
char *prefix = "/hosts/host";
cdb_cd(sock, "%s{%s}/bar{%ip4}", prefix, hname, &ip);
.fi
.if n \{\
.RE
.\}
.PP
If an element has multiple keys, the keys must be space separated as in
cdb_cd("/bars/bar{%s %d}/item", str, i);\&. However the \*(Aq%*x\*(Aq modifier is an exception to this rule, and it is especially useful when we have a number of key values that are unknown at compile time\&. If we have a list
foo
which is known to have two keys, and we have those keys in an array
key[], we can use
cdb_cd("/foo{%x %x}", &key[0], &key[1]);\&.
But if the number of keys is unknown at compile time (or if we just want a more compact code), we can instead use
cdb_cd("/foo{%*x}", n, key);
where
\fIn\fR
is the number of keys\&.
.PP
The \*(Aq%h\*(Aq and \*(Aq%*h\*(Aq modifiers can only be used at the beginning of a format path, as they expand to the absolute path corresponding to the
\fBconfd_hkeypath_t\fR\&. These modifiers are particularly useful with
\fBcdb_diff_iterate()\fR
(see below), or for MAAPI access in data provider callbacks (see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[]
and
\m[blue]\fBconfd_lib_dp(3)\fR\m[])\&. The \*(Aq%*h\*(Aq variant allows for using only the initial part of a
\fBconfd_hkeypath_t\fR, as specified by the preceding length argument (similar to \*(Aq%\&.*s\*(Aq for
\fBprintf(3)\fR)\&.
.PP
For example, if the
\fBiter()\fR
function passed to
\fBcdb_diff_iterate()\fR
has been invoked with a
\fBconfd_hkeypath_t *kp\fR
that corresponds to
/hosts/host{buzz}, we can read the
defgw
child element with
.sp
.if n \{\
.RS 4
.\}
.nf
confd_value_t v;
cdb_get(s, &v, "%h/defgw", kp);
.fi
.if n \{\
.RE
.\}
.PP
or the entire list entry with
.sp
.if n \{\
.RS 4
.\}
.nf
confd_value_t v[5];
cdb_get_object(sock, v, 5, "%h", kp);
.fi
.if n \{\
.RE
.\}
.PP
or the
defgw
child element for host
mars
with
.sp
.if n \{\
.RS 4
.\}
.nf
confd_value_t v;
cdb_get(s, &v, "%*h{mars}/defgw", kp\->len \- 1, kp);
.fi
.if n \{\
.RE
.\}
.PP
All the functions that take a path on this form also have a
\fBva_list\fR
variant, of the same form as
\fBcdb_vget()\fR
and
\fBcdb_vset_elem()\fR, which are the only ones explicitly documented below\&. I\&.e\&. they have a prefix "cdb_v" instead of "cdb_", and take a single va_list argument instead of a variable number of arguments\&.
.SH "FUNCTIONS"
.PP
All functions return CONFD_OK (0), CONFD_ERR (\-1) or CONFD_EOF (\-2) unless otherwise stated\&. CONFD_EOF means that the socket to ConfD has been closed\&.
.PP
Whenever CONFD_ERR is returned from any API function described here, it is possible to obtain additional information on the error through the symbol
\fIconfd_errno\fR, see the
\m[blue]\fBERRORS\fR\m[]
section in the
\m[blue]\fBconfd_lib_lib(3)\fR\m[]
manual page\&.
.nr wf \w'int\ cdb_connect('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sock_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr*\ srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ srv_sz);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_connect("
.br
.BI "int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_connect(int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ");" \}
.PP
The application has to connect to ConfD before it can interact\&. There are two different types of connections identified by
\fBcdb_sock_type\fR:
.PP
\fBCDB_DATA_SOCKET\fR
.RS 4
This is a socket which is used to read configuration data, or to read and write operational data\&.
.RE
.PP
\fBCDB_SUBSCRIPTION_SOCKET\fR
.RS 4
This is a socket which is used to receive notifications about updates to the database\&. A subscription socket needs to be part of the application poll set\&.
.RE
.PP
Additionally the type CDB_READ_SOCKET is accepted for backwards compatibility \- it is equivalent to CDB_DATA_SOCKET\&.
.PP
A call to
\fBcdb_connect()\fR
is typically followed by a call to either
\fBcdb_start_session()\fR
for a reading session or a call to
\fBcdb_subscribe()\fR
for a subscription socket\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If this call fails (i\&.e\&. does not return CONFD_OK), the socket descriptor must be closed and a new socket created before the call is re\-attempted\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_connect_name('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sock_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ struct\ sockaddr*\ srv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ srv_sz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_connect_name("
.br
.BI "int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ", const\ char\ *" "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_connect_name(int\ " "sock" ", enum\ cdb_sock_type\ " "type" ", const\ struct\ sockaddr*\ " "srv" ", int\ " "srv_sz" ", const\ char\ *" "name" ");" \}
.PP
When we use
\fBcdb_connect()\fR
to create a connection to ConfD/CDB, the
\fIname\fR
parameter passed to the library initialization function
\fBconfd_init()\fR
(see
\m[blue]\fBconfd_lib_lib(3)\fR\m[]) is used to identify the connection in status reports and logs\&. I we want different names to be used for different connections from the same application process, we can use
\fBcdb_connect_name()\fR
with the wanted name instead of
\fBcdb_connect()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If this call fails (i\&.e\&. does not return CONFD_OK), the socket descriptor must be closed and a new socket created before the call is re\-attempted\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_mandatory_subscriber('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *name);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_mandatory_subscriber("
.br
.BI "int\ " "sock" ", const\ char\ *" "name" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_mandatory_subscriber(int\ " "sock" ", const\ char\ *" "name" ");" \}
.PP
Attaches a mandatory attribute and a mandatory name to the subscriber identified by
\fIsock\fR\&. The
\fIname\fR
parameter is distinct from the name parameter in
\fBcdb_connect_name\fR\&.
.PP
CDB keeps a list of mandatory subscribers for infinite extent, i\&.e\&. until confd is restarted\&. The function is idempotent\&.
.PP
Absence of one or more mandatory subscribers will result in abort of all transactions\&. A mandatory subscriber must be present during the entire PREPARE delivery phase\&.
.PP
If a mandatory subscriber crashes during a PREPARE delivery phase, the subscriber should be restarted and the commit operation should be retried\&.
.PP
A mandatory subscriber is present if the subscriber has issued at least one
\fBcdb_subscribe2()\fR
call followed by a
\fBcdb_subscribe_done()\fR
call\&.
.PP
A call to
\fBcdb_mandatory_subscriber()\fR
is only allowed before the first call of
\fBcdb_subscribe2()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Only applicable for two\-phase subscribers\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_set_namespace('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ hashed_ns);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_namespace("
.br
.BI "int\ " "sock" ", int\ " "hashed_ns" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_namespace(int\ " "sock" ", int\ " "hashed_ns" ");" \}
.PP
If we want to access data in CDB where the toplevel element name is not unique, we need to set the namespace\&. We are reading data related to a specific \&.fxs file\&. confdc can be used to generate a
\fB\&.h\fR
file with a #define for the namespace, by the flag
\fB\-\-emit\-h\fR
to confdc (see
\m[blue]\fBconfdc(1)\fR\m[])\&.
.PP
It is also possible to indicate which namespace to use through the namespace prefix when we read and write data\&. Thus the path
/foo:bar/baz
will get us
/bar/baz
in the namespace with prefix "foo" regardless of what the "set" namespace is\&. And if there is only one toplevel element called "bar" across all namespaces, we can use
/bar/baz
without the prefix and without calling
\fBcdb_set_namespace()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_end_session('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_end_session("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_end_session(int\ " "sock" ");" \}
.PP
We use
\fBcdb_connect()\fR
to establish a read socket to CDB\&. When the socket is closed, the read session is ended\&. We can reuse the same socket for another read session, but we must then end the session and create another session using
\fBcdb_start_session()\fR\&.
.PP
While we have a live CDB read session for configuration data, CDB is normally locked for writing\&. Thus all external entities trying to modify CDB are blocked as long as we have an open CDB read session\&. It is very important that we remember to either
\fBcdb_end_session()\fR
or
\fBcdb_close()\fR
once we have read what we wish to read\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_start_session('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_db_type\ db);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_start_session("
.br
.BI "int\ " "sock" ", enum\ cdb_db_type\ " "db" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_start_session(int\ " "sock" ", enum\ cdb_db_type\ " "db" ");" \}
.PP
Starts a new session on an already established socket to CDB\&. The db parameter should be one of:
.PP
\fBCDB_RUNNING\fR
.RS 4
Creates a read session towards the running database\&.
.RE
.PP
\fBCDB_PRE_COMMIT_RUNNING\fR
.RS 4
Creates a read session towards the running database as it was before the current transaction was committed\&. This is only possible between a subscription notification and the final
\fBcdb_sync_subscription_socket()\fR\&. At any other time trying to call
\fBcdb_start_session()\fR
will fail with confd_errno set to CONFD_ERR_NOEXISTS\&.
.sp
In the case of a
\fBCDB_SUB_PREPARE\fR
subscription notification a session towards
\fBCDB_PRE_COMMIT_RUNNING\fR
will (in spite of the name) will return values as they were
\fIbefore the transaction which is about to be committed\fR
took place\&. This means that if you want to read the new values during a
\fBCDB_SUB_PREPARE\fR
subscription notification you need to create a session towards
\fBCDB_RUNNING\fR\&. However, since it is locked the session needs to be started in lockless mode using
\fBcdb_start_session2()\fR\&. So for example:
.sp
.if n \{\
.RS 4
.\}
.nf
cdb_read_subscription_socket2(ss, &type, &flags, &subp, &len);
/* \&.\&.\&. */
switch (type) {
case CDB_SUB_PREPARE:
    /* Set up a lockless session to read new values: */
    cdb_start_session2(s, CDB_RUNNING, 0);
    read_new_config(s);
    cdb_end_session(s);
    cdb_sync_subscription_socket(ss, CDB_DONE_PRIORITY);
    break;
    /* \&.\&.\&. */
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fBCDB_STARTUP\fR
.RS 4
Creates a read session towards the startup database\&.
.RE
.PP
\fBCDB_OPERATIONAL\fR
.RS 4
Creates a read/write session towards the operational database\&. For further details about working with operational data in CDB, see the
\fBOPERATIONAL DATA\fR
section below\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Subscriptions on operational data will not be triggered from a session created with this function \- to trigger operational data subscriptions, we need to use
\fBcdb_start_session2()\fR, see below\&.
.sp .5v
.RE
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_LOCKED, CONFD_ERR_NOEXISTS
.PP
If the error is CONFD_ERR_LOCKED it means that we are trying to create a new CDB read session precisely when the write phase of some transaction is occurring\&. Thus correct usage of
\fBcdb_start_session()\fR
is:
.sp
.if n \{\
.RS 4
.\}
.nf
 while (1) {
   if (cdb_start_session(sock, CDB_RUNNING) == CONFD_OK)
      break;
   if (confd_errno == CONFD_ERR_LOCKED) {
      sleep(1);
      continue;
   }
   \&.\&.\&.\&. handle error
}
.fi
.if n \{\
.RE
.\}
.PP
Alternatively we can use
\fBcdb_start_session2()\fR
with
\fIflags\fR
= CDB_LOCK_SESSION|CDB_LOCK_WAIT\&. This means that the call will block until the lock has been acquired, and thus we do not need the retry loop\&.
.nr wf \w'int\ cdb_start_session2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_db_type\ db,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_start_session2("
.br
.BI "int\ " "sock" ", enum\ cdb_db_type\ " "db" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_start_session2(int\ " "sock" ", enum\ cdb_db_type\ " "db" ", int\ " "flags" ");" \}
.PP
This function may be used instead of
\fBcdb_start_session()\fR
if it is considered necessary to have more detailed control over some aspects of the CDB session \- if in doubt, use
\fBcdb_start_session()\fR
instead\&. The
\fIsock\fR
and
\fIdb\fR
arguments are the same as for
\fBcdb_start_session()\fR, and these values can be used for
\fIflags\fR
(ORed together if more than one):
.sp
.if n \{\
.RS 4
.\}
.nf
#define CDB_LOCK_WAIT     (1 << 0)
#define CDB_LOCK_SESSION  (1 << 1)
#define CDB_LOCK_REQUEST  (1 << 2)
#define CDB_LOCK_PARTIAL  (1 << 3)
.fi
.if n \{\
.RE
.\}
.PP
The flags affect sessions for the different database types as follows:
.PP
\fBCDB_RUNNING\fR
.RS 4
CDB_LOCK_SESSION obtains a read lock for the complete session, i\&.e\&. using this flag alone is equivalent to calling
\fBcdb_start_session()\fR\&. CDB_LOCK_REQUEST obtains a read lock only for the duration of each read request\&. This means that values of elements read in different requests may be inconsistent with each other, and the consequences of this must be carefully considered\&. In particular, the use of
\fBcdb_num_instances()\fR
and the
[n]
"integer index" notation in keypaths is inherently unsafe in this mode\&. Note: The implementation will not actually obtain a lock for a single\-value request, since that is an atomic operation anyway\&. The CDB_LOCK_PARTIAL flag is not allowed\&.
.RE
.PP
\fBCDB_STARTUP\fR
.RS 4
Same as CDB_RUNNING\&.
.RE
.PP
\fBCDB_PRE_COMMIT_RUNNING\fR
.RS 4
This database type does not have any locks, which means that it is an error to call
\fBcdb_start_session2()\fR
with any CDB_LOCK_XXX flag included in
\fIflags\fR\&. Using a
\fIflags\fR
value of 0 is equivalent to calling
\fBcdb_start_session()\fR\&.
.RE
.PP
\fBCDB_OPERATIONAL\fR
.RS 4
CDB_LOCK_REQUEST obtains a "subscription lock" for the duration of each write request\&. This can be described as an "advisory exclusive" lock, i\&.e\&. only one client at a time can hold the lock (unless CDB_LOCK_PARTIAL is used), but the lock does not affect clients that do not attempt to obtain it\&. It also does not affect the reading of operational data\&. The purpose of this lock is to indicate that the client wants the write operation to generate subscription notifications\&. The lock remains in effect until any/all subscription notifications generated as a result of the write has been delivered\&.
.sp
If the CDB_LOCK_PARTIAL flag is used together with CDB_LOCK_REQUEST, the "subscription lock" only applies to the smallest data subtree that includes all the data in the write request\&. This means that multiple writes that generates subscription notifications, and delivery of the corresponding notifications, can proceed in parallel as long as they affect disjunct parts of the data tree\&.
.sp
The CDB_LOCK_SESSION flag is not allowed\&. Using a
\fIflags\fR
value of 0 is equivalent to calling
\fBcdb_start_session()\fR\&.
.RE
.PP
In all cases of using CDB_LOCK_SESSION or CDB_LOCK_REQUEST described above, adding the CDB_LOCK_WAIT flag means that instead of failing with CONFD_ERR_LOCKED if the lock can not be obtained immediately, requests will wait for the lock to become available\&. When used with CDB_LOCK_SESSION it pertains to
\fBcdb_start_session2()\fR
itself, with CDB_LOCK_REQUEST it pertains to the individual requests\&.
.PP
While it is possible to use this function to start a session towards a configuration database type with no locking at all (\fIflags\fR
= 0), this is strongly discouraged in general, since it means that even the values read in a single multi\-value request (e\&.g\&.
\fBcdb_get_object()\fR, see below) may be inconsistent with each other\&. However it is necessary to do this if we want to have a session open during semantic validation, see the "Semantic Validation" chapter in the User Guide \- and in this particular case it is safe, since the transaction lock prevents changes to CDB during validation\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_LOCKED, CONFD_ERR_NOEXISTS, CONFD_ERR_PROTOUSAGE
.nr wf \w'int\ cdb_close('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_close("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_close(int\ " "sock" ");" \}
.PP
Closes the socket\&.
\fBcdb_end_session()\fR
should be called before calling this function\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS
.PP
Even if the call returns an error, the socket will be closed\&.
.nr wf \w'int\ cdb_wait_start('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_wait_start("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_wait_start(int\ " "sock" ");" \}
.PP
This call waits until CDB has completed start\-phase 1 and is available, when it is CONFD_OK is returned\&. If CDB already is available (i\&.e\&. start\-phase >= 1) the call returns immediately\&. This can be used by a CDB client who is not synchronously started and only wants to wait until it can read its configuration\&. The call can be used after cdb_connect()\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_get_phase('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_phase\ *phase);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_phase("
.br
.BI "int\ " "sock" ", struct\ cdb_phase\ *" "phase" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_phase(int\ " "sock" ", struct\ cdb_phase\ *" "phase" ");" \}
.PP
Returns the start\-phase CDB is currently in, in the struct cdb_phase pointed to by the second argument\&. Also if CDB is in phase 0 and has initiated an init transaction (to load any init files) the flag CDB_FLAG_INIT is set in the flags field of struct cdb_phase and correspondingly if an upgrade session is started the CDB_FLAG_UPGRADE is set\&. The call can be used after cdb_connect() and returns CONFD_OK\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_initiate_journal_compaction('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_initiate_journal_compaction("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_initiate_journal_compaction(int\ " "sock" ");" \}
.PP
Normally CDB handles journal compaction of the config datastore automatically\&. If this has been turned off (in the configuration file) then the A\&.cdb file will grow indefinitely unless this API function is called periodically to initiate compaction\&. This function initiates a compaction and returns immediately (if the datastore is locked, the compaction will be delayed, but eventually compaction will take place)\&. Calling this function when journal compaction is configured to be automatic has no effect\&.
.PP
\fIErrors\fR: \-
.nr wf \w'int\ cdb_get_txid('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_txid\ *txid);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_txid("
.br
.BI "int\ " "sock" ", struct\ cdb_txid\ *" "txid" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_txid(int\ " "sock" ", struct\ cdb_txid\ *" "txid" ");" \}
.PP
Read the last transaction id from CDB\&. This function can be used if we are forced to reconnect to CDB, If the transaction id we read is identical to the last id we had prior to loosing the CDB sockets we don\*(Aqt have to reload our managed object data\&. See the User Guide for full explanation\&. Returns CONFD_OK on success and CONFD_ERR or CONFD_EOF on failure\&.
.nr wf \w'int\ cdb_get_replay_txids('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_txid\ **txid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *resultlen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_replay_txids("
.br
.BI "int\ " "sock" ", struct\ cdb_txid\ **" "txid" ", int\ *" "resultlen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_replay_txids(int\ " "sock" ", struct\ cdb_txid\ **" "txid" ", int\ *" "resultlen" ");" \}
.PP
When the subscriptionReplay functionality is enabled in confd\&.conf this function returns the list of available transactions that CDB can replay\&. The current transaction id will be the first in the list, the second at txid[1] and so on\&. The number of transactions is returned in
\fIresultlen\fR\&. In case there are no replay transactions available (the feature isn\*(Aqt enabled or there hasn\*(Aqt been any transactions yet) only one (the current) transaction id is returned\&. It is up to the caller to
\fBfree()\fR\fItxid\fR
when it is no longer needed\&.
.nr wf \w'int\ cdb_set_timeout('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ timeout_secs);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_timeout("
.br
.BI "int\ " "sock" ", int\ " "timeout_secs" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_timeout(int\ " "sock" ", int\ " "timeout_secs" ");" \}
.PP
A timeout for client actions can be specified via
/confdConfig/cdb/clientTimeout
in
confd\&.conf, see the
\m[blue]\fBconfd\&.conf(5)\fR\m[]
manual page\&. This function can be used to dynamically extend (or shorten) the timeout for the current action\&. Thus it is possible to configure a restrictive timeout in
confd\&.conf, but still allow specific actions to have a longer execution time\&.
.PP
The function can be called either with a subscription socket during subscription delivery on that socket (including from the
\fBiter()\fR
function passed to
\fBcdb_diff_iterate()\fR), or with a data socket that has an active session\&. The timeout is given in seconds from the point in time when the function is called\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
The timeout for subscription delivery is common for all the subscribers receiving notifications at a given priority\&. Thus calling the function during subscription delivery changes the timeout for all the subscribers that are currently processing notifications\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_PROTOUSAGE, CONFD_ERR_BADSTATE
.nr wf \w'int\ cdb_exists('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_exists("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_exists(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Leafs in the data model may be optional, and presence containers and list entries may or may not exist\&. This function checks whether a node exists in CDB\&. Returns 0 for false, 1 for true and CONFD_ERR or CONFD_EOF for errors\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.nr wf \w'int\ cdb_cd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_cd("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_cd(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Changes the working directory according to the format path\&. Note that this function can not be used as an existence test\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.nr wf \w'int\ cdb_pushd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_pushd("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_pushd(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Similar to
\fBcdb_cd()\fR
but pushes the previous current directory on a stack\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSTACK, CONFD_ERR_BADPATH
.nr wf \w'int\ cdb_popd('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_popd("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_popd(int\ " "sock" ");" \}
.PP
Pops the top element from the directory stack and changes directory to previous directory\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOSTACK
.nr wf \w'int\ cdb_getcwd('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'size_t\ strsz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *curdir);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_getcwd("
.br
.BI "int\ " "sock" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_getcwd(int\ " "sock" ", size_t\ " "strsz" ", char\ *" "curdir" ");" \}
.PP
Returns the current position as previously set by
\fBcdb_cd()\fR,
\fBcdb_pushd()\fR, or
\fBcdb_popd()\fR
as a string path\&. Note that what is returned is a pretty\-printed version of the internal representation of the current position, it will be the shortest unique way to print the path but it might not exactly match the string given to
\fBcdb_cd()\fR\&. The buffer in *curdir will be NULL terminated, and no more characters than strsz\-1 will be written to it\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_getcwd_kpath('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **kp);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_getcwd_kpath("
.br
.BI "int\ " "sock" ", confd_hkeypath_t\ **" "kp" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_getcwd_kpath(int\ " "sock" ", confd_hkeypath_t\ **" "kp" ");" \}
.PP
Returns the current position like
\fBcdb_getcwd()\fR, but as a pointer to a hashed keypath instead of as a string\&. The hkeypath is dynamically allocated, and may further contain dynamically allocated elements\&. The caller must free the allocated memory, easiest done by calling
\fBconfd_free_hkeypath()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_num_instances('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_num_instances("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_num_instances(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Returns the number of entries in a list\&. On error CONFD_ERR or CONFD_EOF is returned\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.nr wf \w'int\ cdb_next_index('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_next_index("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_next_index(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Given a path to a list entry
\fBcdb_next_index()\fR
returns the position (starting from 0) of the next entry (regardless of whether the path exists or not)\&. When the list has multiple keys a
*
may be used for the last keys to make the path partially instantiated\&. For example if
/foo/bar
has three integer keys, the following pseudo code could be used to iterate over all entries with
42
as the first key:
.sp
.if n \{\
.RS 4
.\}
.nf
/* find the first entry of /foo/bar with 42 as first key */
ix = cdb_next_index(sock, "/foo/bar{42 * *}");
for (; ix>=0; ix++) {
    int32_t k1 = 0;
    cdb_get_int32(sock, &k1, "/foo/bar[%d]/key1", ix);
    if (k1 != 42) break;
    /* \&.\&.\&. do something with /foo/bar[%d] \&.\&.\&. */
}
.fi
.if n \{\
.RE
.\}
.PP
If there is no next entry \-1 is returned\&. It is not possible to use this function on an ordered\-by user list\&. On error CONFD_ERR or CONFD_EOF is returned\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.nr wf \w'int\ cdb_index('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_index("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_index(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Given a path to a list entry
\fBcdb_index()\fR
returns its position (starting from 0)\&. On error CONFD_ERR or CONFD_EOF is returned\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.nr wf \w'int\ cdb_is_default('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_is_default("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_is_default(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function returns 1 for a leaf which has a default value defined in the data model when no value has been set, i\&.e\&. when the default value is in effect\&. It returns 0 for other existing leafs, and CONFD_ERR or CONFD_EOF for errors\&. There is normally no need to call this function, since CDB automatically provides the default value as needed when cdb_get() etc is called\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_subscribe('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ priority,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nspace,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *spoint,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_subscribe("
.br
.BI "int\ " "sock" ", int\ " "priority" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_subscribe(int\ " "sock" ", int\ " "priority" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Sets up a CDB subscription so that we are notified when CDB configuration data changes\&. There can be multiple subscription points from different sources, that is a single client daemon can have many subscriptions and there can be many client daemons\&.
.PP
Each subscription point is defined through a path similar to the paths we use for read operations\&. We can subscribe either to specific leafs or entire subtrees\&. Subscribing to list entries can be done using fully qualified paths, or tagpaths to match multiple entries\&. A path which isn\*(Aqt a leaf element automatically matches the subtree below that path\&. When specifying keys to a list entry it is possible to use the wildcard character * which will match any key value\&.
.PP
When subscribing to a leaf with a
tailf:default\-ref
statement, or to a subtree with elements that have
tailf:default\-ref, implicit subscriptions to the referred leafs are added\&. This means that a change in a referred leaf will generate a notification for the subscription that has referring leaf(s) \- but currently such a change will not be reported by
\fBcdb_diff_iterate()\fR\&. Thus to get the new "effective" value of a referring leaf in this case, it is necessary to either read the value of the leaf with e\&.g\&.
\fBcdb_get()\fR
\- or to use a subscription that includes the referred leafs, and use
\fBcdb_diff_iterate()\fR
when a notification for that subscription is received\&.
.PP
Some examples
.PP
/hosts
.RS 4
Means that we subscribe to any changes in the subtree \- rooted at
/hosts\&. This includes additions or removals of
host
entries as well as changes to already existing
host
entries\&.
.RE
.PP
/hosts/host{www}/interfaces/interface{eth0}/ip
.RS 4
Means we are notified when host
www
changes its IP address on
eth0\&.
.RE
.PP
/hosts/host/interfaces/interface/ip
.RS 4
Means we are notified when any host changes any of its IP addresses\&.
.RE
.PP
/hosts/host/interfaces
.RS 4
Means we are notified when either an interface is added/removed or when an individual leaf element in an existing interface is changed\&.
.RE
.PP
The
\fIpriority\fR
value is an integer\&. When CDB is changed, the change is performed inside a transaction\&. Either a
\fBcommit\fR
operation from the CLI or a
\fBcandidate\-commit\fR
operation in NETCONF means that the running database is changed\&. These changes occur inside a ConfD transaction\&. CDB will handle the subscriptions in lock\-step priority order\&. First all subscribers at the lowest priority are handled, once they all have replied and synchronized through calls to
\fBcdb_sync_subscription_socket()\fR
the next set \- at the next priority level is handled by CDB\&. Priority numbers are global, i\&.e\&. if there are multiple client daemons notifications will still be delivered in priority order per all subscriptions, not per daemon\&.
.PP
See
\fBcdb_diff_iterate()\fR
and cdb_diff_match() for ways of filtering subscription notifications and finding out what changed\&. The easiest way is though to not use either of the two above mentioned diff function but to solely rely on the positioning of the subscription points in the tree to figure out what changed\&.
.PP
\fBcdb_subscribe()\fR
returns a
\fIsubscription point\fR
in the return parameter
\fIspoint\fR\&. This integer value is used to identify this particular subscription\&.
.PP
Because there can be many subscriptions on the same socket the client must notify ConfD when it is done subscribing and ready to receive notifications\&. This is done using
\fBcdb_subscribe_done()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_oper_subscribe('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nspace,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *spoint,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_oper_subscribe("
.br
.BI "int\ " "sock" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_oper_subscribe(int\ " "sock" ", int\ " "nspace" ", int\ *" "spoint" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Sets up a CDB subscription for changes in the operational data base\&. Similar to the subscriptions for configuration data, we can be notified of changes to the operational data stored in CDB\&. Note that there are several differences from the subscriptions for configuration data:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Notifications are only generated if the writer has taken a subscription lock, see
\fBcdb_start_session2()\fR
above\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Priorities are not used for these notifications\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
It is not possible to receive the previous value for modified leafs in
\fBcdb_diff_iterate()\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A special synchronization reply must be used when the notifications have been read (see
\fBcdb_sync_subscription_socket()\fR
below)\&.
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_subscribe2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sub_type\ type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ priority,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *spoint,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nspace,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_subscribe2("
.br
.BI "int\ " "sock" ", enum\ cdb_sub_type\ " "type" ", int\ " "flags" ", int\ " "priority" ", int\ *" "spoint" ", int\ " "nspace" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_subscribe2(int\ " "sock" ", enum\ cdb_sub_type\ " "type" ", int\ " "flags" ", int\ " "priority" ", int\ *" "spoint" ", int\ " "nspace" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function supersedes the current
\fBcdb_subscribe()\fR
and
\fBcdb_oper_subscribe()\fR
as well as makes it possible to use the new two phase subscription method\&. The
\fBcdb_sub_type\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
enum cdb_sub_type {
    CDB_SUB_RUNNING = 1,
    CDB_SUB_RUNNING_TWOPHASE = 2,
    CDB_SUB_OPERATIONAL = 3
};
.fi
.if n \{\
.RE
.\}
.PP
The CDB subscription type
\fBCDB_SUB_RUNNING\fR
is the same as
\fBcdb_subscribe()\fR,
\fBCDB_SUB_OPERATIONAL\fR
is the same as
\fBcdb_oper_subscribe()\fR, and
\fBCDB_SUB_RUNNING_TWOPHASE\fR
does a two phase subscription\&.
.PP
The flags argument should be set to 0, or a combination of:
.PP
\fBCDB_SUB_WANT_ABORT_ON_ABORT\fR
.RS 4
Normally if a subscriber is the one to abort a transaction it will not receive an abort notification\&. This flags means that this subscriber wants an abort notification even if it was the one that called cdb_sub_abort_trans()\&. This flag is only valid when the subscription type is
\fBCDB_SUB_RUNNING_TWOPHASE\fR\&.
.RE
.PP
The two phase subscriptions work like this: A subscriber uses
\fBcdb_subscribe2()\fR
with the type set to
\fBCDB_SUB_RUNNING_TWOPHASE\fR
to register as many subscription points as required\&. The
\fBcdb_subscribe_done()\fR
function is used to indicate that no more subscription points will be registered on that particular socket\&. Only after
\fBcdb_subscribe_done()\fR
is called will subscription notifications be delivered\&.
.PP
Once a transaction enters prepare state all CDB two phase subscribers will be notified in priority order (lowest priority first, subscribers with the same priority is delivered in parallel)\&. The
\fBcdb_read_subscription_socket2()\fR
function will set type to
\fBCDB_SUB_PREPARE\fR\&. Once all subscribers have acknowledged the notification by using the function
\fBcdb_sync_subscription_socket(CDB_DONE_PRIORITY)\fR
they will subsequently be notified when the transaction is committed\&. The
\fBCDB_SUB_COMMIT\fR
notification is the same as the current subscription mechanism, so when a transaction is committed all subscribers will be notified (again in priority order)\&.
.PP
When a transaction is aborted, delivery of any remaining
\fBCDB_SUB_PREPARE\fR
notifications is cancelled\&. The subscribers that had already been notified with
\fBCDB_SUB_PREPARE\fR
will be notified with
\fBCDB_SUB_ABORT\fR
(This notification will be done in reverse order of the
\fBCDB_SUB_PREPARE\fR
notification)\&. The transaction could be aborted because one of the subscribers that received
\fBCDB_SUB_PREPARE\fR
called
\fBcdb_sub_abort_trans()\fR, but it could also be caused for other reasons, for example another data provider (than CDB) can abort the transaction\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Two phase subscriptions are not supported for NCS\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_subscribe_done('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_subscribe_done("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_subscribe_done(int\ " "sock" ");" \}
.PP
When a client is done registering all its subscriptions on a particular subscription socket it must call
\fBcdb_subscribe_done()\fR\&. No notifications will be delivered until then\&.
.nr wf \w'int\ cdb_trigger_subscriptions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ len);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_trigger_subscriptions("
.br
.BI "int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_trigger_subscriptions(int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.PP
This function makes it possible to trigger CDB subscriptions for configuration data even though the configuration has not been modified\&. The caller will trigger all subscription points passed in the sub_points array (or all subscribers if the array is of zero length) in priority order, and the call will not return until the last subscriber has called cdb_sync_subscription_socket()\&.
.PP
The call is blocking and doesn\*(Aqt return until all subscribers have acknowledged the notification\&. That means that it is not possible to use
\fBcdb_trigger_subscriptions()\fR
in a cdb subscriber process (without forking a process or spawning a thread) since it would cause a deadlock\&.
.PP
The subscription notification generated by this "synthetic" trigger will seem like a regular subscription notification to a subscription client\&. As such, it is possible to use
\fBcdb_diff_iterate()\fR
to traverse the changeset\&. CDB will make up this changeset in which all leafs in the configuration will appear to be set, and all list entries and presence containers will appear as if they are created\&.
.PP
If the client is a two\-phase subscriber, a prepare notification will first be delivered and if any client aborts this synthetic transaction further delivery of subscription notification is suspended and an error is returned to the caller of
\fBcdb_trigger_subscriptions()\fR\&. The error is the result of mapping the CONFD_ERRCODE as set by the aborting client as described for MAAPI in the
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
section in the
\m[blue]\fBconfd_lib_lib(3)\fR\m[]
manpage\&. Note however that the configuration is still the way it is \- so it is up to the caller of
\fBcdb_trigger_subscriptions()\fR
to take appropriate action (for example: raising an alarm, restarting a subsystem, or even rebooting the system)\&.
.PP
If one or more subscription ids is passed in the subids array that are not valid, an error (\fBCONFD_ERR_PROTOUSAGE\fR) will be returned and no subscriptions will be triggered\&. If no subscription ids are passed this error can not occur (even if there aren\*(Aqt any subscribers)\&.
.nr wf \w'int\ cdb_trigger_oper_subscriptions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ len,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_trigger_oper_subscriptions("
.br
.BI "int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_trigger_oper_subscriptions(int\ " "sock" ", int\ " "sub_points[]" ", int\ " "len" ", int\ " "flags" ");" \}
.PP
This function works like
\fBcdb_trigger_subscriptions()\fR, but for CDB subscriptions to operational data\&. The caller will trigger all subscription points passed in the
\fIsub_points\fR
array (or all operational data subscribers if the array is of zero length), and the call will not return until the last subscriber has called cdb_sync_subscription_socket()\&.
.PP
Since the generation of subscription notifications for operational data requires that the subscription lock is taken (see
\fBcdb_start_session2()\fR), this function implicitly attempts to take a "global" subscription lock\&. If the subscription lock is already taken, the function will by default return CONFD_ERR with
\fIconfd_errno\fR
set to CONFD_ERR_LOCKED\&. To instead have it wait until the lock becomes available, CDB_LOCK_WAIT can be passed for the
\fIflags\fR
parameter\&.
.nr wf \w'int\ cdb_replay_subscriptions('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ cdb_txid\ *txid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ len);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_replay_subscriptions("
.br
.BI "int\ " "sock" ", struct\ cdb_txid\ *" "txid" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_replay_subscriptions(int\ " "sock" ", struct\ cdb_txid\ *" "txid" ", int\ " "sub_points[]" ", int\ " "len" ");" \}
.PP
This function makes it possible to replay the subscription events for the last configuration change to some or all CDB subscribers\&. This call is useful in a number of recovery scenarios, where some CDB subscribers lost connection to ConfD before having received all the changes in a transaction\&. The replay functionality is only available if it has been enabled in confd\&.conf
.PP
The caller specifies the transaction id of the last transaction that the application has completely seen and acted on\&. This verifies that the application has only missed (part of) the last transaction\&. If a different (older) transaction ID is specified, an error is returned and no subscriptions will be triggered\&. If the transaction id is the latest transaction ID (i\&.e\&. the caller is already up to date) nothing is triggered and CONFD_OK is returned\&.
.PP
By calling this function, the caller will potentially trigger all subscription points passed in the sub_points array (or all subscribers if the array is of zero length)\&. The subscriptions will be triggered in priority order, and the call will not return until the last subscriber has called cdb_sync_subscription_socket()\&.
.PP
The call is blocking and doesn\*(Aqt return until all subscribers have acknowledged the notification\&. That means that it is not possible to use
\fBcdb_replay_subscriptions()\fR
in a cdb subscriber process (without forking a process or spawning a thread) since it would cause a deadlock\&.
.PP
The subscription notification generated by this "synthetic" trigger will seem like a regular subscription notification to a subscription client\&. It is possible to use
\fBcdb_diff_iterate()\fR
to traverse the changeset\&.
.PP
If the client is a two\-phase subscriber, a prepare notification will first be delivered and if any client aborts this synthetic transaction further delivery of subscription notification is suspended and an error is returned to the caller of
\fBcdb_replay_subscriptions()\fR\&. The error is the result of mapping the CONFD_ERRCODE as set by the aborting client as described for MAAPI in the
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
section in the
\m[blue]\fBconfd_lib_lib(3)\fR\m[]
manpage\&.
.nr wf \w'int\ cdb_read_subscription_socket('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ sub_points[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *resultlen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_read_subscription_socket("
.br
.BI "int\ " "sock" ", int\ " "sub_points[]" ", int\ *" "resultlen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_read_subscription_socket(int\ " "sock" ", int\ " "sub_points[]" ", int\ *" "resultlen" ");" \}
.PP
The subscription socket \- which is acquired through a call to
\fBcdb_connect()\fR
\- must be part of the application poll set\&. Once the subscription socket has I/O ready to read, we must call
\fBcdb_read_subscription_socket()\fR
on the subscription socket\&.
.PP
The call will fill in the result in the array
\fIsub_points\fR
with a list of integer values containing
\fIsubscription points\fR
earlier acquired through calls to
\fBcdb_subscribe()\fR\&. The global variable
\fIcdb_active_subscriptions\fR
can be read to find how many active subscriptions the application has\&. Make sure the
sub_points[]
array is at least this big, otherwise the confd library will write in unallocated memory\&.
.PP
The subscription points may be either for configuration data or operational data (if
\fBcdb_oper_subscribe()\fR
has been used on the same socket), but they will all be of the same "type" \- i\&.e\&. a single call of the function will never deliver a mix of configuration and operational data subscription points\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_read_subscription_socket2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_sub_notification\ *type,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *subpoints[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *resultlen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_read_subscription_socket2("
.br
.BI "int\ " "sock" ", enum\ cdb_sub_notification\ *" "type" ", int\ *" "flags" ", int\ *" "subpoints[]" ", int\ *" "resultlen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_read_subscription_socket2(int\ " "sock" ", enum\ cdb_sub_notification\ *" "type" ", int\ *" "flags" ", int\ *" "subpoints[]" ", int\ *" "resultlen" ");" \}
.sp
.if n \{\
.RS 4
.\}
.nf
enum cdb_sub_notification {
    CDB_SUB_PREPARE = 1,
    CDB_SUB_COMMIT = 2,
    CDB_SUB_ABORT = 3,
    CDB_SUB_OPER = 4
};
.fi
.if n \{\
.RE
.\}
.PP
This is another version of the
\fBcdb_read_subscription_socket()\fR
with two important differences:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
In this version
\fIsubpoints is allocated by the library\fR, and it is up to the caller of this function to
\fBfree()\fR
it when it is done\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
It is possible to retrieve the type of the subscription notification via the
\fItype\fR
return parameter\&.
.RE
.PP
All parameters except
\fIsock\fR
are return parameters\&. It is legal to pass in
\fIflags\fR
and
\fItype\fR
as
\fBNULL\fR
pointers (in which case type and flags cannot be retrieved)\&.
\fIsubpoints\fR
is an array of integers, the length is indicated in
\fIresultlen\fR, it is allocated by the library, and
\fImust be freed by the caller\fR\&. The
\fItype\fR
parameter is what the subscriber uses to distinguish the different types of subscription notifications\&.
.PP
The
\fIflags\fR
return parameter can have the following bits set:
.PP
\fBCDB_SUB_FLAG_IS_LAST\fR
.RS 4
This bit is set when this notification is the last of its type for this subscription socket\&.
.RE
.PP
\fBCDB_SUB_FLAG_HA_IS_SLAVE\fR
.RS 4
This bit is set when
ConfD
runs in HA mode, and the current HA mode is slave\&. I\&.e\&. it is a convenient way for the subscriber to know wether this node is in slave mode or not\&.
.RE
.PP
\fBCDB_SUB_FLAG_TRIGGER\fR
.RS 4
This bit is set when the cause of the subscription notification is that someone called
\fBcdb_trigger_subscriptions()\fR\&.
.RE
.PP
\fBCDB_SUB_FLAG_REVERT\fR
.RS 4
If a confirming commit is aborted it will look to the CDB subscriber as if a transaction happened that is the reverse of what the original transaction was\&. This bit will be set when such a transaction is the cause of the notification\&. Note that for a two\-phase subscriber both a prepare and a commit notification is delivered\&. However it is not possible to reply by calling
\fBcdb_sub_abort_trans()\fR
for the prepare notification in this case, instead the subscriber will have to take appropriate backup action if it needs to abort (for example: raise an alarm, restart, or even reboot the system)\&.
.RE
.PP
\fBCDB_SUB_FLAG_HA_SYNC\fR
.RS 4
This bit is set when the cause of the subscription notification is initial synchronization of a HA slave from CDB on the master\&.
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_ret\ (*iter)(confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "subid" ", enum\ cdb_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_diff_iterate(int\ " "sock" ", int\ " "subid" ", enum\ cdb_iter_ret\ (*" "iter" ")(confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), int\ " "flags" ", void\ *" "initstate" ");" \}
.PP
After reading the subscription socket the
\fBcdb_diff_iterate()\fR
function can be used to iterate over the changes made in CDB data that matched the particular subscription point given by
\fIsubid\fR\&.
.PP
The user defined function
\fBiter()\fR
will be called for each element that has been modified and matches the subscription\&. The
\fBiter()\fR
callback receives the
\fIconfd_hkeypath_t kp\fR
which uniquely identifies which node in the data tree that is affected, the operation, and optionally the values it has before and after the transaction\&. The
\fIop\fR
parameter gives the modification as:
.PP
MOP_CREATED
.RS 4
The list entry,
presence
container, or leaf of type
empty
given by
\fIkp\fR
has been created\&.
.RE
.PP
MOP_DELETED
.RS 4
The list entry,
presence
container, or optional leaf given by
\fIkp\fR
has been deleted\&.
.sp
If the subscription was triggered because an ancestor was deleted, the
\fBiter()\fR
function will not called at all if the delete was above the subscription point\&. However if the flag ITER_WANT_ANCESTOR_DELETE is passed to
\fBcdb_diff_iterate()\fR
then deletes that trigger a descendant subscription will also generate a call to
\fBiter()\fR, and in this case
\fIkp\fR
will be the path that was actually deleted\&.
.RE
.PP
MOP_MODIFIED
.RS 4
A descendant of the list entry given by
\fIkp\fR
has been modified\&.
.RE
.PP
MOP_VALUE_SET
.RS 4
The value of the leaf given by
\fIkp\fR
has been set to
\fInewv\fR\&.
.RE
.PP
MOP_MOVED_AFTER
.RS 4
The list entry given by
\fIkp\fR, in an
ordered\-by user
list, has been moved\&. If
\fInewv\fR
is NULL, the entry has been moved first in the list, otherwise it has been moved after the entry given by
\fInewv\fR\&. In this case
\fInewv\fR
is a pointer to an array of key values identifying an entry in the list\&. The array is terminated with an element that has type C_NOEXISTS\&.
.RE
.PP
By setting the
\fIflags\fR
parameter ITER_WANT_REVERSE two\-phase subscribers may use this function to traverse the reverse changeset in case of CDB_SUB_ABORT notification\&. In this scenario a two\-phase subscriber traverses the changes in the prepare phase (CDB_SUB_PREPARE notification) and if the transaction is aborted the subscriber may iterate the inverse to the changes during the abort phase (CDB_SUB_PREPARE notification)\&.
.PP
For configuration subscriptions, the previous value of the node can also be passed to
\fBiter()\fR
if the
\fIflags\fR
parameter contains ITER_WANT_PREV, in which case
\fIoldv\fR
will be pointing to it (otherwise NULL)\&. For operational data subscriptions, the ITER_WANT_PREV flag is ignored, and
\fIoldv\fR
is always NULL \- there is no equivalent to CDB_PRE_COMMIT_RUNNING that holds "old" operational data\&.
.PP
If
\fBiter()\fR
returns ITER_STOP, no more iteration is done, and CONFD_OK is returned\&. If
\fBiter()\fR
returns ITER_RECURSE iteration continues with all children to the node\&. If
\fBiter()\fR
returns ITER_CONTINUE iteration ignores the children to the node (if any), and continues with the node\*(Aqs sibling, and if
\fBiter()\fR
returns ITER_UP the iteration is continued with the node\*(Aqs parents sibling\&. If, for some reason, the
\fBiter()\fR
function wants to return control to the caller of
\fBcdb_diff_iterate()\fR\fIbefore\fR
all the changes has been iterated over it can return ITER_SUSPEND\&. The caller then has to call
\fBcdb_diff_iterate_resume()\fR
to continue/finish the iteration\&.
.PP
The
\fIstate\fR
parameter can be used for any user supplied state (i\&.e\&. whatever is supplied as
\fIinitstate\fR
is passed as
\fIstate\fR
to
\fBiter()\fR
in each invocation)\&.
.PP
By default the traverse order is undefined but guaranteed to be the most efficient one\&. The traverse order may be changed by setting setting a bit in the
\fIflags\fR
parameter:
.PP
ITER_WANT_SCHEMA_ORDER
.RS 4
The
\fBiter()\fR
function will be invoked in
\fIschema\fR
order (i\&.e\&. in the order in which the elements are defined in the YANG file)\&.
.RE
.PP
ITER_WANT_LEAF_FIRST_ORDER
.RS 4
The
\fBiter()\fR
function will be invoked for leafs first, then non\-leafs\&.
.RE
.PP
ITER_WANT_LEAF_LAST_ORDER
.RS 4
The
\fBiter()\fR
function will be invoked for non\-leafs first, then leafs\&.
.RE
.PP
If the
\fIflags\fR
parameter ITER_WANT_LEAF_LIST_AS_LEAF is given, changes to leaf\-lists will cause invocations of
\fBiter()\fR
as for leafs and and not as for lists, e\&.g\&. with MOP_VALUE_SET rather than MOP_CREATED / MOP_DELETED\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This flag is deprecated, and only present for temporary backward compatibility \- it will be removed in a future release\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This flag is not supported when invoking
\fBcdb_diff_iterate()\fR
on a HA slave\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE, CONFD_ERR_PROTOUSAGE\&.
.nr wf \w'int\ cdb_diff_iterate_resume('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_ret\ reply,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_ret\ (*iter)(\ confd_hkeypath_t\ *kp,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_iter_op\ op,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *oldv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *newv,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *state),'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *resumestate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_diff_iterate_resume("
.br
.BI "int\ " "sock" ", enum\ cdb_iter_ret\ " "reply" ", enum\ cdb_iter_ret\ (*" "iter" ")(\ confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_diff_iterate_resume(int\ " "sock" ", enum\ cdb_iter_ret\ " "reply" ", enum\ cdb_iter_ret\ (*" "iter" ")(\ confd_hkeypath_t\ *" "kp" ", enum\ cdb_iter_op\ " "op" ", confd_value_t\ *" "oldv" ", confd_value_t\ *" "newv" ", void\ *" "state" "), void\ *" "resumestate" ");" \}
.PP
The application
\fImust\fR
call this function whenever an iterator function has returned
\fBITER_SUSPEND\fR
to finish up the iteration\&. If the application does not wish to continue iteration it must at least call
cdb_diff_iterate_resume(s, ITER_STOP, NULL, NULL);
to clean up the state\&. The
\fIreply\fR
parameter is what the iterator function would have returned (i\&.e\&. normally ITER_RECURSE or ITER_CONTINUE) if it hadn\*(Aqt returned ITER_SUSPEND\&. Note that it is up to the iterator function to somehow communicate that it has returned ITER_SUSPEND to the caller of
\fBcdb_diff_iterate()\fR, this can for example be a field in a struct for which a pointer to can passed back and forth in the
\fIstate\fR/\fIresumestate\fR
variable\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE\&.
.nr wf \w'int\ cdb_diff_match('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ xml_tag\ tags[],'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ tagslen);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_diff_match("
.br
.BI "int\ " "sock" ", int\ " "subid" ", struct\ xml_tag\ " "tags[]" ", int\ " "tagslen" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_diff_match(int\ " "sock" ", int\ " "subid" ", struct\ xml_tag\ " "tags[]" ", int\ " "tagslen" ");" \}
.PP
This function can be invoked when a subscription point has fired\&. Similar to the
\fBconfd_hkp_tagmatch()\fR
function it takes an argument which is an array of XML tags\&. The function will invoke
\fBcdb_diff_iterate()\fR
on a subscription socket\&. Using combinations of
\fBITER_STOP\fR,
\fBITER_CONTINUE\fR
and
\fBITER_RECURSE\fR
return values, the function checks a tagpath and decides whether any changes (under the subscription point) has occurred that also match the provided path
\fItags\fR\&. It is slightly easier to use this function than
\fBcdb_diff_iterate()\fR
but can also be slower since it is a general purpose matcher\&.
.PP
If we have a subscription point at
/root, we could invoke this function as:
.sp
.if n \{\
.RS 4
.\}
.nf
struct xml_tag tags[] = {{root_root, root__ns},
                         {root_servers, root__ns},
                         {root_server, root__ns}};
/* /root/servers/server */
int retv = cdb_diff_match(subsock, subpoint, tags, 3);
.fi
.if n \{\
.RE
.\}
.PP
The function returns 1 if there were any changes under
\fIsubpoint\fR
that matched
\fItags\fR, 0 if no match was found and
\fBCONFD_ERR\fR
on error\&.
.nr wf \w'int\ cdb_cli_diff_iterate('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'cli_diff_iter_function_t\ *iter,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'void\ *initstate);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_cli_diff_iterate("
.br
.BI "int\ " "sock" ", int\ " "subid" ", cli_diff_iter_function_t\ *" "iter" ", int\ " "flags" ", void\ *" "initstate" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_cli_diff_iterate(int\ " "sock" ", int\ " "subid" ", cli_diff_iter_function_t\ *" "iter" ", int\ " "flags" ", void\ *" "initstate" ");" \}
.PP
Where the
\fBcli_diff_iter_function_t\fR
is defined as:
.sp
.if n \{\
.RS 4
.\}
.nf
typedef enum cdb_iter_ret
    (cli_diff_iter_function_t)(confd_hkeypath_t *kp,
                               enum cdb_iter_op op,
                               confd_value_t *oldv,
                               confd_value_t *newv,
                               char *clistr,
                               int token_count,
                               struct confd_cli_token *tokens,
                               void *state);
.fi
.if n \{\
.RE
.\}
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function is DEPRECATED\&. Use cdb_get_modifications_cli() instead\&.
.sp .5v
.RE
.PP
The function
\fBcdb_cli_diff_iterate()\fR
works just like the
\fBcdb_diff_iterate()\fR
function, except the
\fBiter()\fR
function takes three additional parameters,
\fIclistr\fR,
\fItoken_count\fR, and
\fItokens\fR\&. The
\fIclistr\fR
is a string containing the (C\-style) rendering of the CLI commands equivalent to the current keypath/operation\&. The
\fItokens\fR
is actually an array of length
\fItoken_count\fR, it contains the CLI string broken down by token\&.
.PP
The string and the token array (including all the strings in the array) are allocated by the library, and will be freed by the library when the
\fIiter\fR
function returns\&.
.PP
If
\fIflags\fR
has the
\fBITER_WANT_SCHEMA_ORDER\fR
bit set, then the
\fBiter()\fR
function will be invoked in
\fIschema\fR
order (i\&.e\&. in the order in which the elements are defined in the YANG file)\&. Normally the order is undefined, which is most efficient\&.
.PP
Note that the cli commands are independent of whether the originating request actually came in over the CLI or some other northbound interface\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE\&.
.nr wf \w'int\ cdb_get_modifications('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_modifications("
.br
.BI "int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_modifications(int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
The
\fBcdb_get_modifications()\fR
function can be called after reception of a subscription notification to retrieve all the changes that caused the subscription notification\&. The socket
\fIs\fR
is the subscription socket, the subscription id must also be provided\&. Optionally a path can be used to limit what is returned further (only changes below the supplied path will be returned), if this isn\*(Aqt needed fmt can be set to
\fBNULL\fR\&.
.PP
When
\fBcdb_get_modifications()\fR
returns
\fBCONFD_OK\fR, the results are in
\fIvalues\fR, which is a tag value array with length
\fInvalues\fR\&. The library allocates memory for the results, which must be free:d by the caller\&. This can in all cases be done with code like this:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_tag_value_t *values;
int nvalues, i;

if (cdb_get_modifications(sock, subid, flags, &values, &nvalues,
                          "/some/path") == CONFD_OK) {
    \&.\&.\&.
    for (i = 0; i < nvalues; i++)
        confd_free_value(CONFD_GET_TAG_VALUE(&values[i]));
    free(values);
}
.fi
.if n \{\
.RE
.\}
.PP
The tag value array differs somewhat between how it is described in the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page, most notably only the values that were modified in this transaction are included\&. In addition to that these are the different values of the tags depending on what happened in the transaction:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A leaf of type empty that has been deleted has the value of
\fBC_NOEXISTS\fR, and when it is created it has the value
\fBC_XMLTAG\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A leaf or a leaf\-list that has been set to a new value (or its default value) is included with that new value\&. If the leaf or leaf\-list is optional, then when it is deleted the value is
\fBC_NOEXISTS\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Presence containers are included when they are created or when they have modifications below them (by the usual
\fBC_XMLBEGIN\fR,
\fBC_XMLEND\fR
pair)\&. If a presence container has been deleted its tag is included, but has the value
\fBC_NOEXISTS\fR\&.
.RE
.PP
By default
\fBcdb_get_modifications()\fR
does not include list instances (created, deleted, or modified) \- but if the
\fBCDB_GET_MODS_INCLUDE_LISTS\fR
flag is included in the
\fIflags\fR
parameter, list instances will be included\&. Created and modified instances are included wrapped in the
\fBC_XMLBEGIN\fR
/
\fBC_XMLEND\fR
pair, with the keys first\&. Deleted list instances instead begin with
\fBC_XMLBEGINDEL\fR, then follows the keys, immediately followed by a
\fBC_XMLEND\fR\&.
.PP
If the
\fBCDB_GET_MODS_SUPPRESS_DEFAULTS\fR
flag is included in the
\fIflags\fR
parameter, a default value that comes into effect for a leaf due to an ancestor list entry or presence container being created will not be included, and a default value that comes into effect for a leaf due to a set value being deleted will be included as a deletion (i\&.e\&. with value
\fBC_NOEXISTS\fR)\&.
.PP
When processing a
\fBCDB_SUB_ABORT\fR
notification for a two phase subscription, it is also possible to request a list of "reverse" modifications instead of the normal "forward" list\&. This is done by including the
\fBCDB_GET_MODS_REVERSE\fR
flag in the
\fIflags\fR
parameter\&.
.nr wf \w'int\ cdb_get_modifications_iter('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *nvalues);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_modifications_iter("
.br
.BI "int\ " "sock" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_modifications_iter(int\ " "sock" ", int\ " "flags" ", confd_tag_value_t\ **" "values" ", int\ *" "nvalues" ");" \}
.PP
The
\fBcdb_get_modifications_iter()\fR
is basically a convenient short\-hand of the
\fBcdb_get_modifications()\fR
function intended to be used from within a iteration function started by
\fBcdb_diff_iterate()\fR\&. In this case no subscription id is needed, and the path is implicitly the current position in the iteration\&.
.PP
Combining this call with
\fBcdb_diff_iterate()\fR
makes it for example possible to iterate over a list, and for each list instance fetch the changes using
\fBcdb_get_modifications_iter()\fR, and then return
\fBITER_CONTINUE\fR
to process next instance\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Note: The
\fBCDB_GET_MODS_REVERSE\fR
flag is ignored by
\fBcdb_get_modifications_iter()\fR\&. It will instead return a "forward" or "reverse" list of modifications for a
\fBCDB_SUB_ABORT\fR
notification according to whether the
\fBITER_WANT_REVERSE\fR
flag was included in the
\fIflags\fR
parameter of the
\fBcdb_diff_iterate()\fR
call\&.
.sp .5v
.RE
.nr wf \w'int\ cdb_get_modifications_cli('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ subid,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ **str);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_modifications_cli("
.br
.BI "int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", char\ **" "str" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_modifications_cli(int\ " "sock" ", int\ " "subid" ", int\ " "flags" ", char\ **" "str" ");" \}
.PP
The
\fBcdb_get_modifications_cli()\fR
function can be called after reception of a subscription notification to retrieve all the changes that caused the subscription notification as a string in Cisco CLI format\&. The socket
\fIs\fR
is the subscription socket, the subscription id must also be provided\&. The
\fIflags\fR
parameter is currently unused, and should be set to zero for future compatibility\&.
.PP
The CLI string is malloc(3)ed by the library, and the caller must free the memory using free(3) when it is not needed any longer\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_sync_subscription_socket('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ cdb_subscription_sync_type\ st);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sync_subscription_socket("
.br
.BI "int\ " "sock" ", enum\ cdb_subscription_sync_type\ " "st" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sync_subscription_socket(int\ " "sock" ", enum\ cdb_subscription_sync_type\ " "st" ");" \}
.PP
Once we have read the subscription notification through a call to
\fBcdb_read_subscription_socket()\fR
and optionally used the
\fBcdb_diff_iterate()\fR
to iterate through the changes as well as acted on the changes to CDB, we must synchronize with CDB so that CDB can continue and deliver further subscription messages to subscribers with higher priority numbers\&.
.PP
There are four different types of synchronization replies the application can use in the
\fBenum cdb_subscription_sync_type\fR
parameter:
.PP
\fBCDB_DONE_PRIORITY\fR
.RS 4
This means that the application has acted on the subscription notification and CDB can continue to deliver further notifications\&.
.RE
.PP
\fBCDB_DONE_SOCKET\fR
.RS 4
This means that we are done\&. But regardless of priority, CDB shall not send any further notifications to us on our socket that are related to the currently executing transaction\&.
.RE
.PP
\fBCDB_DONE_TRANSACTION\fR
.RS 4
This means that CDB should not send any further notifications to any subscribers \- including ourselves \- related to the currently executing transaction\&.
.RE
.PP
\fBCDB_DONE_OPERATIONAL\fR
.RS 4
This should be used when a subscription notification for operational data has been read\&. It is the only type that should be used in this case, since the operational data does not have transactions and the notifications do not have priorities\&.
.RE
.PP
When using two phase subscriptions and
\fBcdb_read_subscription_socket2()\fR
has returned the type as
\fBCDB_SUB_PREPARE\fR
or
\fBCDB_SUB_ABORT\fR
the only valid response is
\fBCDB_DONE_PRIORITY\fR\&.
.PP
For configuration data, the transaction that generated the subscription notifications is pending until all notifications have been acknowledged\&. A read lock on CDB is in effect while notifications are being delivered, preventing writes until delivery is complete\&.
.PP
For operational data, the writer that generated the subscription notifications is not directly affected, but the "subscription lock" remains in effect until all notifications have been acknowledged \- thus subsequent attempts to obtain a "global" subscription lock, or a subscription lock using CDB_LOCK_PARTIAL for a non\-disjuct subtree, will fail or block while notifications are being delivered (see
\fBcdb_start_session2()\fR
above)\&. Write operations that don\*(Aqt attempt to obtain the subscription lock will proceed independent of the delivery of subscription notifications\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_sub_progress('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sub_progress("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sub_progress(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
After receiving a subscription notification (using
\fBcdb_read_subscription_socket()\fR) but before acknowledging it (or aborting, in the case of prepare subscriptions), it is possible to send progress reports back to ConfD using the
\fBcdb_sub_progress()\fR
function\&. The socket
\fIsock\fR
must be the subscription socket, and it is allowed to call the function more than once to display more than one message\&. It is also possible to use this function in the diff\-iterate callback function\&. A newline at the end of the string isn\*(Aqt necessary\&.
.PP
Depending on which north\-bound interface that triggered the transaction, the string passed may be reported by that interface\&. Currently this is only presented in the CLI when the operator requests detailed reporting using the
\fBcommit | details\fR
command\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_sub_abort_trans('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sub_abort_trans("
.br
.BI "int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sub_abort_trans(int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function is to be called instead of
\fBcdb_sync_subscription_socket()\fR
when the subscriber wishes to abort the current transaction\&. It is only valid to call after
\fBcdb_read_subscription_socket2()\fR
has returned with type set to
\fBCDB_SUB_PREPARE\fR\&. The arguments after sock are the same as to
\fBconfd_X_seterr_extended()\fR
and give the caller a way of indicating the reason for the failure\&. Details can be found in the
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
section in the
\m[blue]\fBconfd_lib_lib(3)\fR\m[]
manpage\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_sub_abort_trans_info('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'enum\ confd_errcode\ code,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_ns,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ apptag_tag,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *error_info,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_sub_abort_trans_info("
.br
.BI "int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_sub_abort_trans_info(int\ " "sock" ", enum\ confd_errcode\ " "code" ", u_int32_t\ " "apptag_ns" ", u_int32_t\ " "apptag_tag" ", const\ confd_tag_value_t\ *" "error_info" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function does the same as
\fBcdb_sub_abort_trans()\fR, and additionally gives the possibility to provide contents for the NETCONF <error\-info> element\&. See the
\m[blue]\fBEXTENDED ERROR REPORTING\fR\m[]
section in the
\m[blue]\fBconfd_lib_lib(3)\fR\m[]
manpage\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS
.nr wf \w'int\ cdb_get_user_session('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_user_session("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_user_session(int\ " "sock" ");" \}
.PP
Returns the user session id for the transaction that triggered the current subscription notification\&. This function uses a subscription socket, and can only be called when a subscription notification for configuration data has been received on that socket, before
\fBcdb_sync_subscription_socket()\fR
has been called\&. Additionally, it is not possible to call this function from the
\fBiter()\fR
function passed to
\fBcdb_diff_iterate()\fR\&. To retrieve full information about the user session, use
\fBmaapi_get_user_session()\fR
(see
\m[blue]\fBconfd_lib_maapi(3)\fR\m[])\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Note: When the ConfD High Availability functionality is used, the user session information is not available on slave nodes\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADSTATE, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_get_transaction_handle('
.nr wm 0
.nr wp \w'int\ sock);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_transaction_handle("
.br
.BI "int\ " "sock" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_transaction_handle(int\ " "sock" ");" \}
.PP
Returns the transaction handle for the transaction that triggered the current subscription notification\&. This function uses a subscription socket, and can only be called when a subscription notification for configuration data has been received on that socket, before
\fBcdb_sync_subscription_socket()\fR
has been called\&. Additionally, it is not possible to call this function from the
\fBiter()\fR
function passed to
\fBcdb_diff_iterate()\fR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
A CDB client is not expected to access the ConfD transaction store directly \- this function should only be used for logging or debugging purposes\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
When the ConfD High Availability functionality is used, the transaction information is not available on slave nodes\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADSTATE, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_get('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get(int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
This function reads a value from the path in
\fIfmt\fR
and writes the result into the result parameter
\fBconfd_value_t\fR\&. The path must lead to a leaf element in the XML data tree\&. Note that for the C_BUF, C_BINARY, C_LIST, C_OBJECTREF, C_OID, C_QNAME, C_HEXSTR, and C_BITBIG
\fBconfd_value_t\fR
types, the buffer(s) pointed to are allocated using malloc(3) \- it is up to the user of this interface to free them using
\fBconfd_free_value()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_NOEXISTS, CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE
.PP
All the type safe versions of
\fBcdb_get()\fR
described below, as well as
\fBcdb_vget()\fR, also have the same possible Errors\&. When the type of the read value is wrong,
\fIconfd_errno\fR
is set to CONFD_ERR_BADTYPE and the function returns CONFD_ERR\&. The YANG type is given in the descriptions below\&.
.nr wf \w'int\ cdb_get_int8('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int8_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int8("
.br
.BI "int\ " "sock" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int8(int\ " "sock" ", int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBint8\fR
values\&.
.nr wf \w'int\ cdb_get_int16('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int16_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int16("
.br
.BI "int\ " "sock" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int16(int\ " "sock" ", int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBint16\fR
values\&.
.nr wf \w'int\ cdb_get_int32('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int32("
.br
.BI "int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int32(int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBint32\fR
values\&.
.nr wf \w'int\ cdb_get_int64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_int64("
.br
.BI "int\ " "sock" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_int64(int\ " "sock" ", int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBint64\fR
values\&.
.nr wf \w'int\ cdb_get_u_int8('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int8_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int8("
.br
.BI "int\ " "sock" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int8(int\ " "sock" ", u_int8_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBuint8\fR
values\&.
.nr wf \w'int\ cdb_get_u_int16('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int16_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int16("
.br
.BI "int\ " "sock" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int16(int\ " "sock" ", u_int16_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBuint16\fR
values\&.
.nr wf \w'int\ cdb_get_u_int32('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int32("
.br
.BI "int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int32(int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBuint32\fR
values\&.
.nr wf \w'int\ cdb_get_u_int64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_u_int64("
.br
.BI "int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_u_int64(int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBuint64\fR
values\&.
.nr wf \w'int\ cdb_get_bit32('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bit32("
.br
.BI "int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bit32(int\ " "sock" ", u_int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBbits\fR
values where the highest assigned bit position for the type is 31\&.
.nr wf \w'int\ cdb_get_bit64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'u_int64_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bit64("
.br
.BI "int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bit64(int\ " "sock" ", u_int64_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBbits\fR
values where the highest assigned bit position for the type is above 31 and below 64\&.
.nr wf \w'int\ cdb_get_bitbig('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bitbig("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bitbig(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBbits\fR
values where the highest assigned bit position for the type is above 63\&. Upon successful return
\fIrval\fR
is pointing to a buffer of size
\fIbufsiz\fR\&. It is up to the user of this function to free the buffer using free(3) when it is not needed any longer\&.
.nr wf \w'int\ cdb_get_ipv4('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ in_addr\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv4("
.br
.BI "int\ " "sock" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv4(int\ " "sock" ", struct\ in_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBinet:ipv4\-address\fR
values\&.
.nr wf \w'int\ cdb_get_ipv6('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ in6_addr\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv6("
.br
.BI "int\ " "sock" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv6(int\ " "sock" ", struct\ in6_addr\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBinet:ipv6\-address\fR
values\&.
.nr wf \w'int\ cdb_get_double('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'double\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_double("
.br
.BI "int\ " "sock" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_double(int\ " "sock" ", double\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBxs:float\fR
and
\fBxs:double\fR
values\&.
.nr wf \w'int\ cdb_get_bool('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_bool("
.br
.BI "int\ " "sock" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_bool(int\ " "sock" ", int\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBboolean\fR
values\&.
.nr wf \w'int\ cdb_get_datetime('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_datetime\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_datetime("
.br
.BI "int\ " "sock" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_datetime(int\ " "sock" ", struct\ confd_datetime\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBdate\-and\-time\fR
values\&.
.nr wf \w'int\ cdb_get_date('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_date\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_date("
.br
.BI "int\ " "sock" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_date(int\ " "sock" ", struct\ confd_date\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBxs:date\fR
values\&.
.nr wf \w'int\ cdb_get_time('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_time\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_time("
.br
.BI "int\ " "sock" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_time(int\ " "sock" ", struct\ confd_time\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBxs:time\fR
values\&.
.nr wf \w'int\ cdb_get_duration('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_duration\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_duration("
.br
.BI "int\ " "sock" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_duration(int\ " "sock" ", struct\ confd_duration\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBxs:duration\fR
values\&.
.nr wf \w'int\ cdb_get_enum_value('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int32_t\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_enum_value("
.br
.BI "int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_enum_value(int\ " "sock" ", int32_t\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read enumeration values\&. If we have:
.sp
.if n \{\
.RS 4
.\}
.nf
typedef unboundedType {
  type enumeration {
    enum unbounded;
    enum infinity;
  }
}
.fi
.if n \{\
.RE
.\}
.PP
The two enumeration values
\fBunbounded\fR
and
\fBinfinity\fR
will occur as two #define integers in the \&.h file which is generated from the YANG module\&. Thus this function
\fBcdb_get_enum_value()\fR
populates an unsigned integer pointer\&.
.nr wf \w'int\ cdb_get_objectref('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_hkeypath_t\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_objectref("
.br
.BI "int\ " "sock" ", confd_hkeypath_t\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_objectref(int\ " "sock" ", confd_hkeypath_t\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBinstance\-identifier\fR
values\&. Upon successful return
\fIrval\fR
is pointing to an allocated
\fBconfd_hkeypath_t\fR\&. It is up to the user of this function to free the hkeypath using
\fBconfd_free_hkeypath()\fR
when it is not needed any longer\&.
.nr wf \w'int\ cdb_get_oid('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_snmp_oid\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_oid("
.br
.BI "int\ " "sock" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_oid(int\ " "sock" ", struct\ confd_snmp_oid\ **" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBobject\-identifier\fR
values\&. Upon successful return
\fIrval\fR
is pointing to an allocated
\fBstruct confd_snmp_oid\fR\&. It is up to the user of this function to free the struct using free(3) when it is not needed any longer\&.
.nr wf \w'int\ cdb_get_buf('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_buf("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_buf(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBstring\fR
values\&. Upon successful return
\fIrval\fR
is pointing to a buffer of size
\fIbufsiz\fR\&. It is up to the user of this function to free the buffer using free(3) when it is not needed any longer\&.
.nr wf \w'int\ cdb_get_buf2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_buf2("
.br
.BI "int\ " "sock" ", unsigned\ char\ *" "rval" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_buf2(int\ " "sock" ", unsigned\ char\ *" "rval" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBstring\fR
values\&. If the buffer returned by
\fBcdb_get()\fR
fits into
\fI*n\fR
bytes CONFD_OK is returned and the buffer is copied into
\fI*rval\fR\&. Upon successful return
\fI*n\fR
is set to the number of bytes copied into
\fI*rval\fR\&.
.nr wf \w'int\ cdb_get_str('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'char\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_str("
.br
.BI "int\ " "sock" ", char\ *" "rval" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_str(int\ " "sock" ", char\ *" "rval" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBstring\fR
values\&. If the buffer returned by
\fBcdb_get()\fR
plus a terminating NUL fits into
\fIn\fR
bytes CONFD_OK is returned and the buffer is copied into
\fI*rval\fR
(as well as a terminating NUL character)\&.
.nr wf \w'int\ cdb_get_binary('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_binary("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_binary(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR, as
\fBcdb_get_buf()\fR
but for
\fBbinary\fR
values\&. Upon successful return
\fIrval\fR
is pointing to a buffer of size
\fIbufsiz\fR\&. It is up to the user of this function to free the buffer using free(3) when it is not needed any longer\&.
.nr wf \w'int\ cdb_get_hexstr('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *bufsiz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_hexstr("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_hexstr(int\ " "sock" ", unsigned\ char\ **" "rval" ", int\ *" "bufsiz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR, as
\fBcdb_get_buf()\fR
but for
\fByang:hex\-string\fR
values\&. Upon successful return
\fIrval\fR
is pointing to a buffer of size
\fIbufsiz\fR\&. It is up to the user of this function to free the buffer using free(3) when it is not needed any longer\&.
.nr wf \w'int\ cdb_get_qname('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **prefix,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *prefixsz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'unsigned\ char\ **name,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *namesz,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_qname("
.br
.BI "int\ " "sock" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_qname(int\ " "sock" ", unsigned\ char\ **" "prefix" ", int\ *" "prefixsz" ", unsigned\ char\ **" "name" ", int\ *" "namesz" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBxs:QName\fR
values\&. Note that
\fIprefixsz\fR
can be zero (in which case
\fI*prefix\fR
will be set to NULL)\&. The space for prefix and name is allocated using
\fBmalloc()\fR, it is up to the user of this function to free them when no longer in use\&.
.nr wf \w'int\ cdb_get_list('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ **values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ *n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_list("
.br
.BI "int\ " "sock" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_list(int\ " "sock" ", confd_value_t\ **" "values" ", int\ *" "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read values of a YANG
leaf\-list\&. The function will
\fBmalloc()\fR
an array of
\fBconfd_value_t\fR
elements for the list, and return a pointer to the array via the
\fI**values\fR
parameter and the length of the array via the
\fI*n\fR
parameter\&. The caller must free the memory for the values (see
\fBcdb_get()\fR) and the array itself\&. An example that reads and prints the elements of a list of strings:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_value_t *values;
int i, n;

cdb_get_list(sock, &values, &n, "/system/cards");
for (i = 0; i < n; i++) {
    printf("card %d: %s\en", i, CONFD_GET_BUFPTR(&values[i]));
    confd_free_value(&values[i]);
}
free(values);
.fi
.if n \{\
.RE
.\}
.nr wf \w'int\ cdb_get_ipv4prefix('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv4_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv4prefix("
.br
.BI "int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv4prefix(int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBinet:ipv4\-prefix\fR
values\&.
.nr wf \w'int\ cdb_get_ipv6prefix('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv6_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv6prefix("
.br
.BI "int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv6prefix(int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBinet:ipv6\-prefix\fR
values\&.
.nr wf \w'int\ cdb_get_decimal64('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_decimal64\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_decimal64("
.br
.BI "int\ " "sock" ", struct\ confd_decimal64\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_decimal64(int\ " "sock" ", struct\ confd_decimal64\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBdecimal64\fR
values\&.
.nr wf \w'int\ cdb_get_identityref('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_identityref\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_identityref("
.br
.BI "int\ " "sock" ", struct\ confd_identityref\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_identityref(int\ " "sock" ", struct\ confd_identityref\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBidentityref\fR
values\&.
.nr wf \w'int\ cdb_get_ipv4_and_plen('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv4_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv4_and_plen("
.br
.BI "int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv4_and_plen(int\ " "sock" ", struct\ confd_ipv4_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBtailf:ipv4\-address\-and\-prefix\-length\fR
values\&.
.nr wf \w'int\ cdb_get_ipv6_and_plen('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_ipv6_prefix\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_ipv6_and_plen("
.br
.BI "int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_ipv6_and_plen(int\ " "sock" ", struct\ confd_ipv6_prefix\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fBtailf:ipv6\-address\-and\-prefix\-length\fR
values\&.
.nr wf \w'int\ cdb_get_dquad('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'struct\ confd_dotted_quad\ *rval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_dquad("
.br
.BI "int\ " "sock" ", struct\ confd_dotted_quad\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_dquad(int\ " "sock" ", struct\ confd_dotted_quad\ *" "rval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Type safe variant of
\fBcdb_get()\fR
which is used to read
\fByang:dotted\-quad\fR
values\&.
.nr wf \w'int\ cdb_vget('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *v,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_vget("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_vget(int\ " "sock" ", confd_value_t\ *" "v" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.PP
This function does the same as
\fBcdb_get()\fR, but takes a single
\fBva_list\fR
argument instead of a variable number of arguments \- i\&.e\&. similar to
\fBvprintf()\fR\&. Corresponding
\fBva_list\fR
variants exist for all the functions that take a path as a variable number of arguments\&.
.nr wf \w'int\ cdb_get_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_object("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_object(int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
In some cases it can be motivated to read multiple values in one request \- this will be more efficient since it only incurs a single round trip to ConfD, but usage is a bit more complex\&. This function reads at most
\fIn\fR
values from the container or list entry specified by the path, and places them in the
\fIvalues\fR
array, which is provided by the caller\&. The array is populated according to the specification of the
\fIValue Array\fR
format in the
\fIXML STRUCTURES\fR
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
When reading from a container or list entry with mixed configuration and operational data (i\&.e\&. a config container or list entry that has some number of operational elements), some elements will have the "wrong" type \- i\&.e\&. operational data in a session for CDB_RUNNING/CDB_STARTUP, or config data in a session for CDB_OPERATIONAL\&. Leaf elements of the "wrong" type will have a "value" of C_NOEXISTS in the array, while static or (existing) optional sub\-container elements will have C_XMLTAG in all cases\&. Sub\-containers or leafs provided by external data providers will always be represented with C_NOEXISTS, whether config or not\&.
.PP
On success, the function returns the actual number of elements in the container or list entry\&. I\&.e\&. if the return value is bigger than
\fIn\fR, only the values for the first
\fIn\fR
elements are in the array, and the remaining values have been discarded\&. Note that given the specification of the array contents, there is always a fixed upper bound on the number of actual elements, and if there are no presence sub\-containers, the number is constant\&.
.PP
As an example, with the YANG fragment in the
\m[blue]\fBPATHS\fR\m[]
section above, this code could be used to read the values for interface "eth0" on host "buzz":
.sp
.if n \{\
.RS 4
.\}
.nf
char *path = "/hosts/host{buzz}/interfaces/interface{%s}";
confd_value_t v[4];
struct in_addr ip, mask;
int enabled;

cdb_get_object(sock, v, 4, path, "eth0");
/* v[0] is interface name, already known
   \- must be freed since it\*(Aqs a C_BUF   */
confd_free_value(&v[0]);
ip = CONFD_GET_IPV4(&v[1]);
mask = CONFD_GET_IPV4(&v[2]);
enabled = CONFD_GET_BOOL(&v[3]);
.fi
.if n \{\
.RE
.\}
.PP
In this simple example, we assumed that the application was aware of the details of the data model, specifically that a
\fBconfd_value_t\fR
array of length 4 would be sufficient for the values we wanted to retrieve, and at which positions in the array those values could be found\&. If we make use of schema information loaded from the ConfD daemon into the library (see
\m[blue]\fBconfd_types(3)\fR\m[]), we can avoid "hardwiring" these details\&. The following, more complex, example does the same as the above, but using only the names (in the form of #defines from the header file generated by
\fBconfdc \-\-emit\-h\fR) of the relevant leafs:
.sp
.if n \{\
.RS 4
.\}
.nf
char *path = "/hosts/host{buzz}/interfaces/interface{%s}";
struct confd_cs_node *object = confd_cs_node_cd(NULL, path);
struct confd_cs_node *cur;
int n = confd_max_object_size(object);
int i;
confd_value_t v[n];
struct in_addr ip, mask;
int enabled;

cdb_get_object(sock, v, n, path, "eth0");
for (cur = object\->children, i = 0;
     cur != NULL;
     cur = confd_next_object_node(object, cur, &v[i]), i++) {
    switch (cur\->tag) {
    case hst_ip:
        ip = CONFD_GET_IPV4(&v[i]);
        break;
    case hst_mask:
        mask = CONFD_GET_IPV4(&v[i]);
        break;
    case hst_enabled:
        enabled = CONFD_GET_BOOL(&v[i]);
        break;
    }
    /* always free \- it is a no\-op if not needed */
    confd_free_value(&v[i]);
}
.fi
.if n \{\
.RE
.\}
.PP
See
\m[blue]\fBconfd_lib_lib(3)\fR\m[]
for the specification of the
\fBconfd_max_object_size()\fR
and
\fBconfd_next_object_node()\fR
functions\&. Also worth noting is that the return value from
\fBconfd_max_object_size()\fR
is a constant for a given node in a given data model \- thus we could optimize the above by calling
\fBconfd_max_object_size()\fR
only at the first invocation of
\fBcdb_get_object()\fR
for a given node, making use of the
\fIopaque\fR
element of
\fBstruct confd_cs_node\fR
to store the value:
.sp
.if n \{\
.RS 4
.\}
.nf
char *path = "/hosts/host{buzz}/interfaces/interface{%s}";
struct confd_cs_node *object = confd_cs_node_cd(NULL, path);
int n;
struct in_addr ip, mask;
int enabled;

if (object\->opaque == NULL) {
    n = confd_max_object_size(object);
    object\->opaque = (void *)n;
} else {
    n = (int)object\->opaque;
}

{
    struct confd_cs_node *cur;
    confd_value_t v[n];
    int i;

    cdb_get_object(sock, v, n, path, "eth0");
    for (cur = object\->children, i = 0;
         cur != NULL;
         cur = confd_next_object_node(object, cur, &v[i]), i++) {
        \&.\&.\&.
    }
}
.fi
.if n \{\
.RE
.\}
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH
.nr wf \w'int\ cdb_get_objects('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ ix,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ nobj,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_objects("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ " "ix" ", int\ " "nobj" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_objects(int\ " "sock" ", confd_value_t\ *" "values" ", int\ " "n" ", int\ " "ix" ", int\ " "nobj" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Similar to
\fBcdb_get_object()\fR, but reads multiple entries of a list based on the "instance integer" otherwise given within square brackets in the path \- here the path must specify the list without the instance integer\&. At most
\fIn\fR
values from each of
\fInobj\fR
entries, starting at entry
\fIix\fR, are read and placed in the
\fIvalues\fR
array\&.
.PP
The array must be at least
n * nobj
elements long, and the values for list entry
ix + i
start at element
array[i * n]
(i\&.e\&.
ix
starts at
array[0],
ix+1
at
array[n], and so on)\&. On success, the highest actual number of values in any of the list entries read is returned\&. An error (CONFD_ERR_NOEXISTS) will be returned if we attempt to read more entries than actually exist (i\&.e\&. if
ix + nobj \- 1
is outside the range of actually existing list entries)\&. Example \- read the data for all interfaces on the host "buzz" (assuming that we have memory enough for that):
.sp
.if n \{\
.RS 4
.\}
.nf
char *path = "/hosts/host{buzz}/interfaces/interface";
int n;

n = cdb_num_instances(sock, path);
{
    confd_value_t v[n*4];
    char name[n][64];
    struct in_addr ip[n], mask[n];
    int enabled[n];
    int i;

    cdb_get_objects(sock, v, 4, 0, n, path);
    for (i = 0; i < n*4; i += 4) {
        confd_pp_value(&name[i][0], 64, &v[i]);
        /* value must be freed since it\*(Aqs a C_BUF */
        confd_free_value(&v[i]);
        ip[i] = CONFD_GET_IPV4(&v[i+1]);
        mask[i] = CONFD_GET_IPV4(&v[i+2]);
        enabled[i] = CONFD_GET_BOOL(&v[i+3]);
    }

    /* configure interfaces\&.\&.\&. */
}
.fi
.if n \{\
.RE
.\}
.PP
This simple example can of course be enhanced to use loaded schema information in a similar manner as for
\fBcdb_get_object()\fR
above\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_get_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_values("
.br
.BI "int\ " "sock" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_values(int\ " "sock" ", confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Read an arbitrary set of sub\-elements of a container or list entry\&. The
\fIvalues\fR
array must be pre\-populated with
\fIn\fR
values based on the specification of the
\fITagged Value Array\fR
format in the
\fIXML STRUCTURES\fR
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page, where the
\fBconfd_value_t\fR
value element is given as follows:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C_NOEXISTS means that the value should be read from CDB and stored in the array\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C_PTR also means that the value should be read from CDB, but instead gives the expected type and a pointer to the type\-specific variable where the value should be stored\&. Thus this gives a functionality similar to the type safe versions of
\fBcdb_get()\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C_XMLBEGIN and C_XMLEND are used as per the specification\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Key values to select list entries can be given with their values\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
As a special case, the "instance integer" can be used to select a list entry by using C_CDBBEGIN instead of C_XMLBEGIN (and no key values)\&.
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
When we use C_PTR, we need to take special care to free any allocated memory\&. When we use C_NOEXISTS and the value is stored in the array, we can just use
\fBconfd_free_value()\fR
regardless of the type, since the
\fBconfd_value_t\fR
has the type information\&. But with C_PTR, only the actual value is stored in the pointed\-to variable, just as for
\fBcdb_get_buf()\fR,
\fBcdb_get_binary()\fR, etc, and we need to free the memory specifically allocated for the types listed in the description of
\fBcdb_get()\fR
above\&. See the corresponding
\fBcdb_get_xxx()\fR
functions for the details of how to do this\&.
.sp .5v
.RE
.PP
All elements have the same position in the array after the call, in order to simplify extraction of the values \- this means that optional elements that were requested but didn\*(Aqt exist will have C_NOEXISTS rather than being omitted from the array\&. However requesting a list entry that doesn\*(Aqt exist, or requesting non\-CDB data, or operational vs config data, is an error\&. Note that when using C_PTR, the only indication of a non\-existing value is that the destination variable has not been modified \- it\*(Aqs up to the application to set it to some "impossible" value before the call when optional leafs are read\&.
.PP
In this rather complex example we first read only the "name" and "enabled" values for all interfaces, and then read "ip" and "mask" for those that were enabled \- a total of two requests\&. Note that since the "interface" list begin/end elements are in the array, the path must not include the "interface" component\&. When reading values from a single container, it is generally simpler to have the container component (and keys or instance integer) in the path instead\&.
.sp
.if n \{\
.RS 4
.\}
.nf
char *path = "/hosts/host{buzz}/interfaces";
int n = cdb_num_instances(sock, "%s/interface", path);
{
  /* when reading ip/mask, we need 5 elements per interface:
     begin + name (key) + ip + mask + end                    */
  confd_tag_value_t tv[n*5];
  char name[n][64];
  struct in_addr ip[n], mask[n];
  int i, j;
  int n_if;

  /* read name and enabled for all interfaces */
  j = 0;
  for (i = 0; i < n; i++) {
    CONFD_SET_TAG_CDBBEGIN(&tv[j], hst_interface, hst__ns, i); j++;
    CONFD_SET_TAG_NOEXISTS(&tv[j], hst_name);                  j++;
    CONFD_SET_TAG_NOEXISTS(&tv[j], hst_enabled);               j++;
    CONFD_SET_TAG_XMLEND(&tv[j], hst_interface, hst__ns);      j++;
  }
  cdb_get_values(sock, tv, j, path);

  /* extract name for enabled interfaces */
  j = 0;
  for (i = 0; i < n*4; i += 4) {
    int enabled = CONFD_GET_BOOL(CONFD_GET_TAG_VALUE(&tv[i+2]));
    confd_value_t *v = CONFD_GET_TAG_VALUE(&tv[i+1]);
    if (enabled) {
      confd_pp_value(&name[j][0], 64, v);
      j++;
    }
    /* name must be freed regardless since it\*(Aqs a C_BUF */
    confd_free_value(v);
  }
  n_if = j;

  /* read ip and mask for enabled interfaces by key value (name) */
  j = 0;
  for (i = 0; i < n_if; i++) {
    CONFD_SET_TAG_XMLBEGIN(&tv[j], hst_interface, hst__ns);    j++;
    CONFD_SET_TAG_STR(&tv[j], hst_name, &name[i][0]);          j++;
    CONFD_SET_TAG_PTR(&tv[j], hst_ip, C_IPV4, &ip[i]);         j++;
    CONFD_SET_TAG_PTR(&tv[j], hst_mask, C_IPV4, &mask[i]);     j++;
    CONFD_SET_TAG_XMLEND(&tv[j], hst_interface, hst__ns);      j++;
  }
  cdb_get_values(sock, tv, j, path);

  for (i = 0; i < n_if; i++) {
    /* configure interface i with ip[i] and mask[i]\&.\&.\&. */
  }
}
.fi
.if n \{\
.RE
.\}
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_get_case('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *rcase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_get_case("
.br
.BI "int\ " "sock" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_get_case(int\ " "sock" ", const\ char\ *" "choice" ", confd_value_t\ *" "rcase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
When we use the YANG
choice
statement in the data model, this function can be used to find the currently selected
case, avoiding useless
\fBcdb_get()\fR
etc requests for elements that belong to other cases\&. The
\fIfmt, \&.\&.\&.\fR
arguments give the path to the container or list entry where the choice is defined, and
\fIchoice\fR
is the name of the choice\&. The case value is returned to the
\fBconfd_value_t\fR
that
\fIrcase\fR
points to, as type C_XMLTAG \- i\&.e\&. we can use the
\fBCONFD_GET_XMLTAG()\fR
macro to retrieve the hashed tag value\&. If no case is currently selected (i\&.e\&. for an optional choice that doesn\*(Aqt have a default case), the function will fail with CONFD_ERR_NOEXISTS\&.
.PP
If we have "nested" choices, i\&.e\&. multiple levels of
choice
statements without intervening
container
or
list
statements in the data model, the
\fIchoice\fR
argument must give a \*(Aq/\*(Aq\-separated path with alternating choice and case names, from the data node given by the
\fIfmt, \&.\&.\&.\fR
arguments to the specific choice that the request pertains to\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS
.SH "OPERATIONAL DATA"
.PP
It is possible for an application to store operational data (i\&.e\&. status and statistical information) in CDB, instead of providing it on demand via the callback interfaces described in the
\m[blue]\fBconfd_lib_dp(3)\fR\m[]
manual page\&. The operational database has no transactions and normally avoids the use of locks in order to provide light\-weight access methods, however when the multi\-value API functions below are used, all updates requested by a given function call are carried out atomically\&. Read about how to specify the storage of operational data in CDB via the
tailf:cdb\-oper
extension in the
\m[blue]\fBtailf_yang_extensions(5)\fR\m[]
manual page\&.
.PP
To establish a session for operational data, the application needs to use
\fBcdb_connect()\fR
with CDB_DATA_SOCKET and
\fBcdb_start_session()\fR
with CDB_OPERATIONAL\&. After this, all the read and access functions above are available for use with operational data, and additionally the write functions described below\&. Configuration data can not be accessed in a session for operational data, nor vice versa \- however it is possible to have both types of sessions active simultaneously on two different sockets, or to alternate the use of one socket via
\fBcdb_end_session()\fR\&. The write functions can never be used in a session for configuration data\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
In order to trigger subscriptions on operational data, we must obtain a subscription lock via the use of
\fBcdb_start_session2()\fR
instead of
\fBcdb_start_session()\fR, see above\&.
.sp .5v
.RE
.PP
In YANG it is possible to define a list of operational data without any keys\&. For this type of list, we use a single "pseudo" key which is always of type C_INT64 \- see the
\m[blue]\fBOperational Data chapter in the User Guide\fR\m[]\&. This key isn\*(Aqt visible in the northbound agent interfaces, but is used in the functions described here just as if it was a "normal" key\&.
.nr wf \w'int\ cdb_set_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *val,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_elem("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_elem(int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.nr wf \w'int\ cdb_set_elem2('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *strval,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_elem2("
.br
.BI "int\ " "sock" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_elem2(int\ " "sock" ", const\ char\ *" "strval" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
There are two different functions to set the value of a single leaf\&. The first takes the value from a
\fBconfd_value_t\fR
struct, the second takes the string representation of the value\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ cdb_vset_elem('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'confd_value_t\ *val,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'va_list\ args);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_vset_elem("
.br
.BI "int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_vset_elem(int\ " "sock" ", confd_value_t\ *" "val" ", const\ char\ *" "fmt" ", va_list\ " "args" ");" \}
.PP
This function does the same as
\fBcdb_set_elem()\fR, but takes a single
\fBva_list\fR
argument instead of a variable number of arguments \- i\&.e\&. similar to
\fBvprintf()\fR\&. Corresponding
\fBva_list\fR
variants exist for all the functions that take a path as a variable number of arguments\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ cdb_create('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_create("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_create(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Create a new list entry, presence container, or leaf of type
empty\&. Note that for list entries and containers, sub\-elements will not exist until created or set via some of the other functions, thus doing implicit create via
\fBcdb_set_object()\fR
or
\fBcdb_set_values()\fR
may be preferred in this case\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOTCREATABLE, CONFD_ERR_ALREADY_EXISTS
.nr wf \w'int\ cdb_delete('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_delete("
.br
.BI "int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_delete(int\ " "sock" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Delete a list entry, presence container, or leaf of type
empty, and all its child elements (if any)\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOTDELETABLE, CONFD_ERR_NOEXISTS
.nr wf \w'int\ cdb_set_object('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_object("
.br
.BI "int\ " "sock" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_object(int\ " "sock" ", const\ confd_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Set all elements corresponding to the complete contents of a container or list entry, except for sub\-lists\&. The
\fIvalues\fR
array must be populated with
\fIn\fR
values according to the specification of the
\fIValue Array\fR
format in the
\fIXML STRUCTURES\fR
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
If the container or list entry itself, or any sub\-elements that are specified as existing, do not exist before this call, they will be created, otherwise the existing values will be updated\&. Non\-mandatory leafs and presence containers that are specified as not existing in the array, i\&.e\&. with value C_NOEXISTS, will be deleted if they existed before the call\&.
.PP
When writing to a container with mixed configuration and operational data (i\&.e\&. a config container or list entry that has some number of operational elements), all config leaf elements must be specified as C_NOEXISTS in the corresponding array elements, while config sub\-container elements are specified with C_XMLTAG just as for operational data\&.
.PP
For a list entry, since the key elements must be present in the array, it is not required that the key values are included in the path given by
\fIfmt\fR\&. If the key values
\fIare\fR
included in the path, the values of the key elements in the array are ignored\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ cdb_set_values('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ confd_tag_value_t\ *values,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ n,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_values("
.br
.BI "int\ " "sock" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_values(int\ " "sock" ", const\ confd_tag_value_t\ *" "values" ", int\ " "n" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
Set arbitrary sub\-elements of a container or list entry\&. The
\fIvalues\fR
array must be populated with
\fIn\fR
values according to the specification of the
\fITagged Value Array\fR
format in the
\fIXML STRUCTURES\fR
section of the
\m[blue]\fBconfd_types(3)\fR\m[]
manual page\&.
.PP
If the container or list entry itself, or any sub\-elements that are specified as existing, do not exist before this call, they will be created, otherwise the existing values will be updated\&. Both mandatory and optional elements may be omitted from the array, and all omitted elements are left unchanged\&. To actually delete a non\-mandatory leaf or presence container as described for
\fBcdb_set_object()\fR, it may (as an extension of the format) be specified as C_NOEXISTS instead of being omitted\&.
.PP
For a list entry, the key values can be specified either in the path or via key elements in the array \- if the values are in the path, the key elements can be omitted from the array\&. For sub\-lists present in the array, the key elements must of course always also be present though, immediately following the C_XMLBEGIN element and in the order defined by the data model\&. It is also possible to delete a list entry by using a C_XMLBEGINDEL element, followed by the keys in data model order, followed by a C_XMLEND element\&.
.PP
For a list without keys (see above), the "pseudo" key may (or in some cases must) be present in the array, but of course there is no tag value for it, since it isn\*(Aqt present in the data model\&. In this case we must use a tag value of 0, i\&.e\&. it can be set with code like:
.sp
.if n \{\
.RS 4
.\}
.nf
confd_tag_value_t tv[7];

CONFD_SET_TAG_INT64(&tv[1], 0, 42);
.fi
.if n \{\
.RE
.\}
.PP
The same method is used when reading data from such a list with the
\fBcdb_get_values()\fR
function described above\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOT_WRITABLE
.nr wf \w'int\ cdb_set_case('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *choice,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *scase,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *fmt,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'\&.\&.\&.);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_set_case("
.br
.BI "int\ " "sock" ", const\ char\ *" "choice" ", const\ char\ *" "scase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.el \{\
.HP \n(wfu
.BI "int cdb_set_case(int\ " "sock" ", const\ char\ *" "choice" ", const\ char\ *" "scase" ", const\ char\ *" "fmt" ", \&.\&.\&.);" \}
.PP
When we use the YANG
choice
statement in the data model, this function can be used to select the current
case\&. When configuration data is modified by northbound agents, the current case is implicitly selected (and elements for other cases potentially deleted) by the setting of elements in a choice\&. For operational data in CDB however, this is under direct control of the application, which needs to explicitly set the current case\&. Setting the case will also automatically delete elements belonging to other cases, but it is up to the application to not set any elements in the "wrong" case\&.
.PP
The
\fIfmt, \&.\&.\&.\fR
arguments give the path to the container or list entry where the choice is defined, and
\fIchoice\fR
and
\fIscase\fR
are the choice and case names\&. For an optional choice, it is possible to have no case at all selected\&. To indicate that the previously selected case should be deleted without selecting another case, we can pass NULL for the
\fIscase\fR
argument\&.
.PP
If we have "nested" choices, i\&.e\&. multiple levels of
choice
statements without intervening
container
or
list
statements in the data model, the
\fIchoice\fR
argument must give a \*(Aq/\*(Aq\-separated path with alternating choice and case names, from the data node given by the
\fIfmt, \&.\&.\&.\fR
arguments to the specific choice that the request pertains to\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH, CONFD_ERR_NOTDELETABLE
.nr wf \w'int\ cdb_load_file('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *filename,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_load_file("
.br
.BI "int\ " "sock" ", const\ char\ *" "filename" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_load_file(int\ " "sock" ", const\ char\ *" "filename" ", int\ " "flags" ");" \}
.PP
Load operational data from
\fIfilename\fR
into CDB operational\&. The file must be in xml format, and
\fIsock\fR
must be connected to CDB operational (i\&.e\&.
\fBcdb_start_session()\fR
or
\fBcdb_start_session2()\fR
must have been called with CDB_OPERATIONAL)\&. If the file contains config data, or operational data not residing in CDB, that data will be silently ignored\&. If the name of the file ends in \&.gz (or \&.Z) then the file is assumed to be gzipped, and will be uncompressed as it is loaded\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
If you use a relative pathname for
\fIfilename\fR, it is taken as relative to the working directory of the ConfD daemon, i\&.e\&. the directory where the daemon was started\&.
.sp .5v
.RE
.PP
Note that there are no transactions in CDB operational, so there will not be any validation or transactional commit of the file\&. However the file will be completely parsed before CDB tries to set the values, with the result that any errors in the file will abort the operation without changing anything in CDB operational\&.
.PP
The flags parameter is currently not used, and should be set to 0\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
This function is DEPRECATED\&. Use
\fBmaapi_load_config()\fR
instead\&.
.sp .5v
.RE
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_BADPATH, CONFD_ERR_EXTERNAL
.nr wf \w'int\ cdb_load_str('
.nr wm 0
.nr wp \w'int\ sock,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'const\ char\ *xml_str,'
.if \n(wp>\n(wm 'nr wm \n(wp
.nr wp \w'int\ flags);'
.if \n(wp>\n(wm 'nr wm \n(wp
.ie \n(IN+\n(wf+\n(wm-\n(LL \{\
.HP \n(LLu-\n(INu-\n(wmu
.BI "int cdb_load_str("
.br
.BI "int\ " "sock" ", const\ char\ *" "xml_str" ", int\ " "flags" ");" \}
.el \{\
.HP \n(wfu
.BI "int cdb_load_str(int\ " "sock" ", const\ char\ *" "xml_str" ", int\ " "flags" ");" \}
.PP
Load operational data from the string
\fIxml_str\fR
into CDB operational\&. I\&.e\&. instead of having the xml data read from a file as for
\fBcdb_load_file()\fR, it is passed as a string to the function\&. Besides this, the function works the same as
\fBcdb_load_file()\fR\&.
.PP
\fIErrors\fR: CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_EXTERNAL
.SH "SEE ALSO"
.PP
\fBconfd_lib\fR(3)
\- Confd lib
.PP
\fBconfd_types\fR(3)
\- ConfD C data types
.PP
The ConfD User Guide
.SH "AUTHOR"
.PP
 <\&support@tail\-f\&.com\&>
.RS 4
.RE
.SH "COPYRIGHT"
.br
Copyright \(co 2018 Tail-f Systems AB
.br
