/*
 * This module has been generated by smidump 0.4.8:
 *
 *      smidump -f yang IP-MIB
 *
 * Do not edit. Edit the source file instead!
 */

module IP-MIB {

  /*** NAMESPACE / PREFIX DEFINITION ***/

  namespace "urn:ietf:params:xml:ns:yang:smiv2:IP-MIB";
  prefix "ip-mib";

  /*** LINKAGE (IMPORTS / INCLUDES) ***/

  import IF-MIB           { prefix "if-mib"; }
  import INET-ADDRESS-MIB { prefix "inet-address"; }
  import SNMPv2-TC        { prefix "smiv2"; }
  import ietf-yang-types  { prefix "yang"; }

  import tailf-common { prefix tailf; }

  /*** META INFORMATION ***/

  organization
   "IETF IPv6 MIB Revision Team";

  contact
   "Editor:
    Shawn A. Routhier
    Interworking Labs
    108 Whispering Pines Dr. Suite 235
    Scotts Valley, CA 95066
    USA
    EMail: <sar@iwl.com>";

  description
   "The MIB module for managing IP and ICMP implementations, but
    excluding their management of IP routes.

    Copyright (C) The Internet Society (2006).  This version of
    this MIB module is part of RFC 4293; see the RFC itself for
    full legal notices.";

  revision "2006-02-02" {
    description
     "The IP version neutral revision with added IPv6 objects for
      ND, default routers, and router advertisements.  As well as
      being the successor to RFC 2011, this MIB is also the
      successor to RFCs 2465 and 2466.  Published as RFC 4293.";
  }
  revision "1994-11-01" {
    description
     "A separate MIB module (IP-MIB) for IP and ICMP management
      objects.  Published as RFC 2011.";
  }
  revision "1991-03-31" {
    description
     "The initial revision of this MIB module was part of MIB-II,
      which was published as RFC 1213.";
  }

  /*** TYPE DEFINITIONS ***/

  typedef IpAddressOriginTC {
    type enumeration {
      enum other     { value 1; }
      enum manual    { value 2; }
      enum dhcp      { value 4; }
      enum linklayer { value 5; }
      enum random    { value 6; }
    }
    description
     "The origin of the address.

      manual(2) indicates that the address was manually configured
      to a specified address, e.g., by user configuration.

      dhcp(4) indicates an address that was assigned to this
      system by a DHCP server.

      linklayer(5) indicates an address created by IPv6 stateless
      auto-configuration.

      random(6) indicates an address chosen by the system at
      random, e.g., an IPv4 address within 169.254/16, or an RFC
      3041 privacy address.";
  }

  typedef IpAddressStatusTC {
    type enumeration {
      enum preferred    { value 1; }
      enum deprecated   { value 2; }
      enum invalid      { value 3; tailf:code-name tc_invalid; }
      enum inaccessible { value 4; }
          enum unknown      { value 5; tailf:code-name tc_unknown; }
      enum tentative    { value 6; }
      enum duplicate    { value 7; }
      enum optimistic   { value 8; }
    }
    description
     "The status of an address.  Most of the states correspond to
      states from the IPv6 Stateless Address Autoconfiguration
      protocol.

      The preferred(1) state indicates that this is a valid
      address that can appear as the destination or source address
      of a packet.

      The deprecated(2) state indicates that this is a valid but
      deprecated address that should no longer be used as a source
      address in new communications, but packets addressed to such
      an address are processed as expected.

      The invalid(3) state indicates that this isn't a valid
      address and it shouldn't appear as the destination or source
      address of a packet.

      The inaccessible(4) state indicates that the address is not
      accessible because the interface to which this address is
      assigned is not operational.

      The unknown(5) state indicates that the status cannot be
      determined for some reason.

      The tentative(6) state indicates that the uniqueness of the
      address on the link is being verified.  Addresses in this
      state should not be used for general communication and
      should only be used to determine the uniqueness of the
      address.

      The duplicate(7) state indicates the address has been
      determined to be non-unique on the link and so must not be
      used.

      The optimistic(8) state indicates the address is available
      for use, subject to restrictions, while its uniqueness on
      a link is being verified.

      In the absence of other information, an IPv4 address is
      always preferred(1).";
    reference
     "RFC 2462";
  }

  typedef IpAddressPrefixOriginTC {
    type enumeration {
      enum other     { value 1; }
      enum manual    { value 2; }
      enum wellknown { value 3; }
      enum dhcp      { value 4; }
      enum routeradv { value 5; }
    }
    description
     "The origin of this prefix.

      manual(2) indicates a prefix that was manually configured.

      wellknown(3) indicates a well-known prefix, e.g., 169.254/16
      for IPv4 auto-configuration or fe80::/10 for IPv6 link-local
      addresses.  Well known prefixes may be assigned by IANA,
      the address registries, or by specification in a standards
      track RFC.

      dhcp(4) indicates a prefix that was assigned by a DHCP
      server.

      routeradv(5) indicates a prefix learned from a router
      advertisement.

      Note: while IpAddressOriginTC and IpAddressPrefixOriginTC
      are similar, they are not identical.  The first defines how
      an address was created, while the second defines how a
      prefix was found.";
  }

  typedef Ipv6AddressIfIdentifierTC {
    type tailf:hex-list {
      tailf:value-length "0..8";
      pattern "(((([0-9A-Fa-f]{2})){0,7}([0-9A-Fa-f]{2}))){0,1}";
    }
    description
     "This data type is used to model IPv6 address
      interface identifiers.  This is a binary string
      of up to 8 octets in network byte-order.";
  }

  container ip {
    config false;
    tailf:callpoint ip_status;
    tailf:snmp-oid 1.3.6.1.2.1.4;
        leaf ipForwarding {
          tailf:snmp-name ipForwarding;
      type enumeration {
        enum forwarding    { value 1; }
        enum notForwarding { value 2; }
      }
      description
       "The indication of whether this entity is acting as an IPv4
        router in respect to the forwarding of datagrams received
        by, but not addressed to, this entity.  IPv4 routers forward
        datagrams.  IPv4 hosts do not (except those source-routed
        via the host).

        When this object is written, the entity should save the
        change to non-volatile storage and restore the object from
        non-volatile storage upon re-initialization of the system.
        Note: a stronger requirement is not used because this object
        was previously defined.";
    }

    leaf ipDefaultTTL {
          tailf:snmp-name ipDefaultTTL;
      type int32 {
        range "1..255";
      }
      description
       "The default value inserted into the Time-To-Live field of
        the IPv4 header of datagrams originated at this entity,
        whenever a TTL value is not supplied by the transport layer
        protocol.

        When this object is written, the entity should save the
        change to non-volatile storage and restore the object from
        non-volatile storage upon re-initialization of the system.
        Note: a stronger requirement is not used because this object
        was previously defined.";
    }

//    leaf ipInReceives {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The total number of input datagrams received from
//        interfaces, including those received in error.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsInRecieves.";
//    }

//    leaf ipInHdrErrors {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of input datagrams discarded due to errors in
//        their IPv4 headers, including bad checksums, version number
//        mismatch, other format errors, time-to-live exceeded, errors
//        discovered in processing their IPv4 options, etc.

//        This object has been deprecated as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsInHdrErrors.";
//    }

//    leaf ipInAddrErrors {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of input datagrams discarded because the IPv4
//        address in their IPv4 header's destination field was not a
//        valid address to be received at this entity.  This count
//        includes invalid addresses (e.g., 0.0.0.0) and addresses of
//        unsupported Classes (e.g., Class E).  For entities which are
//        not IPv4 routers, and therefore do not forward datagrams,
//        this counter includes datagrams discarded because the
//        destination address was not a local address.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsInAddrErrors.";
//    }

//    leaf ipForwDatagrams {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of input datagrams for which this entity was not
//        their final IPv4 destination, as a result of which an
//        attempt was made to find a route to forward them to that
//        final destination.  In entities which do not act as IPv4
//        routers, this counter will include only those packets which
//        were Source-Routed via this entity, and the Source-Route
//        option processing was successful.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsInForwDatagrams.";
//    }

//    leaf ipInUnknownProtos {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of locally-addressed datagrams received
//        successfully but discarded because of an unknown or
//        unsupported protocol.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsInUnknownProtos.";
//    }

//    leaf ipInDiscards {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of input IPv4 datagrams for which no problems
//        were encountered to prevent their continued processing, but
//        which were discarded (e.g., for lack of buffer space).  Note
//        that this counter does not include any datagrams discarded
//        while awaiting re-assembly.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsInDiscards.";
//    }

//    leaf ipInDelivers {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The total number of input datagrams successfully delivered
//        to IPv4 user-protocols (including ICMP).

//        This object has been deprecated as a new IP version neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsIndelivers.";
//    }

//    leaf ipOutRequests {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The total number of IPv4 datagrams which local IPv4 user
//        protocols (including ICMP) supplied to IPv4 in requests for
//        transmission.  Note that this counter does not include any
//        datagrams counted in ipForwDatagrams.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsOutRequests.";
//    }

//    leaf ipOutDiscards {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of output IPv4 datagrams for which no problem was
//        encountered to prevent their transmission to their
//        destination, but which were discarded (e.g., for lack of
//        buffer space).  Note that this counter would include
//        datagrams counted in ipForwDatagrams if any such packets met
//        this (discretionary) discard criterion.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsOutDiscards.";
//    }

//    leaf ipOutNoRoutes {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of IPv4 datagrams discarded because no route
//        could be found to transmit them to their destination.  Note
//        that this counter includes any packets counted in
//        ipForwDatagrams which meet this `no-route' criterion.  Note
//        that this includes any datagrams which a host cannot route
//        because all of its default routers are down.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsOutNoRoutes.";
//    }

    leaf ipReasmTimeout {
          tailf:snmp-name ipReasmTimeout;
      type int32;
      units "seconds";
      description
       "The maximum number of seconds that received fragments are
        held while they are awaiting reassembly at this entity.";
    }

//    leaf ipReasmReqds {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of IPv4 fragments received which needed to be
//        reassembled at this entity.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsReasmReqds.";
//    }

//    leaf ipReasmOKs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of IPv4 datagrams successfully re-assembled.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsReasmOKs.";
//    }

//    leaf ipReasmFails {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of failures detected by the IPv4 re-assembly
//        algorithm (for whatever reason: timed out, errors, etc).
//        Note that this is not necessarily a count of discarded IPv4
//        fragments since some algorithms (notably the algorithm in
//        RFC 815) can lose track of the number of fragments by
//        combining them as they are received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsReasmFails.";
//    }

//    leaf ipFragOKs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of IPv4 datagrams that have been successfully
//        fragmented at this entity.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsOutFragOKs.";
//    }

//    leaf ipFragFails {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of IPv4 datagrams that have been discarded
//        because they needed to be fragmented at this entity but
//        could not be, e.g., because their Don't Fragment flag was
//        set.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsOutFragFails.";
//    }

//    leaf ipFragCreates {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of IPv4 datagram fragments that have been
//        generated as a result of fragmentation at this entity.

//        This object has been deprecated as a new IP version neutral
//        table has been added.  It is loosely replaced by
//        ipSystemStatsOutFragCreates.";
//    }


//    list ipAddrEntry {

//      key "ipAdEntAddr";
//      status deprecated;
//      description
//       "The addressing information for one of this entity's IPv4
//        addresses.";


//      leaf ipAdEntAddr {
//        type inet:ipv4-address;
//        status deprecated;
//        description
//         "The IPv4 address to which this entry's addressing
//          information pertains.";
//      }

//      leaf ipAdEntIfIndex {
//        type int32 {
//          range "1..2147483647";
//        }
//        status deprecated;
//        description
//         "The index value which uniquely identifies the interface to
//          which this entry is applicable.  The interface identified by
//          a particular value of this index is the same interface as
//          identified by the same value of the IF-MIB's ifIndex.";
//      }

//      leaf ipAdEntNetMask {
//        type inet:ipv4-address;
//        status deprecated;
//        description
//         "The subnet mask associated with the IPv4 address of this
//          entry.  The value of the mask is an IPv4 address with all
//          the network bits set to 1 and all the hosts bits set to 0.";
//      }

//      leaf ipAdEntBcastAddr {
//        type int32 {
//          range "0..1";
//        }
//        status deprecated;
//        description
//         "The value of the least-significant bit in the IPv4 broadcast
//          address used for sending datagrams on the (logical)
//          interface associated with the IPv4 address of this entry.
//          For example, when the Internet standard all-ones broadcast
//          address is used, the value will be 1.  This value applies to
//          both the subnet and network broadcast addresses used by the
//          entity on this (logical) interface.";
//      }

//      leaf ipAdEntReasmMaxSize {
//        type int32 {
//          range "0..65535";
//        }
//        status deprecated;
//        description
//         "The size of the largest IPv4 datagram which this entity can
//          re-assemble from incoming IPv4 fragmented datagrams received
//          on this interface.";
//      }
//    }


    /* XXX table comments here XXX */

//    list ipNetToMediaEntry {

//      key "ipNetToMediaIfIndex ipNetToMediaNetAddress";
//      status deprecated;
//      description
//       "Each entry contains one IpAddress to `physical' address
//        equivalence.";


//      leaf ipNetToMediaIfIndex {
//        type int32 {
//          range "1..2147483647";
//        }
//        status deprecated;
//        description
//         "The interface on which this entry's equivalence is
//          effective.  The interface identified by a particular value
//          of this index is the same interface as identified by the
//          same value of the IF-MIB's ifIndex.

//          This object predates the rule limiting index objects to a
//          max access value of 'not-accessible' and so continues to use
//          a value of 'read-create'.";
//      }

//      leaf ipNetToMediaPhysAddress {
//        type yang:phys-address {
//          length "0..65535";
//        }
//        status deprecated;
//        description
//         "The media-dependent `physical' address.  This object should
//          return 0 when this entry is in the 'incomplete' state.

//          As the entries in this table are typically not persistent
//          when this object is written the entity should not save the
//          change to non-volatile storage.  Note: a stronger
//          requirement is not used because this object was previously
//          defined.";
//      }

//      leaf ipNetToMediaNetAddress {
//        type inet:ipv4-address;
//        status deprecated;
//       description
//         "The IpAddress corresponding to the media-dependent
//          `physical' address.

//          This object predates the rule limiting index objects to a
//          max access value of 'not-accessible' and so continues to use
//          a value of 'read-create'.";
//      }

//      leaf ipNetToMediaType {
//        type enumeration {
//          enum other   { value 1; }
//          enum invalid { value 2; }
//          enum dynamic { value 3; }
//          enum static  { value 4; }
//        }
//        status deprecated;
//        description
//         "The type of mapping.

//          Setting this object to the value invalid(2) has the effect
//          of invalidating the corresponding entry in the
//          ipNetToMediaTable.  That is, it effectively dis-associates
//          the interface identified with said entry from the mapping
//          identified with said entry.  It is an implementation-
//          specific matter as to whether the agent removes an
//          invalidated entry from the table.  Accordingly, management
//          stations must be prepared to receive tabular information
//          from agents that corresponds to entries not currently in
//          use.  Proper interpretation of such entries requires
//          examination of the relevant ipNetToMediaType object.

//          As the entries in this table are typically not persistent
//          when this object is written the entity should not save the
//          change to non-volatile storage.  Note: a stronger
//          requirement is not used because this object was previously
//          defined.";
//      }
//    }

//    leaf ipRoutingDiscards {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of routing entries which were chosen to be
//        discarded even though they are valid.  One possible reason
//        for discarding such an entry could be to free-up buffer
//        space for other routing entries.
//        This object was defined in pre-IPv6 versions of the IP MIB.
//        It was implicitly IPv4 only, but the original specifications
//        did not indicate this protocol restriction.  In order to
//        clarify the specifications, this object has been deprecated
//        and a similar, but more thoroughly clarified, object has
//        been added to the IP-FORWARD-MIB.";
//    }

   leaf ipv6IpForwarding {
         tailf:snmp-name ipv6IpForwarding;
     type enumeration {
       enum forwarding    { value 1; }
       enum notForwarding { value 2; }
     }
     description
      "The indication of whether this entity is acting as an IPv6
       router on any interface in respect to the forwarding of
       datagrams received by, but not addressed to, this entity.
       IPv6 routers forward datagrams.  IPv6 hosts do not (except
       those source-routed via the host).

       When this object is written, the entity SHOULD save the
       change to non-volatile storage and restore the object from
       non-volatile storage upon re-initialization of the system.";
   }

   leaf ipv6IpDefaultHopLimit {
         tailf:snmp-name ipv6IpDefaultHopLimit;
     type int32 {
       range "0..255";
     }
     description
      "The default value inserted into the Hop Limit field of the
       IPv6 header of datagrams originated at this entity whenever
       a Hop Limit value is not supplied by the transport layer
       protocol.

       When this object is written, the entity SHOULD save the
       change to non-volatile storage and restore the object from
       non-volatile storage upon re-initialization of the system.";
     reference
      "RFC 2461 Section 6.3.2";
   }

   leaf ipv4InterfaceTableLastChange {
     tailf:snmp-name ipv4InterfaceTableLastChange;
     type yang:timestamp;
     description
      "The value of sysUpTime on the most recent occasion at which
       a row in the ipv4InterfaceTable was added or deleted, or
       when an ipv4InterfaceReasmMaxSize or an
       ipv4InterfaceEnableStatus object was modified.

       If new objects are added to the ipv4InterfaceTable that
       require the ipv4InterfaceTableLastChange to be updated when
       they are modified, they must specify that requirement in
       their description clause.";
   }


    /* XXX table comments here XXX */

    list ipv4InterfaceEntry {
          tailf:callpoint ipv4_if_status;
          tailf:snmp-oid 1.3.6.1.2.1.4.28;
          tailf:sort-order snmp;
      key "ipv4InterfaceIfIndex";
      description
       "An entry containing IPv4-specific information for a specific
        interface.";


      leaf ipv4InterfaceIfIndex {
                tailf:snmp-name ipv4InterfaceIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface to
          which this entry is applicable.  The interface identified by
          a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipv4InterfaceReasmMaxSize {
                tailf:snmp-name ipv4InterfaceReasmMaxSize;
        type int32 {
          range "0..65535";
        }
        description
         "The size of the largest IPv4 datagram that this entity can
          re-assemble from incoming IPv4 fragmented datagrams received
          on this interface.";
      }

      leaf ipv4InterfaceEnableStatus {
                tailf:snmp-name ipv4InterfaceEnableStatus;
        type enumeration {
          enum up   { value 1; }
          enum down { value 2; }
        }
        description
         "The indication of whether IPv4 is enabled (up) or disabled
          (down) on this interface.  This object does not affect the
          state of the interface itself, only its connection to an
          IPv4 stack.  The IF-MIB should be used to control the state
          of the interface.";
      }

      leaf ipv4InterfaceRetransmitTime {
                tailf:snmp-name ipv4InterfaceRetransmitTime;
        type uint32;
        units "milliseconds";
        description
         "The time between retransmissions of ARP requests to a
          neighbor when resolving the address or when probing the
          reachability of a neighbor.";
        reference
         "RFC 1122";
      }
    }

    leaf ipv6InterfaceTableLastChange {
      tailf:snmp-name ipv6InterfaceTableLastChange;
      type yang:timestamp;
      description
       "The value of sysUpTime on the most recent occasion at which
        a row in the ipv6InterfaceTable was added or deleted or when
        an ipv6InterfaceReasmMaxSize, ipv6InterfaceIdentifier,
        ipv6InterfaceEnableStatus, ipv6InterfaceReachableTime,
        ipv6InterfaceRetransmitTime, or ipv6InterfaceForwarding
        object was modified.

        If new objects are added to the ipv6InterfaceTable that
        require the ipv6InterfaceTableLastChange to be updated when
        they are modified, they must specify that requirement in
        their description clause.";
    }


    /* XXX table comments here XXX */

    list ipv6InterfaceEntry {
      tailf:snmp-oid 1.3.6.1.2.1.4.30;
      tailf:callpoint ipv6_if_status;
      tailf:sort-order snmp;

      key "ipv6InterfaceIfIndex";
      description
       "An entry containing IPv6-specific information for a given
        interface.";


      leaf ipv6InterfaceIfIndex {
        tailf:snmp-name ipv6InterfaceIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface to
          which this entry is applicable.  The interface identified by
          a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipv6InterfaceReasmMaxSize {
        tailf:snmp-name ipv6InterfaceReasmMaxSize;
        type uint32 {
          range "1500..65535";
        }
        units "octets";
        description
         "The size of the largest IPv6 datagram that this entity can
          re-assemble from incoming IPv6 fragmented datagrams received
          on this interface.";
      }

      leaf ipv6InterfaceIdentifier {
        tailf:snmp-name ipv6InterfaceIdentifier;
        type ip-mib:Ipv6AddressIfIdentifierTC;
        description
         "The Interface Identifier for this interface.  The Interface
          Identifier is combined with an address prefix to form an
          interface address.

          By default, the Interface Identifier is auto-configured
          according to the rules of the link type to which this
          interface is attached.

          A zero length identifier may be used where appropriate.  One
          possible example is a loopback interface.";
      }

      leaf ipv6InterfaceEnableStatus {
        tailf:snmp-name ipv6InterfaceEnableStatus;
        type enumeration {
          enum up   { value 1; }
          enum down { value 2; }
        }
        description
         "The indication of whether IPv6 is enabled (up) or disabled
          (down) on this interface.  This object does not affect the
          state of the interface itself, only its connection to an
          IPv6 stack.  The IF-MIB should be used to control the state
          of the interface.

          When this object is written, the entity SHOULD save the
          change to non-volatile storage and restore the object from
          non-volatile storage upon re-initialization of the system.";
      }

      leaf ipv6InterfaceReachableTime {
        tailf:snmp-name ipv6InterfaceReachableTime;
        type uint32;
        units "milliseconds";
        description
         "The time a neighbor is considered reachable after receiving
          a reachability confirmation.";
        reference
         "RFC 2461, Section 6.3.2";
      }

      leaf ipv6InterfaceRetransmitTime {
        tailf:snmp-name ipv6InterfaceRetransmitTime;
        type uint32;
        units "milliseconds";
        description
         "The time between retransmissions of Neighbor Solicitation
          messages to a neighbor when resolving the address or when
          probing the reachability of a neighbor.";
        reference
         "RFC 2461, Section 6.3.2";
      }

      leaf ipv6InterfaceForwarding {
        tailf:snmp-name ipv6InterfaceForwarding;
        type enumeration {
          enum forwarding    { value 1; }
          enum notForwarding { value 2; }
        }
        description
         "The indication of whether this entity is acting as an IPv6
          router on this interface with respect to the forwarding of
          datagrams received by, but not addressed to, this entity.
          IPv6 routers forward datagrams.  IPv6 hosts do not (except
          those source-routed via the host).

          This object is constrained by ipv6IpForwarding and is
          ignored if ipv6IpForwarding is set to notForwarding.  Those
          systems that do not provide per-interface control of the
          forwarding function should set this object to forwarding for
          all interfaces and allow the ipv6IpForwarding object to
          control the forwarding capability.

          When this object is written, the entity SHOULD save the
          change to non-volatile storage and restore the object from
          non-volatile storage upon re-initialization of the system.";
      }
    }



    /* XXX table comments here XXX */

    list ipAddressPrefixEntry {
          tailf:callpoint ip_address_prefix_status;
          tailf:sort-order snmp;
          tailf:snmp-oid 1.3.6.1.2.1.4.32;

      key "ipAddressPrefixIfIndex ipAddressPrefixType
           ipAddressPrefixPrefix ipAddressPrefixLength";
      description
       "An entry in the ipAddressPrefixTable.";


      leaf ipAddressPrefixIfIndex {
                tailf:snmp-name ipAddressPrefixIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface on
          which this prefix is configured.  The interface identified
          by a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipAddressPrefixType {
                tailf:snmp-name ipAddressPrefixType;
        type inet-address:InetAddressType;
        description
         "The address type of ipAddressPrefix.";
      }

      leaf ipAddressPrefixPrefix {
                tailf:snmp-name ipAddressPrefixPrefix;
        type inet-address:InetAddress;
        description
         "The address prefix.  The address type of this object is
          specified in ipAddressPrefixType.  The length of this object
          is the standard length for objects of that type (4 or 16
          bytes).  Any bits after ipAddressPrefixLength must be zero.

          Implementors need to be aware that, if the size of
          ipAddressPrefixPrefix exceeds 114 octets, then OIDS of
          instances of columns in this row will have more than 128
          sub-identifiers and cannot be accessed using SNMPv1,
          SNMPv2c, or SNMPv3.";
      }

      leaf ipAddressPrefixLength {
                tailf:snmp-name ipAddressPrefixLength;
        type inet-address:InetAddressPrefixLength;
        description
         "The prefix length associated with this prefix.

          The value 0 has no special meaning for this object.  It
          simply refers to address '::/0'.";
      }
      leaf ipAddressPrefixOrigin {
                tailf:snmp-name ipAddressPrefixOrigin;
        type ip-mib:IpAddressPrefixOriginTC;
        description
         "The origin of this prefix.";
      }
      leaf ipAddressPrefixOnLinkFlag {
                tailf:snmp-name ipAddressPrefixOnLinkFlag;
        type smiv2:TruthValue;
        description
         "This object has the value 'true(1)', if this prefix can be
          used for on-link determination; otherwise, the value is
          'false(2)'.

          The default for IPv4 prefixes is 'true(1)'.";
        reference
         "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
          RFC 2462";
      }

      leaf ipAddressPrefixAutonomousFlag {
                tailf:snmp-name ipAddressPrefixAutonomousFlag;
        type smiv2:TruthValue;
        description
         "Autonomous address configuration flag.  When true(1),
          indicates that this prefix can be used for autonomous
          address configuration (i.e., can be used to form a local
          interface address).  If false(2), it is not used to auto-
          configure a local interface address.

          The default for IPv4 prefixes is 'false(2)'.";
        reference
         "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
          RFC 2462";
      }

      leaf ipAddressPrefixAdvPreferredLifetime {
                tailf:snmp-name ipAddressPrefixAdvPreferredLifetime;
        type uint32;
        units "seconds";
        description
         "The remaining length of time, in seconds, that this prefix
          will continue to be preferred, i.e., time until deprecation.

          A value of 4,294,967,295 represents infinity.

          The address generated from a deprecated prefix should no
          longer be used as a source address in new communications,
          but packets received on such an interface are processed as
          expected.

          The default for IPv4 prefixes is 4,294,967,295 (infinity).";
        reference
         "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
          RFC 2462";
      }

      leaf ipAddressPrefixAdvValidLifetime {
                tailf:snmp-name ipAddressPrefixAdvValidLifetime;
        type uint32;
        units "seconds";
        description
         "The remaining length of time, in seconds, that this prefix
          will continue to be valid, i.e., time until invalidation.  A
          value of 4,294,967,295 represents infinity.

          The address generated from an invalidated prefix should not
          appear as the destination or source address of a packet.

          The default for IPv4 prefixes is 4,294,967,295 (infinity).";
        reference
         "For IPv6 RFC 2461, especially sections 2 and 4.6.2 and
          RFC 2462";
      }
    }

    leaf ipAddressSpinLock {
      tailf:snmp-name ipAddressSpinLock;
      type smiv2:TestAndIncr;
      description
       "An advisory lock used to allow cooperating SNMP managers to
        coordinate their use of the set operation in creating or
        modifying rows within this table.

        In order to use this lock to coordinate the use of set
        operations, managers should first retrieve
        ipAddressTableSpinLock.  They should then determine the
        appropriate row to create or modify.  Finally, they should
        issue the appropriate set command, including the retrieved
        value of ipAddressSpinLock.  If another manager has altered
        the table in the meantime, then the value of
        ipAddressSpinLock will have changed, and the creation will
        fail as it will be specifying an incorrect value for
        ipAddressSpinLock.  It is suggested, but not required, that
        the ipAddressSpinLock be the first var bind for each set of
        objects representing a 'row' in a PDU.";
    }


    /* XXX table comments here XXX */

    list ipAddressEntry {

      key "ipAddressAddrType ipAddressAddr";
      tailf:callpoint ip_address_status;
      tailf:snmp-oid 1.3.6.1.2.1.4.34;
      tailf:sort-order snmp;
      description
       "An address mapping for a particular interface.";


      leaf ipAddressAddrType {
        tailf:snmp-name ipAddressAddrType;
        type inet-address:InetAddressType;
        description
         "The address type of ipAddressAddr.";
      }

      leaf ipAddressAddr {
        tailf:snmp-name ipAddressAddr;
        type inet-address:InetAddress;
        description
         "The IP address to which this entry's addressing information
          pertains.  The address type of this object is specified in
          ipAddressAddrType.

          Implementors need to be aware that if the size of
          ipAddressAddr exceeds 116 octets, then OIDS of instances of
          columns in this row will have more than 128 sub-identifiers
          and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.";
      }

      leaf ipAddressIfIndex {
        tailf:snmp-name ipAddressIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface to
          which this entry is applicable.  The interface identified by
          a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipAddressType {
        tailf:snmp-name ipAddressType;
        type enumeration {
          enum unicast   { value 1; }
          enum anycast   { value 2; }
          enum broadcast { value 3; }
        }
        description
         "The type of address.  broadcast(3) is not a valid value for
          IPv6 addresses (RFC 3513).";
      }

      leaf ipAddressPrefix {
      tailf:snmp-name ipAddressPrefix;
        type smiv2:RowPointer;
        description
         "A pointer to the row in the prefix table to which this
          address belongs.  May be { 0 0 } if there is no such row.";
      }

      leaf ipAddressOrigin {
        tailf:snmp-name ipAddressOrigin;
        type ip-mib:IpAddressOriginTC;
        description
         "The origin of the address.";
      }

      leaf ipAddressStatus {
        tailf:snmp-name ipAddressStatus;
        type ip-mib:IpAddressStatusTC;
        description
         "The status of the address, describing if the address can be
          used for communication.

          In the absence of other information, an IPv4 address is
          always preferred(1).";
      }

      leaf ipAddressCreated {
        tailf:snmp-name ipAddressCreated;
        type yang:timestamp;
        description
         "The value of sysUpTime at the time this entry was created.
          If this entry was created prior to the last re-
          initialization of the local network management subsystem,
          then this object contains a zero value.";
      }

      leaf ipAddressLastChanged {
        tailf:snmp-name ipAddressLastChanged;
        type yang:timestamp;
        description
         "The value of sysUpTime at the time this entry was last
          updated.  If this entry was updated prior to the last re-
          initialization of the local network management subsystem,
          then this object contains a zero value.";
      }
/* provided by the agent itself
      leaf ipAddressRowStatus {
        type smiv2:RowStatus;
        description
         "The status of this conceptual row.

          The RowStatus TC requires that this DESCRIPTION clause
          states under which circumstances other objects in this row
          can be modified.  The value of this object has no effect on
          whether other objects in this conceptual row can be
          modified.

          A conceptual row can not be made active until the
          ipAddressIfIndex has been set to a valid index.";
      }
*/
      leaf ipAddressStorageType {
        tailf:snmp-name ipAddressStorageType;
        type smiv2:StorageType;
        description
         "The storage type for this conceptual row.  If this object
          has a value of 'permanent', then no other objects are
          required to be able to be modified.";
      }
    }


    /* XXX table comments here XXX */

    list ipNetToPhysicalEntry {
      tailf:callpoint ip-net-to-physical-stats;
      tailf:sort-order snmp;
      tailf:snmp-oid 1.3.6.1.2.1.4.35;

      key "ipNetToPhysicalIfIndex ipNetToPhysicalNetAddressType
           ipNetToPhysicalNetAddress";
      description
       "Each entry contains one IP address to `physical' address
        equivalence.";


      leaf ipNetToPhysicalIfIndex {
        tailf:snmp-name ipNetToPhysicalIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface to
          which this entry is applicable.  The interface identified by
          a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipNetToPhysicalNetAddressType {
        tailf:snmp-name ipNetToPhysicalNetAddressType;
        type inet-address:InetAddressType;
        description
         "The type of ipNetToPhysicalNetAddress.";
      }

      leaf ipNetToPhysicalNetAddress {
        tailf:snmp-name ipNetToPhysicalNetAddress;
        type inet-address:InetAddress;
        description
         "The IP Address corresponding to the media-dependent
          `physical' address.  The address type of this object is
          specified in ipNetToPhysicalAddressType.

          Implementors need to be aware that if the size of
          ipNetToPhysicalNetAddress exceeds 115 octets, then OIDS of
          instances of columns in this row will have more than 128
          sub-identifiers and cannot be accessed using SNMPv1,
          SNMPv2c, or SNMPv3.";
      }

      leaf ipNetToPhysicalPhysAddress {
        tailf:snmp-name ipNetToPhysicalPhysAddress;
        type yang:phys-address {
          tailf:value-length "0..65535";
        }
        description
         "The media-dependent `physical' address.

          As the entries in this table are typically not persistent
          when this object is written the entity SHOULD NOT save the
          change to non-volatile storage.";
      }

      leaf ipNetToPhysicalLastUpdated {
        tailf:snmp-name ipNetToPhysicalLastUpdated;
        type yang:timestamp;
        description
         "The value of sysUpTime at the time this entry was last
          updated.  If this entry was updated prior to the last re-
          initialization of the local network management subsystem,
          then this object contains a zero value.";
      }

      leaf ipNetToPhysicalType {
        tailf:snmp-name ipNetToPhysicalType;
        type enumeration {
          enum other   { value 1; }
          enum invalid { value 2; tailf:code-name pt_invalid; }
          enum dynamic { value 3; }
          enum static  { value 4; }
          enum local   { value 5; }
        }
        description
         "The type of mapping.

          Setting this object to the value invalid(2) has the effect
          of invalidating the corresponding entry in the
          ipNetToPhysicalTable.  That is, it effectively dis-
          associates the interface identified with said entry from the
          mapping identified with said entry.  It is an
          implementation-specific matter as to whether the agent
          removes an invalidated entry from the table.  Accordingly,
          management stations must be prepared to receive tabular
          information from agents that corresponds to entries not
          currently in use.  Proper interpretation of such entries
          requires examination of the relevant ipNetToPhysicalType
          object.

          The 'dynamic(3)' type indicates that the IP address to
          physical addresses mapping has been dynamically resolved
          using e.g., IPv4 ARP or the IPv6 Neighbor Discovery
          protocol.

          The 'static(4)' type indicates that the mapping has been
          statically configured.  Both of these refer to entries that
          provide mappings for other entities addresses.

          The 'local(5)' type indicates that the mapping is provided
          for an entity's own interface address.

          As the entries in this table are typically not persistent
          when this object is written the entity SHOULD NOT save the
          change to non-volatile storage.";
      }

      leaf ipNetToPhysicalState {
        tailf:snmp-name ipNetToPhysicalState;
        type enumeration {
          enum reachable  { value 1; }
          enum stale      { value 2; }
          enum delay      { value 3; }
          enum probe      { value 4; }
          enum invalid    { value 5; tailf:code-name ps_invalid; }
          enum unknown    { value 6; tailf:code-name ps_unknown; }
          enum incomplete { value 7; }
        }
        description
         "The Neighbor Unreachability Detection state for the
          interface when the address mapping in this entry is used.
          If Neighbor Unreachability Detection is not in use (e.g. for
          IPv4), this object is always unknown(6).";
        reference
         "RFC 2461";
      }

      leaf ipNetToPhysicalRowStatus {
        type smiv2:RowStatus;
        description
         "The status of this conceptual row.

          The RowStatus TC requires that this DESCRIPTION clause
          states under which circumstances other objects in this row
          can be modified.  The value of this object has no effect on
          whether other objects in this conceptual row can be
          modified.

          A conceptual row can not be made active until the
          ipNetToPhysicalPhysAddress object has been set.

          Note that if the ipNetToPhysicalType is set to 'invalid',
          the managed node may delete the entry independent of the
          state of this object.";
      }
    }


    /* XXX table comments here XXX */

    list ipv6ScopeZoneIndexEntry {

      key "ipv6ScopeZoneIndexIfIndex";

      tailf:callpoint ip6_scope_zone_idx;
      tailf:sort-order snmp;
      tailf:snmp-oid 1.3.6.1.2.1.4.36;

      description
       "Each entry contains the list of scope identifiers on a given
        interface.";


      leaf ipv6ScopeZoneIndexIfIndex {
        tailf:snmp-name ipv6ScopeZoneIndexIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface to
          which these scopes belong.  The interface identified by a
          particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipv6ScopeZoneIndexLinkLocal {
        tailf:snmp-name ipv6ScopeZoneIndexLinkLocal;
        type inet-address:InetZoneIndex;
        description
         "The zone index for the link-local scope on this interface.";
      }

      leaf ipv6ScopeZoneIndex3 {
        tailf:snmp-name ipv6ScopeZoneIndex3;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope 3 on this interface.";
      }

      leaf ipv6ScopeZoneIndexAdminLocal {
        tailf:snmp-name ipv6ScopeZoneIndexAdminLocal;
        type inet-address:InetZoneIndex;
        description
         "The zone index for the admin-local scope on this interface.";
      }

      leaf ipv6ScopeZoneIndexSiteLocal {
        tailf:snmp-name ipv6ScopeZoneIndexSiteLocal;
        type inet-address:InetZoneIndex;
        description
         "The zone index for the site-local scope on this interface.";
      }

      leaf ipv6ScopeZoneIndex6 {
        tailf:snmp-name ipv6ScopeZoneIndex6;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope 6 on this interface.";
      }

      leaf ipv6ScopeZoneIndex7 {
        tailf:snmp-name ipv6ScopeZoneIndex7;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope 7 on this interface.";
      }

      leaf ipv6ScopeZoneIndexOrganizationLocal {
        tailf:snmp-name ipv6ScopeZoneIndexOrganizationLocal;
        type inet-address:InetZoneIndex;
        description
         "The zone index for the organization-local scope on this
          interface.";
      }

      leaf ipv6ScopeZoneIndex9 {
        tailf:snmp-name ipv6ScopeZoneIndex9;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope 9 on this interface.";
      }

      leaf ipv6ScopeZoneIndexA {
        tailf:snmp-name ipv6ScopeZoneIndexA;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope A on this interface.";
      }

      leaf ipv6ScopeZoneIndexB {
        tailf:snmp-name ipv6ScopeZoneIndexB;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope B on this interface.";
      }

      leaf ipv6ScopeZoneIndexC {
        tailf:snmp-name ipv6ScopeZoneIndexC;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope C on this interface.";
      }

      leaf ipv6ScopeZoneIndexD {
        tailf:snmp-name ipv6ScopeZoneIndexD;
        type inet-address:InetZoneIndex;
        description
         "The zone index for scope D on this interface.";
      }
    }


    /* XXX table comments here XXX */

    list ipDefaultRouterEntry {

      tailf:snmp-oid 1.3.6.1.2.1.4.37;
      tailf:sort-order snmp;

      key "ipDefaultRouterAddressType ipDefaultRouterAddress
           ipDefaultRouterIfIndex";
      description
       "Each entry contains information about a default router known
        to this entity.";
      tailf:callpoint ip_def_router;

      leaf ipDefaultRouterAddressType {
        tailf:snmp-name ipDefaultRouterAddressType;
        type inet-address:InetAddressType;
        description
         "The address type for this row.";
      }

      leaf ipDefaultRouterAddress {
        tailf:snmp-name ipDefaultRouterAddress;
        type inet-address:InetAddress;
        description
         "The IP address of the default router represented by this
          row.  The address type of this object is specified in
          ipDefaultRouterAddressType.

          Implementers need to be aware that if the size of
          ipDefaultRouterAddress exceeds 115 octets, then OIDS of
          instances of columns in this row will have more than 128
          sub-identifiers and cannot be accessed using SNMPv1,
          SNMPv2c, or SNMPv3.";
      }

      leaf ipDefaultRouterIfIndex {
        tailf:snmp-name ipDefaultRouterIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface by
          which the router can be reached.  The interface identified
          by a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipDefaultRouterLifetime {
        tailf:snmp-name ipDefaultRouterLifetime;
        type uint32 {
          range "0..65535";
        }
        units "seconds";
        description
         "The remaining length of time, in seconds, that this router
          will continue to be useful as a default router.  A value of
          zero indicates that it is no longer useful as a default
          router.  It is left to the implementer of the MIB as to
          whether a router with a lifetime of zero is removed from the
          list.

          For IPv6, this value should be extracted from the router
          advertisement messages.";
        reference
         "For IPv6 RFC 2462 sections 4.2 and 6.3.4";
      }

      leaf ipDefaultRouterPreference {
        tailf:snmp-name ipDefaultRouterPreference;
        type enumeration {
          enum reserved { value -2; }
          enum low      { value -1; }
          enum medium   { value 0; }
          enum high     { value 1; }
        }
        description
         "An indication of preference given to this router as a
          default router as described in he Default Router
          Preferences document.  Treating the value as a
          2 bit signed integer allows for simple arithmetic
          comparisons.

          For IPv4 routers or IPv6 routers that are not using the
          updated router advertisement format, this object is set to
          medium (0).";
        reference
         "RFC 4291, section 2.1";
      }
    }

    leaf ipv6RouterAdvertSpinLock {
      tailf:snmp-name ipv6RouterAdvertSpinLock;
      type smiv2:TestAndIncr;
      description
       "An advisory lock used to allow cooperating SNMP managers to
        coordinate their use of the set operation in creating or
        modifying rows within this table.

        In order to use this lock to coordinate the use of set
        operations, managers should first retrieve
        ipv6RouterAdvertSpinLock.  They should then determine the
        appropriate row to create or modify.  Finally, they should
        issue the appropriate set command including the retrieved
        value of ipv6RouterAdvertSpinLock.  If another manager has
        altered the table in the meantime, then the value of
        ipv6RouterAdvertSpinLock will have changed and the creation
        will fail as it will be specifying an incorrect value for
        ipv6RouterAdvertSpinLock.  It is suggested, but not
        required, that the ipv6RouterAdvertSpinLock be the first var
        bind for each set of objects representing a 'row' in a PDU.";
    }


    /* XXX table comments here XXX */

    list ipv6RouterAdvertEntry {
          tailf:callpoint ipv6_router_status;
          tailf:snmp-oid 1.3.6.1.2.1.4.39;
          tailf:sort-order snmp;

      key "ipv6RouterAdvertIfIndex";
      description
       "An entry containing information used to construct router
        advertisements.

        Information in this table is persistent, and when this
        object is written, the entity SHOULD save the change to
        non-volatile storage.";


      leaf ipv6RouterAdvertIfIndex {
                tailf:snmp-name ipv6RouterAdvertIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface on
          which router advertisements constructed with this
          information will be transmitted.  The interface identified
          by a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipv6RouterAdvertSendAdverts {
                tailf:snmp-name ipv6RouterAdvertSendAdverts;
        type smiv2:TruthValue;
        description
         "A flag indicating whether the router sends periodic
          router advertisements and responds to router solicitations
          on this interface.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertMaxInterval {
                tailf:snmp-name ipv6RouterAdvertMaxInterval;
        type uint32 {
          range "4..1800";
        }
        units "seconds";
        description
         "The maximum time allowed between sending unsolicited router
          advertisements from this interface.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertMinInterval {
                tailf:snmp-name ipv6RouterAdvertMinInterval;
        type uint32 {
          range "3..1350";
        }
        units "seconds";
        description
         "The minimum time allowed between sending unsolicited router
          advertisements from this interface.

          The default is 0.33 * ipv6RouterAdvertMaxInterval, however,
          in the case of a low value for ipv6RouterAdvertMaxInterval,
          the minimum value for this object is restricted to 3.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertManagedFlag {
                tailf:snmp-name ipv6RouterAdvertManagedFlag;
        type smiv2:TruthValue;
        description
         "The true/false value to be placed into the 'managed address
          configuration' flag field in router advertisements sent from
          this interface.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertOtherConfigFlag {
                tailf:snmp-name ipv6RouterAdvertOtherConfigFlag;
        type smiv2:TruthValue;
        description
         "The true/false value to be placed into the 'other stateful
          configuration' flag field in router advertisements sent from
          this interface.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertLinkMTU {
                tailf:snmp-name ipv6RouterAdvertLinkMTU;
        type uint32;
        description
         "The value to be placed in MTU options sent by the router on
          this interface.

          A value of zero indicates that no MTU options are sent.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertReachableTime {
                tailf:snmp-name ipv6RouterAdvertReachableTime;
        type uint32 {
          range "0..3600000";
        }
        units "milliseconds";
        description
         "The value to be placed in the reachable time field in router
          advertisement messages sent from this interface.

          A value of zero in the router advertisement indicates that
          the advertisement isn't specifying a value for reachable
          time.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertRetransmitTime {
                tailf:snmp-name ipv6RouterAdvertRetransmitTime;
        type uint32;
        units "milliseconds";
        description
         "The value to be placed in the retransmit timer field in
          router advertisements sent from this interface.

          A value of zero in the router advertisement indicates that
          the advertisement isn't specifying a value for retrans
          time.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertCurHopLimit {
                tailf:snmp-name ipv6RouterAdvertCurHopLimit;
        type uint32 {
          range "0..255";
        }
        description
         "The default value to be placed in the current hop limit
          field in router advertisements sent from this interface.
          The value should be set to the current diameter of the
          Internet.

          A value of zero in the router advertisement indicates that
          the advertisement isn't specifying a value for curHopLimit.

          The default should be set to the value specified in the IANA
          web pages (www.iana.org) at the time of implementation.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertDefaultLifetime {
                tailf:snmp-name ipv6RouterAdvertDefaultLifetime;
        type uint32 {
          range "0..9000";
          // should be "0 | 4..9000", but .bin compiler complains
        }
        units "seconds";
        description
         "The value to be placed in the router lifetime field of
          router advertisements sent from this interface.  This value
          MUST be either 0 or between ipv6RouterAdvertMaxInterval and
          9000 seconds.

          A value of zero indicates that the router is not to be used
          as a default router.

          The default is 3 * ipv6RouterAdvertMaxInterval.";
        reference
         "RFC 2461 Section 6.2.1";
      }

      leaf ipv6RouterAdvertRowStatus {
        type smiv2:RowStatus;
        description
         "The status of this conceptual row.

          As all objects in this conceptual row have default values, a
          row can be created and made active by setting this object
          appropriately.

          The RowStatus TC requires that this DESCRIPTION clause
          states under which circumstances other objects in this row
          can be modified.  The value of this object has no effect on
          whether other objects in this conceptual row can be
          modified.";
      }
    }
  }

  container ipTrafficStats {
    config false;
        tailf:callpoint ip_traf_status;

    /* XXX table comments here XXX */

    list ipSystemStatsEntry {
          tailf:sort-order snmp;
          tailf:snmp-oid 1.3.6.1.2.1.4.31.1;
      tailf:callpoint ip_traf_system_stats;

      key "ipSystemStatsIPVersion";
      description
       "A statistics entry containing system-wide objects for a
        particular IP version.";


      leaf ipSystemStatsIPVersion {
                tailf:snmp-name ipSystemStatsIPVersion;
        type inet-address:InetVersion;
        description
         "The IP version of this row.";
      }

      leaf ipSystemStatsInReceives {
                tailf:snmp-name ipSystemStatsInReceives;
        type yang:counter32;
        description
         "The total number of input IP datagrams received, including
          those received in error.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCInReceives {
                tailf:snmp-name ipSystemStatsHCInReceives;
        type yang:counter64;
        description
         "The total number of input IP datagrams received, including
          those received in error.  This object counts the same
          datagrams as ipSystemStatsInReceives, but allows for larger
          values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInOctets {
        type yang:counter32;
        description
         "The total number of octets received in input IP datagrams,
          including those received in error.  Octets from datagrams
          counted in ipSystemStatsInReceives MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCInOctets {
        type yang:counter64;
        description
         "The total number of octets received in input IP datagrams,
          including those received in error.  This object counts the
          same octets as ipSystemStatsInOctets, but allows for larger
          values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInHdrErrors {
                tailf:snmp-name ipSystemStatsInHdrErrors;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded due to errors in
          their IP headers, including version number mismatch, other
          format errors, hop count exceeded, errors discovered in
          processing their IP options, etc.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInNoRoutes {
                tailf:snmp-name ipSystemStatsInNoRoutes;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded because no route
          could be found to transmit them to their destination.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInAddrErrors {
                tailf:snmp-name ipSystemStatsInAddrErrors;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded because the IP
          address in their IP header's destination field was not a
          valid address to be received at this entity.  This count
          includes invalid addresses (e.g., ::0).  For entities
          that are not IP routers and therefore do not forward
          datagrams, this counter includes datagrams discarded
          because the destination address was not a local address.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInUnknownProtos {
                tailf:snmp-name ipSystemStatsInUnknownProtos;
        type yang:counter32;
        description
         "The number of locally-addressed IP datagrams received
          successfully but discarded because of an unknown or
          unsupported protocol.

          When tracking interface statistics, the counter of the
          interface to which these datagrams were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the datagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInTruncatedPkts {
                tailf:snmp-name ipSystemStatsInTruncatedPkts;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded because the
          datagram frame didn't carry enough data.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInForwDatagrams {
                tailf:snmp-name ipSystemStatsInForwDatagrams;
        type yang:counter32;
        description
         "The number of input datagrams for which this entity was not
          their final IP destination and for which this entity
          attempted to find a route to forward them to that final
          destination.  In entities that do not act as IP routers,
          this counter will include only those datagrams that were
          Source-Routed via this entity, and the Source-Route
          processing was successful.

          When tracking interface statistics, the counter of the
          incoming interface is incremented for each datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCInForwDatagrams {
                tailf:snmp-name ipSystemStatsHCInForwDatagrams;
        type yang:counter64;
        description
         "The number of input datagrams for which this entity was not
          their final IP destination and for which this entity
          attempted to find a route to forward them to that final
          destination.  This object counts the same packets as
          ipSystemStatsInForwDatagrams, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsReasmReqds {
                tailf:snmp-name ipSystemStatsReasmReqds;
        type yang:counter32;
        description
         "The number of IP fragments received that needed to be
          reassembled at this interface.

          When tracking interface statistics, the counter of the
          interface to which these fragments were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the fragments.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsReasmOKs {
                tailf:snmp-name ipSystemStatsReasmOKs;
        type yang:counter32;
        description
         "The number of IP datagrams successfully reassembled.

          When tracking interface statistics, the counter of the
          interface to which these datagrams were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the datagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsReasmFails {
                tailf:snmp-name ipSystemStatsReasmFails;
        type yang:counter32;
        description
         "The number of failures detected by the IP re-assembly
          algorithm (for whatever reason: timed out, errors, etc.).
          Note that this is not necessarily a count of discarded IP
          fragments since some algorithms (notably the algorithm in
          RFC 815) can lose track of the number of fragments by
          combining them as they are received.

          When tracking interface statistics, the counter of the
          interface to which these fragments were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the fragments.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInDiscards {
                tailf:snmp-name ipSystemStatsInDiscards;
        type yang:counter32;
        description
         "The number of input IP datagrams for which no problems were
          encountered to prevent their continued processing, but
          were discarded (e.g., for lack of buffer space).  Note that
          this counter does not include any datagrams discarded while
          awaiting re-assembly.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInDelivers {
                tailf:snmp-name ipSystemStatsInDelivers;
        type yang:counter32;
        description
         "The total number of datagrams successfully delivered to IP
          user-protocols (including ICMP).

          When tracking interface statistics, the counter of the
          interface to which these datagrams were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the datagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCInDelivers {
                tailf:snmp-name ipSystemStatsHCInDelivers;
        type yang:counter64;
        description
         "The total number of datagrams successfully delivered to IP
          user-protocols (including ICMP).  This object counts the
          same packets as ipSystemStatsInDelivers, but allows for
          larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutRequests {
                tailf:snmp-name ipSystemStatsOutRequests;
        type yang:counter32;
        description
         "The total number of IP datagrams that local IP user-
          protocols (including ICMP) supplied to IP in requests for
          transmission.  Note that this counter does not include any
          datagrams counted in ipSystemStatsOutForwDatagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCOutRequests {
                tailf:snmp-name ipSystemStatsHCOutRequests;
        type yang:counter64;
        description
         "The total number of IP datagrams that local IP user-
          protocols (including ICMP) supplied to IP in requests for
          transmission.  This object counts the same packets as
          ipSystemStatsOutRequests, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutNoRoutes {
                tailf:snmp-name ipSystemStatsOutNoRoutes;
        type yang:counter32;
        description
         "The number of locally generated IP datagrams discarded
          because no route could be found to transmit them to their
          destination.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutForwDatagrams {
                tailf:snmp-name ipSystemStatsOutForwDatagrams;
        type yang:counter32;
        description
         "The number of datagrams for which this entity was not their
          final IP destination and for which it was successful in
          finding a path to their final destination.  In entities
          that do not act as IP routers, this counter will include
          only those datagrams that were Source-Routed via this
          entity, and the Source-Route processing was successful.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          forwarded datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCOutForwDatagrams {
                tailf:snmp-name ipSystemStatsHCOutForwDatagrams;
        type yang:counter64;
        description
         "The number of datagrams for which this entity was not their
          final IP destination and for which it was successful in
          finding a path to their final destination.  This object
          counts the same packets as ipSystemStatsOutForwDatagrams,
          but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutDiscards {
                tailf:snmp-name ipSystemStatsOutDiscards;
        type yang:counter32;
        description
         "The number of output IP datagrams for which no problem was
          encountered to prevent their transmission to their
          destination, but were discarded (e.g., for lack of
          buffer space).  Note that this counter would include
          datagrams counted in ipSystemStatsOutForwDatagrams if any
          such datagrams met this (discretionary) discard criterion.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutFragReqds {
                tailf:snmp-name ipSystemStatsOutFragReqds;
        type yang:counter32;
        description
         "The number of IP datagrams that would require fragmentation
          in order to be transmitted.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutFragOKs {
                tailf:snmp-name ipSystemStatsOutFragOKs;
        type yang:counter32;
        description
         "The number of IP datagrams that have been successfully
          fragmented.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutFragFails {
                tailf:snmp-name ipSystemStatsOutFragFails;
        type yang:counter32;
        description
         "The number of IP datagrams that have been discarded because
          they needed to be fragmented but could not be.  This
          includes IPv4 packets that have the DF bit set and IPv6
          packets that are being forwarded and exceed the outgoing
          link MTU.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for an unsuccessfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutFragCreates {
                tailf:snmp-name ipSystemStatsOutFragCreates;
        type yang:counter32;
        description
         "The number of output datagram fragments that have been
          generated as a result of IP fragmentation.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutTransmits {
                tailf:snmp-name ipSystemStatsOutTransmits;
        type yang:counter32;
        description
         "The total number of IP datagrams that this entity supplied
          to the lower layers for transmission.  This includes
          datagrams generated locally and those forwarded by this
          entity.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCOutTransmits {
                tailf:snmp-name ipSystemStatsHCOutTransmits;
        type yang:counter64;
        description
         "The total number of IP datagrams that this entity supplied
          to the lower layers for transmission.  This object counts
          the same datagrams as ipSystemStatsOutTransmits, but allows
          for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutOctets {
        type yang:counter32;
        description
         "The total number of octets in IP datagrams delivered to the
          lower layers for transmission.  Octets from datagrams
          counted in ipSystemStatsOutTransmits MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCOutOctets {
        type yang:counter64;
        description
         "The total number of octets in IP datagrams delivered to the
          lower layers for transmission.  This objects counts the same
          octets as ipSystemStatsOutOctets, but allows for larger
          values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInMcastPkts {
                tailf:snmp-name ipSystemStatsInMcastPkts;
        type yang:counter32;
        description
         "The number of IP multicast datagrams received.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCInMcastPkts {
                tailf:snmp-name ipSystemStatsHCInMcastPkts;
        type yang:counter64;
        description
         "The number of IP multicast datagrams received.  This object
          counts the same datagrams as ipSystemStatsInMcastPkts but
          allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInMcastOctets {
        type yang:counter32;
        description
         "The total number of octets received in IP multicast
          datagrams.  Octets from datagrams counted in
          ipSystemStatsInMcastPkts MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCInMcastOctets {
        type yang:counter64;
        description
         "The total number of octets received in IP multicast
          datagrams.  This object counts the same octets as
          ipSystemStatsInMcastOctets, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutMcastPkts {
                tailf:snmp-name ipSystemStatsOutMcastPkts;
        type yang:counter32;
        description
         "The number of IP multicast datagrams transmitted.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCOutMcastPkts {
                tailf:snmp-name ipSystemStatsHCOutMcastPkts;
        type yang:counter64;
        description
         "The number of IP multicast datagrams transmitted.  This
          object counts the same datagrams as
          ipSystemStatsOutMcastPkts, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutMcastOctets {
        type yang:counter32;
        description
         "The total number of octets transmitted in IP multicast
          datagrams.  Octets from datagrams counted in
          ipSystemStatsOutMcastPkts MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCOutMcastOctets {
        type yang:counter64;
        description
         "The total number of octets transmitted in IP multicast
          datagrams.  This object counts the same octets as
          ipSystemStatsOutMcastOctets, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsInBcastPkts {
                tailf:snmp-name ipSystemStatsInBcastPkts;
        type yang:counter32;
        description
         "The number of IP broadcast datagrams received.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCInBcastPkts {
                tailf:snmp-name ipSystemStatsHCInBcastPkts;
        type yang:counter64;
        description
         "The number of IP broadcast datagrams received.  This object
          counts the same datagrams as ipSystemStatsInBcastPkts but
          allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsOutBcastPkts {
                tailf:snmp-name ipSystemStatsOutBcastPkts;
        type yang:counter32;
        description
         "The number of IP broadcast datagrams transmitted.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsHCOutBcastPkts {
                tailf:snmp-name ipSystemStatsHCOutBcastPkts;
        type yang:counter64;
        description
         "The number of IP broadcast datagrams transmitted.  This
          object counts the same datagrams as
          ipSystemStatsOutBcastPkts, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipSystemStatsDiscontinuityTime.";
      }

      leaf ipSystemStatsDiscontinuityTime {
                tailf:snmp-name ipSystemStatsDiscontinuityTime;
        type yang:timestamp;
        description
         "The value of sysUpTime on the most recent occasion at which
          any one or more of this entry's counters suffered a
          discontinuity.

          If no such discontinuities have occurred since the last re-
          initialization of the local management subsystem, then this
          object contains a zero value.";
      }

      leaf ipSystemStatsRefreshRate {
                tailf:snmp-name ipSystemStatsRefreshRate;
        type uint32;
        units "milli-seconds";
        description
         "The minimum reasonable polling interval for this entry.
          This object provides an indication of the minimum amount of
          time required to update the counters in this entry.";
      }
    }

    leaf ipIfStatsTableLastChange {
      tailf:snmp-name ipIfStatsTableLastChange;
      type yang:timestamp;
      description
       "The value of sysUpTime on the most recent occasion at which
        a row in the ipIfStatsTable was added or deleted.

        If new objects are added to the ipIfStatsTable that require
        the ipIfStatsTableLastChange to be updated when they are
        modified, they must specify that requirement in their
        description clause.";
    }


    /* XXX table comments here XXX */

    list ipIfStatsEntry {

      tailf:callpoint ip_traf_if_stats;
          tailf:sort-order snmp;
          tailf:snmp-oid 1.3.6.1.2.1.4.31.3;
      key "ipIfStatsIPVersion ipIfStatsIfIndex";
      description
       "An interface statistics entry containing objects for a
        particular interface and version of IP.";


      leaf ipIfStatsIPVersion {
                tailf:snmp-name ipIfStatsIPVersion;
        type inet-address:InetVersion;
        description
         "The IP version of this row.";
      }

      leaf ipIfStatsIfIndex {
                tailf:snmp-name ipIfStatsIfIndex;
        type if-mib:InterfaceIndex;
        description
         "The index value that uniquely identifies the interface to
          which this entry is applicable.  The interface identified by
          a particular value of this index is the same interface as
          identified by the same value of the IF-MIB's ifIndex.";
      }

      leaf ipIfStatsInReceives {
                tailf:snmp-name ipIfStatsInReceives;
        type yang:counter32;
        description
         "The total number of input IP datagrams received, including
          those received in error.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCInReceives {
                tailf:snmp-name ipIfStatsHCInReceives;
        type yang:counter64;
        description
         "The total number of input IP datagrams received, including
          those received in error.  This object counts the same
          datagrams as ipIfStatsInReceives, but allows for larger
          values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInOctets {
                tailf:snmp-name ipIfStatsInOctets;
        type yang:counter32;
        description
         "The total number of octets received in input IP datagrams,
          including those received in error.  Octets from datagrams
          counted in ipIfStatsInReceives MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCInOctets {
                tailf:snmp-name ipIfStatsHCInOctets;
        type yang:counter64;
        description
         "The total number of octets received in input IP datagrams,
          including those received in error.  This object counts the
          same octets as ipIfStatsInOctets, but allows for larger
          values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInHdrErrors {
                tailf:snmp-name ipIfStatsInHdrErrors;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded due to errors in
          their IP headers, including version number mismatch, other
          format errors, hop count exceeded, errors discovered in
          processing their IP options, etc.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInNoRoutes {
                tailf:snmp-name ipIfStatsInNoRoutes;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded because no route
          could be found to transmit them to their destination.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInAddrErrors {
                tailf:snmp-name ipIfStatsInAddrErrors;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded because the IP
          address in their IP header's destination field was not a
          valid address to be received at this entity.  This count
          includes invalid addresses (e.g., ::0).  For entities that
          are not IP routers and therefore do not forward datagrams,
          this counter includes datagrams discarded because the
          destination address was not a local address.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInUnknownProtos {
                tailf:snmp-name ipIfStatsInUnknownProtos;
        type yang:counter32;
        description
         "The number of locally-addressed IP datagrams received
          successfully but discarded because of an unknown or
          unsupported protocol.

          When tracking interface statistics, the counter of the
          interface to which these datagrams were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the datagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInTruncatedPkts {
                tailf:snmp-name ipIfStatsInTruncatedPkts;
        type yang:counter32;
        description
         "The number of input IP datagrams discarded because the
          datagram frame didn't carry enough data.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInForwDatagrams {
                tailf:snmp-name ipIfStatsInForwDatagrams;
        type yang:counter32;
        description
         "The number of input datagrams for which this entity was not
          their final IP destination and for which this entity
          attempted to find a route to forward them to that final
          destination.  In entities that do not act as IP routers,
          this counter will include only those datagrams that were
          Source-Routed via this entity, and the Source-Route
          processing was successful.

          When tracking interface statistics, the counter of the
          incoming interface is incremented for each datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCInForwDatagrams {
                tailf:snmp-name ipIfStatsHCInForwDatagrams;
        type yang:counter64;
        description
         "The number of input datagrams for which this entity was not
          their final IP destination and for which this entity
          attempted to find a route to forward them to that final
          destination.  This object counts the same packets as
          ipIfStatsInForwDatagrams, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsReasmReqds {
                tailf:snmp-name ipIfStatsReasmReqds;
        type yang:counter32;
        description
         "The number of IP fragments received that needed to be
          reassembled at this interface.

          When tracking interface statistics, the counter of the
          interface to which these fragments were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the fragments.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsReasmOKs {
                tailf:snmp-name ipIfStatsReasmOKs;
        type yang:counter32;
        description
         "The number of IP datagrams successfully reassembled.

          When tracking interface statistics, the counter of the
          interface to which these datagrams were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the datagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsReasmFails {
                tailf:snmp-name ipIfStatsReasmFails;
        type yang:counter32;
        description
         "The number of failures detected by the IP re-assembly
          algorithm (for whatever reason: timed out, errors, etc.).
          Note that this is not necessarily a count of discarded IP
          fragments since some algorithms (notably the algorithm in
          RFC 815) can lose track of the number of fragments by
          combining them as they are received.

          When tracking interface statistics, the counter of the
          interface to which these fragments were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the fragments.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInDiscards {
                tailf:snmp-name ipIfStatsInDiscards;
        type yang:counter32;
        description
         "The number of input IP datagrams for which no problems were
          encountered to prevent their continued processing, but
          were discarded (e.g., for lack of buffer space).  Note that
          this counter does not include any datagrams discarded while
          awaiting re-assembly.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInDelivers {
                tailf:snmp-name ipIfStatsInDelivers;
        type yang:counter32;
        description
         "The total number of datagrams successfully delivered to IP
          user-protocols (including ICMP).

          When tracking interface statistics, the counter of the
          interface to which these datagrams were addressed is
          incremented.  This interface might not be the same as the
          input interface for some of the datagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCInDelivers {
                tailf:snmp-name ipIfStatsHCInDelivers;
        type yang:counter64;
        description
         "The total number of datagrams successfully delivered to IP
          user-protocols (including ICMP).  This object counts the
          same packets as ipIfStatsInDelivers, but allows for larger
          values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutRequests {
                tailf:snmp-name ipIfStatsOutRequests;
        type yang:counter32;
        description
         "The total number of IP datagrams that local IP user-
          protocols (including ICMP) supplied to IP in requests for
          transmission.  Note that this counter does not include any
          datagrams counted in ipIfStatsOutForwDatagrams.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCOutRequests {
                tailf:snmp-name ipIfStatsHCOutRequests;
        type yang:counter64;
        description
         "The total number of IP datagrams that local IP user-
          protocols (including ICMP) supplied to IP in requests for
          transmission.  This object counts the same packets as
          ipIfStatsOutRequests, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutForwDatagrams {
                tailf:snmp-name ipIfStatsOutForwDatagrams;
        type yang:counter32;
        description
         "The number of datagrams for which this entity was not their
          final IP destination and for which it was successful in
          finding a path to their final destination.  In entities
          that do not act as IP routers, this counter will include
          only those datagrams that were Source-Routed via this
          entity, and the Source-Route processing was successful.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          forwarded datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCOutForwDatagrams {
                tailf:snmp-name ipIfStatsHCOutForwDatagrams;
        type yang:counter64;
        description
         "The number of datagrams for which this entity was not their
          final IP destination and for which it was successful in
          finding a path to their final destination.  This object
          counts the same packets as ipIfStatsOutForwDatagrams, but
          allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutDiscards {
                tailf:snmp-name ipIfStatsOutDiscards;
        type yang:counter32;
        description
         "The number of output IP datagrams for which no problem was
          encountered to prevent their transmission to their
          destination, but were discarded (e.g., for lack of
          buffer space).  Note that this counter would include
          datagrams counted in ipIfStatsOutForwDatagrams if any such
          datagrams met this (discretionary) discard criterion.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutFragReqds {
                tailf:snmp-name ipIfStatsOutFragReqds;
        type yang:counter32;
        description
         "The number of IP datagrams that would require fragmentation
          in order to be transmitted.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutFragOKs {
                tailf:snmp-name ipIfStatsOutFragOKs;
        type yang:counter32;
        description
         "The number of IP datagrams that have been successfully
          fragmented.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutFragFails {
                tailf:snmp-name ipIfStatsOutFragFails;
        type yang:counter32;
        description
         "The number of IP datagrams that have been discarded because
          they needed to be fragmented but could not be.  This
          includes IPv4 packets that have the DF bit set and IPv6
          packets that are being forwarded and exceed the outgoing
          link MTU.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for an unsuccessfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutFragCreates {
                tailf:snmp-name ipIfStatsOutFragCreates;
        type yang:counter32;
        description
         "The number of output datagram fragments that have been
          generated as a result of IP fragmentation.

          When tracking interface statistics, the counter of the
          outgoing interface is incremented for a successfully
          fragmented datagram.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutTransmits {
                tailf:snmp-name ipIfStatsOutTransmits;
        type yang:counter32;
        description
         "The total number of IP datagrams that this entity supplied
          to the lower layers for transmission.  This includes
          datagrams generated locally and those forwarded by this
          entity.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCOutTransmits {
                tailf:snmp-name ipIfStatsHCOutTransmits;
        type yang:counter64;
        description
         "The total number of IP datagrams that this entity supplied
          to the lower layers for transmission.  This object counts
          the same datagrams as ipIfStatsOutTransmits, but allows for
          larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutOctets {
                tailf:snmp-name ipIfStatsOutOctets;
        type yang:counter32;
        description
         "The total number of octets in IP datagrams delivered to the
          lower layers for transmission.  Octets from datagrams
          counted in ipIfStatsOutTransmits MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCOutOctets {
                tailf:snmp-name ipIfStatsHCOutOctets;
        type yang:counter64;
        description
         "The total number of octets in IP datagrams delivered to the
          lower layers for transmission.  This objects counts the same
          octets as ipIfStatsOutOctets, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInMcastPkts {
                tailf:snmp-name ipIfStatsInMcastPkts;
        type yang:counter32;
        description
         "The number of IP multicast datagrams received.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCInMcastPkts {
                tailf:snmp-name ipIfStatsHCInMcastPkts;
        type yang:counter64;
        description
         "The number of IP multicast datagrams received.  This object
          counts the same datagrams as ipIfStatsInMcastPkts, but
          allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInMcastOctets {
                tailf:snmp-name ipIfStatsInMcastOctets;
        type yang:counter32;
        description
         "The total number of octets received in IP multicast
          datagrams.  Octets from datagrams counted in
          ipIfStatsInMcastPkts MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCInMcastOctets {
                tailf:snmp-name ipIfStatsHCInMcastOctets;
        type yang:counter64;
        description
         "The total number of octets received in IP multicast
          datagrams.  This object counts the same octets as
          ipIfStatsInMcastOctets, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutMcastPkts {
                tailf:snmp-name ipIfStatsOutMcastPkts;
        type yang:counter32;
        description
         "The number of IP multicast datagrams transmitted.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCOutMcastPkts {
                tailf:snmp-name ipIfStatsHCOutMcastPkts;
        type yang:counter64;
        description
         "The number of IP multicast datagrams transmitted.  This
          object counts the same datagrams as ipIfStatsOutMcastPkts,
          but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutMcastOctets {
                tailf:snmp-name ipIfStatsOutMcastOctets;
        type yang:counter32;
        description
         "The total number of octets transmitted in IP multicast
          datagrams.  Octets from datagrams counted in
          ipIfStatsOutMcastPkts MUST be counted here.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCOutMcastOctets {
                tailf:snmp-name ipIfStatsHCOutMcastOctets;
        type yang:counter64;
        description
         "The total number of octets transmitted in IP multicast
          datagrams.  This object counts the same octets as
          ipIfStatsOutMcastOctets, but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsInBcastPkts {
                tailf:snmp-name ipIfStatsInBcastPkts;
        type yang:counter32;
        description
         "The number of IP broadcast datagrams received.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCInBcastPkts {
                tailf:snmp-name ipIfStatsHCInBcastPkts;
        type yang:counter64;
        description
         "The number of IP broadcast datagrams received.  This object
          counts the same datagrams as ipIfStatsInBcastPkts, but
          allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsOutBcastPkts {
                tailf:snmp-name ipIfStatsOutBcastPkts;
        type yang:counter32;
        description
         "The number of IP broadcast datagrams transmitted.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsHCOutBcastPkts {
                tailf:snmp-name ipIfStatsHCOutBcastPkts;
        type yang:counter64;
        description
         "The number of IP broadcast datagrams transmitted.  This
          object counts the same datagrams as ipIfStatsOutBcastPkts,
          but allows for larger values.

          Discontinuities in the value of this counter can occur at
          re-initialization of the management system, and at other
          times as indicated by the value of
          ipIfStatsDiscontinuityTime.";
      }

      leaf ipIfStatsDiscontinuityTime {
                tailf:snmp-name ipIfStatsDiscontinuityTime;
        type yang:timestamp;
        description
         "The value of sysUpTime on the most recent occasion at which
          any one or more of this entry's counters suffered a
          discontinuity.

          If no such discontinuities have occurred since the last re-
          initialization of the local management subsystem, then this
          object contains a zero value.";
      }

      leaf ipIfStatsRefreshRate {
                tailf:snmp-name ipIfStatsRefreshRate;
        type uint32;
        units "milli-seconds";
        description
         "The minimum reasonable polling interval for this entry.
          This object provides an indication of the minimum amount of
          time required to update the counters in this entry.";
      }
    }
  }

  container icmp {
    config false;
    tailf:callpoint icmp_status;

//    leaf icmpInMsgs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The total number of ICMP messages which the entity received.
//        Note that this counter includes all those counted by
//        icmpInErrors.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        icmpStatsInMsgs.";
//    }

//    leaf icmpInErrors {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP messages which the entity received but
//        determined as having ICMP-specific errors (bad ICMP
//        checksums, bad length, etc.).

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        icmpStatsInErrors.";
//    }

//    leaf icmpInDestUnreachs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Destination Unreachable messages
//        received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInTimeExcds {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Time Exceeded messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInParmProbs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Parameter Problem messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInSrcQuenchs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Source Quench messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInRedirects {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Redirect messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInEchos {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Echo (request) messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInEchoReps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Echo Reply messages received.
//
//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInTimestamps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Timestamp (request) messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInTimestampReps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Timestamp Reply messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInAddrMasks {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Address Mask Request messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpInAddrMaskReps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Address Mask Reply messages received.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutMsgs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The total number of ICMP messages which this entity
//        attempted to send.  Note that this counter includes all
//        those counted by icmpOutErrors.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        icmpStatsOutMsgs.";
//    }

//    leaf icmpOutErrors {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP messages which this entity did not send
//        due to problems discovered within ICMP, such as a lack of
//        buffers.  This value should not include errors discovered
//        outside the ICMP layer, such as the inability of IP to route
//        the resultant datagram.  In some implementations, there may
//        be no types of error which contribute to this counter's
//        value.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by
//        icmpStatsOutErrors.";
//    }

//    leaf icmpOutDestUnreachs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Destination Unreachable messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutTimeExcds {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Time Exceeded messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutParmProbs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Parameter Problem messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutSrcQuenchs {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Source Quench messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutRedirects {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Redirect messages sent.  For a host, this
//        object will always be zero, since hosts do not send
//        redirects.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutEchos {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Echo (request) messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutEchoReps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Echo Reply messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutTimestamps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Timestamp (request) messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutTimestampReps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Timestamp Reply messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutAddrMasks {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Address Mask Request messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }

//    leaf icmpOutAddrMaskReps {
//      type yang:counter32;
//      status deprecated;
//      description
//       "The number of ICMP Address Mask Reply messages sent.

//        This object has been deprecated, as a new IP version-neutral
//        table has been added.  It is loosely replaced by a column in
//        the icmpMsgStatsTable.";
//    }


    /* XXX table comments here XXX */

   list icmpStatsEntry {
    tailf:callpoint icmp_stat_status;
     tailf:snmp-oid 1.3.6.1.2.1.5.29;
     tailf:sort-order snmp;

     key "icmpStatsIPVersion";
     description
      "A conceptual row in the icmpStatsTable.";


     leaf icmpStatsIPVersion {
       tailf:snmp-name icmpStatsIPVersion;
       type inet-address:InetVersion;
       description
        "The IP version of the statistics.";
     }

     leaf icmpStatsInMsgs {
       tailf:snmp-name icmpStatsInMsgs;
       type yang:counter32;
       description
        "The total number of ICMP messages that the entity received.
         Note that this counter includes all those counted by
         icmpStatsInErrors.";
     }

     leaf icmpStatsInErrors {
       tailf:snmp-name icmpStatsInErrors;
       type yang:counter32;
       description
        "The number of ICMP messages that the entity received but
         determined as having ICMP-specific errors (bad ICMP
         checksums, bad length, etc.).";
     }

     leaf icmpStatsOutMsgs {
       tailf:snmp-name icmpStatsOutMsgs;
       type yang:counter32;
       description
        "The total number of ICMP messages that the entity attempted
         to send.  Note that this counter includes all those counted
         by icmpStatsOutErrors.";
     }

     leaf icmpStatsOutErrors {
       tailf:snmp-name icmpStatsOutErrors;
       type yang:counter32;
       description
        "The number of ICMP messages that this entity did not send
         due to problems discovered within ICMP, such as a lack of
         buffers.  This value should not include errors discovered
         outside the ICMP layer, such as the inability of IP to route
         the resultant datagram.  In some implementations, there may
         be no types of error that contribute to this counter's
         value.";
     }
   }


    /* XXX table comments here XXX */

   list icmpMsgStatsEntry {
    tailf:callpoint icmp_msg_status;
     tailf:snmp-oid 1.3.6.1.2.1.5.30;
     tailf:sort-order snmp;

     key "icmpMsgStatsIPVersion icmpMsgStatsType";
     description
      "A conceptual row in the icmpMsgStatsTable.

       The system should track each ICMP type value, even if that
       ICMP type is not supported by the system.  However, a
       given row need not be instantiated unless a message of that
       type has been processed, i.e., the row for
       icmpMsgStatsType=X MAY be instantiated before but MUST be
       instantiated after the first message with Type=X is
       received or transmitted.  After receiving or transmitting
       any succeeding messages with Type=X, the relevant counter
       must be incremented.";


     leaf icmpMsgStatsIPVersion {
       tailf:snmp-name icmpMsgStatsIPVersion;
       type inet-address:InetVersion;
       description
        "The IP version of the statistics.";
     }

     leaf icmpMsgStatsType {
       tailf:snmp-name icmpMsgStatsType;
       type int32 {
         range "0..255";
       }
       description
        "The ICMP type field of the message type being counted by
         this row.

         Note that ICMP message types are scoped by the address type
         in use.";
       reference
        "http://www.iana.org/assignments/icmp-parameters and
         http://www.iana.org/assignments/icmpv6-parameters";
     }

     leaf icmpMsgStatsInPkts {
       tailf:snmp-name icmpMsgStatsInPkts;
       type yang:counter32;
       description
        "The number of input packets for this AF and type.";
     }

     leaf icmpMsgStatsOutPkts {
       tailf:snmp-name icmpMsgStatsOutPkts;
       type yang:counter32;
       description
        "The number of output packets for this AF and type.";
     }
   }
 }

} /* end of module IP-MIB */
