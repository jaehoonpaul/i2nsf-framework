<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>confd_lib_cdb</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="ConfD User Guide"><link rel="up" href="rn02.html" title="ConfD man-pages, Volume 3"><link rel="prev" href="rn02re08.html" title="confd_lib"><link rel="next" href="rn02re10.html" title="confd_lib_dp"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">confd_lib_cdb</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="rn02re08.html">Prev</a>&nbsp;</td><th width="60%" align="center">ConfD man-pages, Volume 3</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="rn02re10.html">Next</a></td></tr></table><hr></div><div class="refentry"><a name="man.3.confd_lib_cdb"></a><div class="titlepage"></div><div class="refnamediv"><a name="man.3.confd_lib_cdb.name"></a><h2>Name</h2><p>confd_lib_cdb &#8212; library for connecting to ConfD built-in XML database
    (CDB)</p></div><div class="refsynopsisdiv"><a name="man.3.confd_lib_cdb.synopsis"></a><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;confd_lib.h&gt;
#include &lt;confd_cdb.h&gt;
      </pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_connect</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sock_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>const struct sockaddr* <var class="pdparam">srv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">srv_sz</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_connect_name</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sock_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>const struct sockaddr* <var class="pdparam">srv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">srv_sz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_mandatory_subscriber</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_namespace</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">hashed_ns</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_end_session</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_start_session</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_db_type <var class="pdparam">db</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_start_session2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_db_type <var class="pdparam">db</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_close</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_wait_start</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_phase</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_phase *<var class="pdparam">phase</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_txid</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_txid *<var class="pdparam">txid</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_initiate_journal_compaction</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_load_file</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">filename</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_load_str</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">xml_str</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_user_session</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_transaction_handle</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_timeout</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_exists</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_cd</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_pushd</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_popd</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_getcwd</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>size_t <var class="pdparam">strsz</var>, </td></tr><tr><td>&nbsp;</td><td>char *<var class="pdparam">curdir</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_getcwd_kpath</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_hkeypath_t **<var class="pdparam">kp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_num_instances</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_next_index</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_index</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_is_default</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_subscribe2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sub_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">priority</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">spoint</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nspace</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_subscribe</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">priority</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nspace</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">spoint</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_oper_subscribe</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nspace</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">spoint</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_subscribe_done</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_trigger_subscriptions</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">len</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_trigger_oper_subscriptions</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">len</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_diff_match</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>struct xml_tag <var class="pdparam">tags[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">tagslen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_read_subscription_socket</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">resultlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_read_subscription_socket2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sub_notification *<var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">subpoints[]</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">resultlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_replay_subscriptions</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_txid *<var class="pdparam">txid</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">len</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_replay_txids</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_txid **<var class="pdparam">txid</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">resultlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_diff_iterate</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_ret (*<var class="pdparam">iter</var>)(confd_hkeypath_t *<var class="pdparam">kp</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_op <var class="pdparam">op</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">oldv</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">newv</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">state</var>), </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">initstate</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_diff_iterate_resume</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_ret <var class="pdparam">reply</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_ret (*<var class="pdparam">iter</var>)(                                       confd_hkeypath_t *<var class="pdparam">kp</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_op <var class="pdparam">op</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">oldv</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">newv</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">state</var>), </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">resumestate</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_cli_diff_iterate</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>cli_diff_iter_function_t *<var class="pdparam">iter</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">initstate</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_modifications</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">nvalues</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_modifications_iter</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_modifications_cli</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">str</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sync_subscription_socket</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_subscription_sync_type <var class="pdparam">st</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sub_progress</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sub_abort_trans</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sub_abort_trans_info</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_case</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">choice</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">rcase</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int8</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int8_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int16</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int16_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int32</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int64_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int8</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int8_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int16</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int16_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int32</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int64_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bit32</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bit64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int64_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bitbig</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv4</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct in_addr *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv6</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct in6_addr *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_double</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>double *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bool</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_datetime</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_date</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_date *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_time</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_time *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_duration</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_duration *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_enum_value</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_objectref</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_hkeypath_t **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_oid</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_snmp_oid **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_buf</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_buf2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_str</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>char *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_binary</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_hexstr</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_qname</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">prefix</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">prefixsz</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">name</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">namesz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_list</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv4prefix</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv4_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv6prefix</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv6_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_decimal64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_decimal64 *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_identityref</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_identityref *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv4_and_plen</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv4_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv6_and_plen</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv6_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_dquad</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_dotted_quad *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_vget</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>va_list <var class="pdparam">args</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_object</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_objects</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">ix</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nobj</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_values</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_elem</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">val</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_elem2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">strval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_vset_elem</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">val</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>va_list <var class="pdparam">args</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_case</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">choice</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">scase</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_create</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_delete</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_object</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_values</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div></div><div class="refsect1"><a name="man.3.confd_lib_cdb.library"></a><h2>LIBRARY</h2><p>ConfD Library, (<code class="filename">libconfd</code>,
    <code class="option">-lconfd</code>)</p></div><div class="refsect1"><a name="man.3.confd_lib_cdb.description"></a><h2>DESCRIPTION</h2><p>The <code class="filename">libconfd</code> shared library is used to
    connect to the ConfD built-in XML database, CDB. The purpose of
    this API is to provide a read and subscription API to CDB.</p><p>CDB owns and stores the configuration data and the user of
    the API wants to read that configuration data and also get
    notified when someone through either NETCONF, SNMP, the CLI, the
    Web UI or the MAAPI modifies the data so that the application can
    re-read the configuration data and act accordingly.</p><p>CDB can also store operational data, i.e. data which is
    designated with a <code class="code">"config false"</code> statement in the YANG
    data model. Operational data can be both read and written by the
    applications, but NETCONF and the other northbound agents can only
    read the operational data.</p></div><div class="refsect1"><a name="man.3.confd_lib_cdb.paths"></a><h2>PATHS</h2><p>The majority of the functions described here take as their
    two last arguments a format string and a variable number of extra
    arguments as in: <span class="type">char *</span><em class="parameter"><code>fmt</code></em>,
    <em class="parameter"><code>...</code></em><code class="code">);</code></p><p>The <em class="parameter"><code>fmt</code></em> is a printf style format
    string which is used to format a path into the XML data tree.
    Assume the following YANG fragment:</p><div class="informalexample"><pre class="programlisting">
container hosts {
  list host {
    key name;
    leaf name {
      type string;
    }
    leaf domain {
      type string;
    }
    leaf defgw {
      type inet:ipv4-address;
    }
    container interfaces {
      list interface {
        key name;
        leaf name {
          type string;
        }
        leaf ip {
          type inet:ipv4-address;
        }
        leaf mask {
          type inet:ipv4-address;
        }
        leaf enabled {
          type boolean;
        }
      }
    }
  }
}</pre></div><p>Furthermore, assuming our database is populated with the
    following data.</p><div class="informalexample"><pre class="programlisting">
&lt;hosts xmlns="http://example.com/ns/hst/1.0"&gt;
  &lt;host&gt;
    &lt;name&gt;buzz&lt;/name&gt;
    &lt;domain&gt;tail-f.com&lt;/domain&gt;
    &lt;defgw&gt;192.168.1.1&lt;/defgw&gt;
    &lt;interfaces&gt;
      &lt;interface&gt;
        &lt;name&gt;eth0&lt;/name&gt;
        &lt;ip&gt;192.168.1.61&lt;/ip&gt;
        &lt;mask&gt;255.255.255.0&lt;/mask&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
      &lt;/interface&gt;
      &lt;interface&gt;
        &lt;name&gt;eth1&lt;/name&gt;
        &lt;ip&gt;10.77.1.44&lt;/ip&gt;
        &lt;mask&gt;255.255.0.0&lt;/mask&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/interface&gt;
    &lt;/interfaces&gt;
  &lt;/host&gt;
&lt;/hosts&gt;</pre></div><p>The format path <code class="sgmltag-element">/hosts/host{buzz}/defgw</code> refers to
    the leaf called <code class="sgmltag-element">defgw</code> of the host whose key
    (<code class="sgmltag-element">name</code> leaf) is <code class="literal">buzz</code>.</p><p>The format path
    <code class="sgmltag-element">/hosts/host{buzz}/interfaces/interface{eth0}/ip</code> refers
    to the leaf called <code class="sgmltag-element">ip</code> in the
    <code class="literal">eth0</code> interface of the host called
    <code class="literal">buzz</code>.</p><p>It is possible loop through all entries in a list as in:</p><div class="informalexample"><pre class="programlisting">n = cdb_num_instances(sock, "/hosts/host");
for (i=0; i&lt;n; i++) {
    cdb_cd(sock, "/hosts/host[%d]", i)
    .....</pre></div><p>Thus instead of an actually instantiated key inside a pair
    of curly braces <code class="sgmltag-element">{key}</code>, we can use a temporary integer
    key inside a pair of brackets <code class="code">[n]</code>.</p><p>We can use the following modifiers:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">%d</span></dt><dd><p>requiring an integer parameter (type <span class="type">int</span>)
          to be substituted.</p></dd><dt><span class="term">%u</span></dt><dd><p>requiring an unsigned integer parameter (type <span class="type">unsigned
          int</span>) to be substituted.</p></dd><dt><span class="term">%s</span></dt><dd><p>requiring a <span class="type">char*</span> string parameter to be
          substituted.</p></dd><dt><span class="term">%ip4</span></dt><dd><p>requiring a <span class="type">struct in_addr*</span> to be
          substituted.</p></dd><dt><span class="term">%ip6</span></dt><dd><p>requiring a <span class="type">struct in6_addr*</span> to be
          substituted.</p></dd><dt><span class="term">%x</span></dt><dd><p>requiring a <span class="type">confd_value_t*</span> to be
          substituted.</p></dd><dt><span class="term">%*x</span></dt><dd><p>requiring an array length and a
          <span class="type">confd_value_t*</span> pointing to an array of values to
          be substituted.</p></dd><dt><span class="term">%h</span></dt><dd><p>requiring a <span class="type">confd_hkeypath_t*</span> to be
          substituted.</p></dd><dt><span class="term">%*h</span></dt><dd><p>requiring a length and a <span class="type">confd_hkeypath_t*</span>
          to be substituted.</p></dd></dl></div><p>Thus,</p><div class="informalexample"><pre class="programlisting">char *hname = "earth";
struct in_addr ip;
ip.s_addr = inet_addr("127.0.0.1");

cdb_cd(sock, "/hosts/host{%s}/bar{%ip4}", hname, &amp;ip);</pre></div><p>would change the current position to the path:
    <code class="sgmltag-element">"/hosts/host{earth}/bar{127.0.0.1}"</code></p><p>It is also possible to use the different '%' modifiers
    outside the curly braces, thus the above example could have been
    written as:</p><div class="informalexample"><pre class="programlisting">char *prefix = "/hosts/host";
cdb_cd(sock, "%s{%s}/bar{%ip4}", prefix, hname, &amp;ip);</pre></div><p>If an element has multiple keys, the keys must be space
    separated as in
    <code class="code">cdb_cd("/bars/bar{%s %d}/item", str, i);</code>. However the
    '%*x' modifier is an exception to this rule, and it is especially
    useful when we have a number of key values that are unknown at
    compile time. If we have a list <code class="sgmltag-element">foo</code> which is known
    to have two keys, and we have those keys in an array
    <code class="code">key[]</code>, we can use
    <code class="code">cdb_cd("/foo{%x %x}", &amp;key[0], &amp;key[1]);.</code>
    But if the number of keys is unknown at compile time (or if we just
    want a more compact code), we can instead
    use <code class="code">cdb_cd("/foo{%*x}", n, key);</code> where
    <em class="parameter"><code>n</code></em> is the number of keys.</p><p>The '%h' and '%*h' modifiers can only be used at the beginning of a
    format path, as they expand to the absolute path corresponding to
    the <span class="type">confd_hkeypath_t</span>. These modifiers are particularly
    useful with <code class="function">cdb_diff_iterate()</code> (see below),
    or for MAAPI access in data provider callbacks (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a> and
    <a class="link" href="rn02re10.html" title="confd_lib_dp">confd_lib_dp(3)</a>). The
    '%*h' variant allows for using only the initial part of a
    <span class="type">confd_hkeypath_t</span>, as specified by the preceding
    length argument (similar to '%.*s' for
    <code class="function">printf(3)</code>).</p><p>For example, if the <code class="function">iter()</code> function
    passed to <code class="function">cdb_diff_iterate()</code> has been invoked
    with a <span class="type">confd_hkeypath_t *kp</span> that corresponds to
    <code class="sgmltag-element">/hosts/host{buzz}</code>, we can read the <code class="sgmltag-element">defgw</code>
    child element with</p><div class="informalexample"><pre class="programlisting">confd_value_t v;
cdb_get(s, &amp;v, "%h/defgw", kp);</pre></div><p>or the entire list entry with</p><div class="informalexample"><pre class="programlisting">confd_value_t v[5];
cdb_get_object(sock, v, 5, "%h", kp);</pre></div><p>or the <code class="sgmltag-element">defgw</code> child element for host
    <code class="literal">mars</code> with</p><div class="informalexample"><pre class="programlisting">confd_value_t v;
cdb_get(s, &amp;v, "%*h{mars}/defgw", kp-&gt;len - 1, kp);</pre></div><p>All the functions that take a path on this form also have a
    <span class="type">va_list</span> variant, of the same form as
    <code class="function">cdb_vget()</code> and
    <code class="function">cdb_vset_elem()</code>, which are the only ones
    explicitly documented below. I.e. they have a prefix "cdb_v"
    instead of "cdb_", and take a single va_list argument instead of a
    variable number of arguments.</p></div><div class="refsect1"><a name="man.3.confd_lib_cdb.functions"></a><h2>FUNCTIONS</h2><p>All functions return CONFD_OK (0), CONFD_ERR (-1) or
    CONFD_EOF (-2) unless otherwise stated. CONFD_EOF
    means that the socket to ConfD has been closed.</p><p>Whenever CONFD_ERR is returned from any API function described
    here, it is possible to obtain additional information on the
    error through the symbol <code class="varname">confd_errno</code>, see the
    <a class="link" href="rn02re13.html#man.3.confd_lib_lib.errors" title="ERRORS">ERRORS</a>
    section in the <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>
    manual page.</p><div class="funcsynopsis"><a name="fn.cdb_connect"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_connect</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sock_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>const struct sockaddr* <var class="pdparam">srv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">srv_sz</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The application has to connect to ConfD before it can
    interact. There are two different types of connections identified
    by <span class="type">cdb_sock_type</span>:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CDB_DATA_SOCKET</code></span></dt><dd><p>This is a socket which is used to read configuration
          data, or to read and write operational data.</p></dd><dt><span class="term"><code class="constant">CDB_SUBSCRIPTION_SOCKET</code></span></dt><dd><p>This is a socket which is used to receive
          notifications about updates to the database. A subscription
          socket needs to be part of the application poll set.</p></dd></dl></div><p>Additionally the type CDB_READ_SOCKET is accepted for
    backwards compatibility - it is equivalent to
    CDB_DATA_SOCKET.</p><p>A call to <code class="function">cdb_connect()</code> is typically
    followed by a call to either
    <code class="function">cdb_start_session()</code> for a reading session or
    a call to <code class="function">cdb_subscribe()</code> for a subscription
    socket.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If this call fails (i.e. does not return CONFD_OK),
    the socket descriptor must be closed and a new socket created
    before the call is re-attempted.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_connect_name"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_connect_name</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sock_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>const struct sockaddr* <var class="pdparam">srv</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">srv_sz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>When we use <code class="function">cdb_connect()</code> to create a
    connection to ConfD/CDB, the <em class="parameter"><code>name</code></em> parameter
    passed to the library initialization function
    <code class="function">confd_init()</code> (see <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>) is used to
    identify the connection in status reports and logs. I we want
    different names to be used for different connections from the same
    application process, we can use
    <code class="function">cdb_connect_name()</code> with the wanted name instead
    of <code class="function">cdb_connect()</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If this call fails (i.e. does not return CONFD_OK),
    the socket descriptor must be closed and a new socket created
    before the call is re-attempted.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_mandatory_subscriber"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_mandatory_subscriber</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">name</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>
      Attaches a mandatory attribute and a mandatory name to the subscriber
      identified by <em class="parameter"><code>sock</code></em>. The
      <em class="parameter"><code>name</code></em> parameter is distinct from the name
      parameter in <code class="function">cdb_connect_name</code>.
    </p><p>
      CDB keeps a list of mandatory subscribers for infinite extent,
      i.e. until confd is restarted. The function is idempotent.
    </p><p>
      Absence of one or more mandatory subscribers will result in
      abort of all transactions. A mandatory subscriber must be
      present during the entire PREPARE delivery phase.
    </p><p>
      If a mandatory subscriber crashes during a PREPARE delivery phase,
      the subscriber should be restarted and the commit operation should be
      retried.
    </p><p>
      A mandatory subscriber is present if the subscriber has issued at
      least one <code class="function">cdb_subscribe2()</code> call followed by a
      <code class="function">cdb_subscribe_done()</code> call.
    </p><p>
      A call to <code class="function">cdb_mandatory_subscriber()</code> is
      only allowed before the first call of
      <code class="function">cdb_subscribe2()</code>.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          Only applicable for two-phase subscribers.
        </p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_set_namespace"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_namespace</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">hashed_ns</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>If we want to access data in CDB where the toplevel element
    name is not unique, we need to set the namespace. We are reading
    data related to a specific .fxs file. confdc can be used to generate
    a <span class="markup">.h</span> file with a #define for the namespace, by the
    flag <code class="option">--emit-h</code> to confdc (see <a class="link" href="rn01re06.html" title="confdc">confdc(1)</a>).</p><p>It is also possible to indicate which namespace to use through
    the namespace prefix when we read and write data. Thus the path
    <code class="sgmltag-element">/foo:bar/baz</code> will get us <code class="sgmltag-element">/bar/baz</code> in the
    namespace with prefix "foo" regardless of what the "set" namespace
    is. And if there is only one toplevel element called "bar" across
    all namespaces, we can use <code class="sgmltag-element">/bar/baz</code> without the prefix
    and without calling <code class="function">cdb_set_namespace()</code>.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_end_session"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_end_session</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>We use <code class="function">cdb_connect()</code> to establish a
    read socket to CDB. When the socket is closed, the read session is
    ended. We can reuse the same socket for another read session, but
    we must then end the session and create another session using
    <code class="function">cdb_start_session()</code>.</p><p>While we have a live CDB read session for configuration data,
    CDB is normally locked for
    writing. Thus all external entities trying to modify CDB are
    blocked as long as we have an open CDB read session. It is very
    important that we remember to either
    <code class="function">cdb_end_session()</code> or
    <code class="function">cdb_close()</code> once we have read what we wish to
    read.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_start_session"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_start_session</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_db_type <var class="pdparam">db</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Starts a new session on an already established socket to
    CDB. The db parameter should be one of:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CDB_RUNNING</code></span></dt><dd><p>Creates a read session towards the running
          database.</p></dd><dt><span class="term"><code class="constant">CDB_PRE_COMMIT_RUNNING</code></span></dt><dd><p>Creates a read session towards the running database as
          it was before the current transaction was committed. This is
          only possible between a subscription notification and the
          final
          <code class="function">cdb_sync_subscription_socket()</code>. At any
          other time trying to call
          <code class="function">cdb_start_session()</code> will fail with
          confd_errno set to CONFD_ERR_NOEXISTS.</p><p>In the case of a <code class="constant">CDB_SUB_PREPARE</code>
          subscription notification a session towards
          <code class="constant">CDB_PRE_COMMIT_RUNNING</code> will (in spite
          of the name) will return values as they were
          <span class="emphasis"><em>before the transaction which is about to be
          committed</em></span> took place. This means that if you want
          to read the new values during a
          <code class="constant">CDB_SUB_PREPARE</code> subscription
          notification you need to create a session towards
          <code class="constant">CDB_RUNNING</code>. However, since it is
          locked the session needs to be started in lockless mode
          using <code class="function">cdb_start_session2()</code>. So for
          example:</p><div class="informalexample"><pre class="programlisting">cdb_read_subscription_socket2(ss, &amp;type, &amp;flags, &amp;subp, &amp;len);
/* ... */
switch (type) {
case CDB_SUB_PREPARE:
    /* Set up a lockless session to read new values: */
    cdb_start_session2(s, CDB_RUNNING, 0);
    read_new_config(s);
    cdb_end_session(s);
    cdb_sync_subscription_socket(ss, CDB_DONE_PRIORITY);
    break;
    /* ... */</pre></div></dd><dt><span class="term"><code class="constant">CDB_STARTUP</code></span></dt><dd><p>Creates a read session towards the startup
          database.</p></dd><dt><span class="term"><code class="constant">CDB_OPERATIONAL</code></span></dt><dd><p>Creates a read/write session towards the operational
          database. For further details about working with operational
          data in CDB, see the <code class="constant">OPERATIONAL DATA</code>
          section below.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Subscriptions on operational data will not be
          triggered from a session created with this function - to
          trigger operational data subscriptions, we need to use
          <code class="function">cdb_start_session2()</code>, see
          below.</p></div></dd></dl></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_LOCKED, CONFD_ERR_NOEXISTS</p><p>If the error is CONFD_ERR_LOCKED it means that we are trying
    to create a new CDB read session precisely when the write phase of
    some transaction is occurring. Thus correct usage of
    <code class="function">cdb_start_session()</code> is:</p><div class="informalexample"><pre class="programlisting"> while (1) {
   if (cdb_start_session(sock, CDB_RUNNING) == CONFD_OK)
      break;
   if (confd_errno == CONFD_ERR_LOCKED) {
      sleep(1);
      continue;
   }
   .... handle error
}</pre></div><p>Alternatively we can use
    <code class="function">cdb_start_session2()</code> with
    <em class="parameter"><code>flags</code></em> = CDB_LOCK_SESSION|CDB_LOCK_WAIT. This
    means that the call will block until the lock has been acquired, and
    thus we do not need the retry loop.</p><div class="funcsynopsis"><a name="fn.cdb_start_session2"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_start_session2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_db_type <var class="pdparam">db</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function may be used instead of
    <code class="function">cdb_start_session()</code> if it is considered
    necessary to have more detailed control over some aspects of the
    CDB session - if in doubt, use
    <code class="function">cdb_start_session()</code> instead. The
    <em class="parameter"><code>sock</code></em> and <em class="parameter"><code>db</code></em>
    arguments are the same as for
    <code class="function">cdb_start_session()</code>, and these values can be
    used for <em class="parameter"><code>flags</code></em> (ORed together if more than
    one):</p><div class="informalexample"><pre class="programlisting">
#define CDB_LOCK_WAIT     (1 &lt;&lt; 0)
#define CDB_LOCK_SESSION  (1 &lt;&lt; 1)
#define CDB_LOCK_REQUEST  (1 &lt;&lt; 2)
#define CDB_LOCK_PARTIAL  (1 &lt;&lt; 3)</pre></div><p>The flags affect sessions for the different database types
    as follows:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CDB_RUNNING</code></span></dt><dd><p>CDB_LOCK_SESSION obtains a read lock for the complete
          session, i.e. using this flag alone is equivalent to calling
          <code class="function">cdb_start_session()</code>.  CDB_LOCK_REQUEST
          obtains a read lock only for the duration of each read
          request. This means that values of elements read in
          different requests may be inconsistent with each other, and
          the consequences of this must be carefully considered. In
          particular, the use of
          <code class="function">cdb_num_instances()</code> and the
          <code class="code">[n]</code> "integer index" notation in keypaths is
          inherently unsafe in this mode. Note: The implementation
          will not actually obtain a lock for a single-value request,
          since that is an atomic operation anyway. The CDB_LOCK_PARTIAL
          flag is not allowed.</p></dd><dt><span class="term"><code class="constant">CDB_STARTUP</code></span></dt><dd><p>Same as CDB_RUNNING.</p></dd><dt><span class="term"><code class="constant">CDB_PRE_COMMIT_RUNNING</code></span></dt><dd><p>This database type does not have any locks, which
          means that it is an error to call
          <code class="function">cdb_start_session2()</code> with any
          CDB_LOCK_XXX flag included in
          <em class="parameter"><code>flags</code></em>. Using a
          <em class="parameter"><code>flags</code></em> value of 0 is equivalent to
          calling <code class="function">cdb_start_session()</code>.</p></dd><dt><span class="term"><code class="constant">CDB_OPERATIONAL</code></span></dt><dd><p>CDB_LOCK_REQUEST obtains a "subscription lock" for the
          duration of each write request. This can be described as an
          "advisory exclusive" lock, i.e. only one client at a time
          can hold the lock (unless CDB_LOCK_PARTIAL is used), but the
          lock does not affect clients that
          do not attempt to obtain it. It also does not affect the
          reading of operational data. The purpose of this lock is to
          indicate that the client wants the write operation to
          generate subscription notifications. The lock remains in
          effect until any/all subscription notifications generated as
          a result of the write has been delivered.</p><p>If the CDB_LOCK_PARTIAL flag is used together with
          CDB_LOCK_REQUEST, the "subscription lock" only applies to the
          smallest data subtree that includes all the data in the write
          request. This means that multiple writes that generates
          subscription notifications, and delivery of the corresponding
          notifications, can proceed in parallel as long as they affect
          disjunct parts of the data tree.</p><p>The CDB_LOCK_SESSION flag is not allowed. Using a
          <em class="parameter"><code>flags</code></em> value of 0 is equivalent to
          calling <code class="function">cdb_start_session()</code>.</p></dd></dl></div><p>In all cases of using CDB_LOCK_SESSION or CDB_LOCK_REQUEST
    described above, adding the CDB_LOCK_WAIT flag means that instead
    of failing with CONFD_ERR_LOCKED if the lock can not be obtained
    immediately, requests will wait for the lock to become
    available. When used with CDB_LOCK_SESSION it pertains to
    <code class="function">cdb_start_session2()</code> itself, with
    CDB_LOCK_REQUEST it pertains to the individual requests.</p><p>While it is possible to use this function to start a session
    towards a configuration database type with no locking at all
    (<em class="parameter"><code>flags</code></em> = 0), this is strongly discouraged
    in general, since it means that even the values read in a single
    multi-value request (e.g. <code class="function">cdb_get_object()</code>,
    see below) may be inconsistent with each other. However it is
    necessary to do this if we want to have a session open during
    semantic validation, see the "Semantic Validation" chapter in the
    User Guide - and in this particular case it is safe, since the
    transaction lock prevents changes to CDB during validation.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_LOCKED, CONFD_ERR_NOEXISTS, CONFD_ERR_PROTOUSAGE</p><div class="funcsynopsis"><a name="fn.cdb_close"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_close</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Closes the socket. <code class="function">cdb_end_session()</code>
    should be called before calling this function.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOEXISTS</p><p>Even if the call returns an error, the socket will be
    closed.</p><div class="funcsynopsis"><a name="fn.cdb_wait_start"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_wait_start</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This call waits until CDB has completed start-phase 1 and is
    available, when it is CONFD_OK is returned. If CDB already is
    available (i.e. start-phase &gt;= 1) the call returns
    immediately. This can be used by a CDB client who is not
    synchronously started and only wants to wait until it can read its
    configuration. The call can be used after cdb_connect().</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_get_phase"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_phase</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_phase *<var class="pdparam">phase</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Returns the start-phase CDB is currently in, in the struct
    cdb_phase pointed to by the second argument. Also if CDB is in
    phase 0 and has initiated an init transaction (to load any init
    files) the flag CDB_FLAG_INIT is set in the flags field of struct
    cdb_phase and correspondingly if an upgrade session is started the
    CDB_FLAG_UPGRADE is set. The call can be used after cdb_connect()
    and returns CONFD_OK.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_initiate_journal_compaction"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_initiate_journal_compaction</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Normally CDB handles journal compaction of the config
    datastore automatically. If this has been turned off (in the
    configuration file) then the A.cdb file will grow indefinitely
    unless this API function is called periodically to initiate
    compaction. This function initiates a compaction and returns
    immediately (if the datastore is locked, the compaction will be
    delayed, but eventually compaction will take place). Calling this
    function when journal compaction is configured to be automatic has
    no effect.</p><p><span class="emphasis"><em>Errors</em></span>: -</p><div class="funcsynopsis"><a name="fn.cdb_get_txid"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_txid</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_txid *<var class="pdparam">txid</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Read the last transaction id from CDB. This function can be
    used if we are forced to reconnect to CDB, If the transaction id
    we read is identical to the last id we had prior to loosing the
    CDB sockets we don't have to reload our managed object data. See
    the User Guide for full explanation. Returns CONFD_OK on success and
    CONFD_ERR or CONFD_EOF on failure.</p><div class="funcsynopsis"><a name="fn.cdb_get_replay_txids"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_replay_txids</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_txid **<var class="pdparam">txid</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">resultlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>When the subscriptionReplay functionality is enabled in
    confd.conf this function returns the list of available
    transactions that CDB can replay. The current transaction id will
    be the first in the list, the second at txid[1] and so on. The
    number of transactions is returned in
    <em class="parameter"><code>resultlen</code></em>. In case there are no replay
    transactions available (the feature isn't enabled or there hasn't
    been any transactions yet) only one (the current) transaction id
    is returned. It is up to the caller to <code class="function">free()</code>
    <em class="parameter"><code>txid</code></em> when it is no longer needed.</p><div class="funcsynopsis"><a name="fn.cdb_set_timeout"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_timeout</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">timeout_secs</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>A timeout for client actions can be specified via
    <code class="sgmltag-element">/confdConfig/cdb/clientTimeout</code> in
    <code class="filename">confd.conf</code>, see the <a class="link" href="rn03re17.html" title="confd.conf">confd.conf(5)</a> manual page.
    This function can be used to dynamically extend (or shorten) the
    timeout for the current action. Thus it is possible to configure a
    restrictive timeout in <code class="filename">confd.conf</code>, but still
    allow specific actions to have a longer execution time.</p><p>The function can be called either with a subscription socket
    during subscription delivery on that socket (including from the
    <code class="function">iter()</code> function passed to
    <code class="function">cdb_diff_iterate()</code>), or with a data socket that
    has an active session. The timeout is given in seconds from the
    point in time when the function is called.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The timeout for subscription delivery is common for all
    the subscribers receiving notifications at a given priority. Thus
    calling the function during subscription delivery changes the
    timeout for all the subscribers that are currently processing
    notifications.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_PROTOUSAGE, CONFD_ERR_BADSTATE</p><div class="funcsynopsis"><a name="fn.cdb_exists"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_exists</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Leafs in the data model may be optional, and presence
    containers and list entries may or may not exist. This function
    checks whether a node  exists in
    CDB. Returns 0 for false, 1 for true and CONFD_ERR or CONFD_EOF
    for errors.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH</p><div class="funcsynopsis"><a name="fn.cdb_cd"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_cd</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Changes the working directory according to the format path.
    Note that this function can not be used as an existence
    test.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH</p><div class="funcsynopsis"><a name="fn.cdb_pushd"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_pushd</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Similar to <code class="function">cdb_cd()</code> but pushes the
    previous current directory on a stack.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOSTACK, CONFD_ERR_BADPATH</p><div class="funcsynopsis"><a name="fn.cdb_popd"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_popd</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Pops the top element from the directory stack and changes
    directory to previous directory.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOSTACK</p><div class="funcsynopsis"><a name="fn.cdb_getcwd"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_getcwd</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>size_t <var class="pdparam">strsz</var>, </td></tr><tr><td>&nbsp;</td><td>char *<var class="pdparam">curdir</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Returns the current position as previously set by
    <code class="function">cdb_cd()</code>, <code class="function">cdb_pushd()</code>,
    or <code class="function">cdb_popd()</code> as a string path. Note that what is
    returned is a pretty-printed version of the internal
    representation of the current position, it will be the shortest
    unique way to print the path but it might not exactly match the
    string given to <code class="function">cdb_cd()</code>. The buffer in
    *curdir will be NULL terminated, and no more characters than
    strsz-1 will be written to it.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_getcwd_kpath"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_getcwd_kpath</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_hkeypath_t **<var class="pdparam">kp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Returns the current position like
    <code class="function">cdb_getcwd()</code>, but as a pointer to a hashed
    keypath instead of as a string.  The hkeypath is dynamically
    allocated, and may further contain dynamically allocated
    elements. The caller must free the allocated memory, easiest done
    by calling <code class="function">confd_free_hkeypath()</code>.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_num_instances"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_num_instances</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Returns the number of entries in a list. On error
    CONFD_ERR or CONFD_EOF is returned.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH</p><div class="funcsynopsis"><a name="fn.cdb_next_index"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_next_index</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Given a path to a list entry
    <code class="function">cdb_next_index()</code> returns the position
    (starting from 0) of the next entry (regardless of whether the path
    exists or not). When the list has multiple keys a
    <code class="literal">*</code> may be used for the last keys to make the path
    partially instantiated. For example if <code class="sgmltag-element">/foo/bar</code> has
    three integer keys, the following pseudo code could be used to
    iterate over all entries with <code class="literal">42</code> as the first
    key:</p><div class="informalexample"><pre class="programlisting">/* find the first entry of /foo/bar with 42 as first key */
ix = cdb_next_index(sock, "/foo/bar{42 * *}");
for (; ix&gt;=0; ix++) {
    int32_t k1 = 0;
    cdb_get_int32(sock, &amp;k1, "/foo/bar[%d]/key1", ix);
    if (k1 != 42) break;
    /* ... do something with /foo/bar[%d] ... */
}</pre></div><p>If there is no next entry -1 is returned. It is not possible
    to use this function on an ordered-by user list. On error
    CONFD_ERR or CONFD_EOF is returned.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH</p><div class="funcsynopsis"><a name="fn.cdb_index"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_index</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Given a path to a list entry
    <code class="function">cdb_index()</code> returns its position (starting
    from 0). On error CONFD_ERR or CONFD_EOF is returned.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH</p><div class="funcsynopsis"><a name="fn.cdb_is_default"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_is_default</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function returns 1 for a leaf which has a default value
    defined in the data model when no value has been set, i.e. when the
    default value is in effect. It returns 0 for other existing leafs,
    and CONFD_ERR or CONFD_EOF for errors. There is normally no need to
    call this function, since CDB automatically provides the default
    value as needed when cdb_get() etc is called.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_subscribe"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_subscribe</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">priority</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nspace</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">spoint</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Sets up a CDB subscription so that we are notified when CDB
    configuration data changes. There can be multiple subscription
    points from different sources, that is a single client daemon can
    have many subscriptions and there can be many client
    daemons.</p><p>Each subscription point is defined through a path similar to
    the paths we use for read operations. We can subscribe either to
    specific leafs or entire subtrees. Subscribing to list
    entries can be done using fully qualified paths, or tagpaths to
    match multiple entries. A path which isn't a leaf element
    automatically matches the subtree below that path. When specifying
    keys to a list entry it is possible to use the wildcard
    character * which will match any key value.</p><p>When subscribing to a leaf with a
    <code class="code">tailf:default-ref</code> statement, or to a
    subtree with elements that have <code class="code">tailf:default-ref</code>,
    implicit subscriptions
    to the referred leafs are added. This means that a change in a
    referred leaf will generate a notification for the subscription that
    has referring leaf(s) - but currently such a change will not be
    reported by <code class="function">cdb_diff_iterate()</code>. Thus to get the
    new "effective" value of a referring leaf in this case, it is
    necessary to either read the value of the leaf with e.g.
    <code class="function">cdb_get()</code> - or to use a subscription that
    includes the referred leafs, and use
    <code class="function">cdb_diff_iterate()</code> when a notification for that
    subscription is received.</p><p>Some examples</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-element">/hosts</code></span></dt><dd><p>Means that we subscribe to any changes in the subtree
          - rooted at <code class="sgmltag-element">/hosts</code>. This includes additions or
          removals of <code class="sgmltag-element">host</code> entries as well as changes to
          already existing <code class="sgmltag-element">host</code> entries.</p></dd><dt><span class="term"><code class="sgmltag-element">/hosts/host{www}/interfaces/interface{eth0}/ip</code></span></dt><dd><p>Means we are notified when host <code class="sgmltag-element">www</code> changes
          its IP address on <code class="sgmltag-element">eth0</code>.</p></dd><dt><span class="term"><code class="sgmltag-element">/hosts/host/interfaces/interface/ip</code></span></dt><dd><p>Means we are notified when any host changes any of its
          IP addresses.</p></dd><dt><span class="term"><code class="sgmltag-element">/hosts/host/interfaces</code></span></dt><dd><p>Means we are notified when either an interface is
          added/removed or when an individual leaf element in an
          existing interface is changed.</p></dd></dl></div><p>The <em class="parameter"><code>priority</code></em> value is an
    integer. When CDB is changed, the change is performed inside a
    transaction. Either a <span class="command"><strong>commit</strong></span> operation from the
    CLI or a <span class="command"><strong>candidate-commit</strong></span> operation in NETCONF
    means that the running database is changed. These changes occur
    inside a ConfD transaction. CDB will handle the subscriptions in
    lock-step priority order. First all subscribers at the lowest
    priority are handled, once they all have replied and synchronized
    through calls to
    <code class="function">cdb_sync_subscription_socket()</code> the next set -
    at the next priority level is handled by CDB. Priority numbers are
    global, i.e. if there are multiple client daemons notifications
    will still be delivered in priority order per all subscriptions,
    not per daemon.</p><p>See <code class="function">cdb_diff_iterate()</code> and
    cdb_diff_match() for ways of filtering subscription notifications
    and finding out what changed. The easiest way is though to not use
    either of the two above mentioned diff function but to solely rely
    on the positioning of the subscription points in the tree to
    figure out what changed.</p><p><code class="function">cdb_subscribe()</code> returns a
    <em class="parameter"><code>subscription point</code></em> in the return parameter
    <em class="parameter"><code>spoint</code></em>. This integer value is used to
    identify this particular subscription.</p><p>Because there can be many subscriptions on the same socket
    the client must notify ConfD when it is done subscribing and
    ready to receive notifications. This is done using
    <code class="function">cdb_subscribe_done()</code>.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_oper_subscribe"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_oper_subscribe</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nspace</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">spoint</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Sets up a CDB subscription for changes in the operational
    data base.  Similar to the subscriptions for configuration data,
    we can be notified of changes to the operational data stored in
    CDB. Note that there are several differences from the
    subscriptions for configuration data:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Notifications are only generated if the writer has taken
        a subscription lock, see
        <code class="function">cdb_start_session2()</code> above.</p></li><li class="listitem"><p>Priorities are not used for these notifications.</p></li><li class="listitem"><p>It is not possible to receive the previous value for
        modified leafs in
        <code class="function">cdb_diff_iterate()</code>.</p></li><li class="listitem"><p>A special synchronization reply must be used when the
        notifications have been read (see
        <code class="function">cdb_sync_subscription_socket()</code>
        below).</p></li></ul></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_subscribe2"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_subscribe2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sub_type <var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">priority</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">spoint</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nspace</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function supersedes the current
    <code class="function">cdb_subscribe()</code> and
    <code class="function">cdb_oper_subscribe()</code> as well as makes it
    possible to use the new two phase subscription method. The
    <span class="type">cdb_sub_type</span> is defined as:</p><div class="informalexample"><a name="enum.cdb_sub_type"></a><pre class="programlisting"><strong class="hl-keyword">enum</strong> cdb_sub_type {
    CDB_SUB_RUNNING = <span class="hl-number">1</span>,
    CDB_SUB_RUNNING_TWOPHASE = <span class="hl-number">2</span>,
    CDB_SUB_OPERATIONAL = <span class="hl-number">3</span>
};</pre></div><p>The CDB subscription type <code class="constant">CDB_SUB_RUNNING</code>
    is the same as <code class="function">cdb_subscribe()</code>,
    <code class="constant">CDB_SUB_OPERATIONAL</code> is the same as
    <code class="function">cdb_oper_subscribe()</code>, and
    <code class="constant">CDB_SUB_RUNNING_TWOPHASE</code> does a
    two phase subscription.</p><p>The flags argument should be set to 0, or a combination
    of:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CDB_SUB_WANT_ABORT_ON_ABORT</code></span></dt><dd><p>Normally if a subscriber is the one to abort a
          transaction it will not receive an abort notification. This
          flags means that this subscriber wants an abort notification
          even if it was the one that called
          cdb_sub_abort_trans(). This flag is only valid when the
          subscription type is
          <code class="constant">CDB_SUB_RUNNING_TWOPHASE</code>.</p></dd></dl></div><p>The two phase subscriptions work like this: A subscriber
    uses <code class="function">cdb_subscribe2()</code> with the type set to
    <code class="constant">CDB_SUB_RUNNING_TWOPHASE</code> to register as many
    subscription points as required. The
    <code class="function">cdb_subscribe_done()</code> function is used to
    indicate that no more subscription points will be registered on
    that particular socket. Only after
    <code class="function">cdb_subscribe_done()</code> is called will
    subscription notifications be delivered.</p><p>Once a transaction enters prepare state all CDB two phase
    subscribers will be notified in priority order (lowest priority
    first, subscribers with the same priority is delivered in
    parallel). The
    <code class="function">cdb_read_subscription_socket2()</code> function will
    set type to <code class="constant">CDB_SUB_PREPARE</code>. Once all
    subscribers have acknowledged the notification by using the
    function
    <code class="function">cdb_sync_subscription_socket(CDB_DONE_PRIORITY)</code>
    they will subsequently be notified when the transaction is
    committed. The <code class="constant">CDB_SUB_COMMIT</code> notification is
    the same as the current subscription mechanism, so when a
    transaction is committed all subscribers will be notified (again in
    priority order).</p><p>When a transaction is aborted, delivery of any remaining
    <code class="constant">CDB_SUB_PREPARE</code> notifications is
    cancelled. The subscribers that had already been notified with
    <code class="constant">CDB_SUB_PREPARE</code> will be notified with
    <code class="constant">CDB_SUB_ABORT</code> (This notification will be done
    in reverse order of the <code class="constant">CDB_SUB_PREPARE</code>
    notification). The transaction could be aborted because one of the
    subscribers that received <code class="constant">CDB_SUB_PREPARE</code>
    called <code class="function">cdb_sub_abort_trans()</code>, but it could
    also be caused for other reasons, for example another data
    provider (than CDB) can abort the transaction.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Two phase subscriptions are not supported for NCS.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_subscribe_done"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_subscribe_done</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>When a client is done registering all its subscriptions
    on a particular subscription socket it must call
    <code class="function">cdb_subscribe_done()</code>. No notifications will
    be delivered until then.</p><div class="funcsynopsis"><a name="fn.cdb_trigger_subscriptions"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_trigger_subscriptions</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">len</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function makes it possible to trigger CDB subscriptions
    for configuration data even though the configuration has not been
    modified.  The caller will trigger all subscription points passed
    in the sub_points array (or all subscribers if the array is of
    zero length) in priority order, and the call will not return until
    the last subscriber has called
    cdb_sync_subscription_socket().</p><p>The call is blocking and doesn't return until all
    subscribers have acknowledged the notification. That means that it
    is not possible to use
    <code class="function">cdb_trigger_subscriptions()</code> in a cdb
    subscriber process (without forking a process or spawning a
    thread) since it would cause a deadlock.</p><p>The subscription notification generated by this "synthetic"
    trigger will seem like a regular subscription notification to a
    subscription client. As such, it is possible to use
    <code class="function">cdb_diff_iterate()</code> to traverse the
    changeset. CDB will make up this changeset in which all leafs in
    the configuration will appear to be set, and all list entries
    and presence containers will appear as if they are created.</p><p>If the client is a two-phase subscriber, a prepare
    notification will first be delivered and if any client aborts this
    synthetic transaction further delivery of subscription
    notification is suspended and an error is returned to the caller
    of <code class="function">cdb_trigger_subscriptions()</code>. The error is
    the result of mapping the CONFD_ERRCODE as set by the aborting
    client as described for MAAPI in the <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
    ERROR REPORTING</a> section in the <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a>
    manpage. Note however that the configuration is still the way it
    is - so it is up to the caller of
    <code class="function">cdb_trigger_subscriptions()</code> to take
    appropriate action (for example: raising an alarm, restarting a
    subsystem, or even rebooting the system).</p><p>If one or more subscription ids is passed in the subids
    array that are not valid, an error
    (<code class="constant">CONFD_ERR_PROTOUSAGE</code>) will be returned and
    no subscriptions will be triggered. If no subscription ids are
    passed this error can not occur (even if there aren't any
    subscribers).</p><div class="funcsynopsis"><a name="fn.cdb_trigger_oper_subscriptions"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_trigger_oper_subscriptions</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">len</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function works like
    <code class="function">cdb_trigger_subscriptions()</code>, but for CDB
    subscriptions to operational data. The caller will trigger all
    subscription points passed in the <em class="parameter"><code>sub_points</code></em>
    array (or all operational data subscribers if the array is of zero
    length), and the call will not return until the last subscriber has
    called cdb_sync_subscription_socket().</p><p>Since the generation of subscription notifications for
    operational data requires that the subscription lock is taken (see
    <code class="function">cdb_start_session2()</code>), this function implicitly
    attempts to take a "global" subscription lock. If the subscription
    lock is already taken, the function will by default return CONFD_ERR
    with <code class="varname">confd_errno</code> set to CONFD_ERR_LOCKED. To
    instead have it wait until the lock becomes available, CDB_LOCK_WAIT
    can be passed for the <em class="parameter"><code>flags</code></em> parameter.</p><div class="funcsynopsis"><a name="fn.cdb_replay_subscriptions"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_replay_subscriptions</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct cdb_txid *<var class="pdparam">txid</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">len</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function makes it possible to replay the subscription
    events for the last configuration change to some or all CDB
    subscribers. This call is useful in a number of recovery
    scenarios, where some CDB subscribers lost connection to ConfD
    before having received all the changes in a
    transaction. The replay functionality is only available if it has
    been enabled in confd.conf</p><p>The caller specifies the transaction id of the last
    transaction that the application has completely seen and acted
    on. This verifies that the application has only missed (part of)
    the last transaction. If a different (older) transaction ID is
    specified, an error is returned and no subscriptions will be
    triggered. If the transaction id is the latest transaction ID
    (i.e. the caller is already up to date) nothing is triggered and
    CONFD_OK is returned.</p><p>By calling this function, the caller will potentially
    trigger all subscription points passed in the sub_points array (or
    all subscribers if the array is of zero length). The subscriptions
    will be triggered in priority order, and the call will not return
    until the last subscriber has called
    cdb_sync_subscription_socket().</p><p>The call is blocking and doesn't return until all
    subscribers have acknowledged the notification. That means that it
    is not possible to use
    <code class="function">cdb_replay_subscriptions()</code> in a cdb
    subscriber process (without forking a process or spawning a
    thread) since it would cause a deadlock.</p><p>The subscription notification generated by this "synthetic"
    trigger will seem like a regular subscription notification to a
    subscription client. It is possible to use
    <code class="function">cdb_diff_iterate()</code> to traverse the
    changeset.</p><p>If the client is a two-phase subscriber, a prepare
    notification will first be delivered and if any client aborts this
    synthetic transaction further delivery of subscription
    notification is suspended and an error is returned to the caller
    of <code class="function">cdb_replay_subscriptions()</code>. The error is
    the result of mapping the CONFD_ERRCODE as set by the aborting
    client as described for MAAPI in the <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
    ERROR REPORTING</a> section in the <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a> manpage.</p><div class="funcsynopsis"><a name="fn.cdb_read_subscription_socket"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_read_subscription_socket</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">sub_points[]</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">resultlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The subscription socket - which is acquired through a call
    to <code class="function">cdb_connect()</code> - must be part of the
    application poll set.  Once the subscription socket has I/O ready
    to read, we must call
    <code class="function">cdb_read_subscription_socket()</code> on the
    subscription socket.</p><p>The call will fill in the result in the array
    <em class="parameter"><code>sub_points</code></em> with a list of integer values
    containing <span class="emphasis"><em>subscription points</em></span> earlier
    acquired through calls to <code class="function">cdb_subscribe()</code>.
    The global variable <code class="varname">cdb_active_subscriptions</code>
    can be read to find how many active subscriptions the application
    has. Make sure the <code class="code">sub_points[]</code> array is at least this
    big, otherwise the confd library will write in unallocated
    memory.</p><p>The subscription points may be either for configuration data
    or operational data (if <code class="function">cdb_oper_subscribe()</code>
    has been used on the same socket), but they will all be of the
    same "type" - i.e.  a single call of the function will never
    deliver a mix of configuration and operational data subscription
    points.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_read_subscription_socket2"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_read_subscription_socket2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_sub_notification *<var class="pdparam">type</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">subpoints[]</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">resultlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><div class="informalexample"><a name="enum.cdb_sub_notification"></a><pre class="programlisting"><strong class="hl-keyword">enum</strong> cdb_sub_notification {
    CDB_SUB_PREPARE = <span class="hl-number">1</span>,
    CDB_SUB_COMMIT = <span class="hl-number">2</span>,
    CDB_SUB_ABORT = <span class="hl-number">3</span>,
    CDB_SUB_OPER = <span class="hl-number">4</span>
};</pre></div><p>This is another version of the
    <code class="function">cdb_read_subscription_socket()</code> with two
    important differences:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In this version <span class="emphasis"><em>subpoints is allocated by the
        library</em></span>, and it is up to the caller of this
        function to <code class="function">free()</code> it when it is
        done.</p></li><li class="listitem"><p>It is possible to retrieve the type of the subscription
        notification via the <em class="parameter"><code>type</code></em> return
        parameter.</p></li></ol></div><p>All parameters except <em class="parameter"><code>sock</code></em> are return
    parameters. It is legal to pass in <em class="parameter"><code>flags</code></em>
    and <em class="parameter"><code>type</code></em> as <code class="constant">NULL</code>
    pointers (in which case type and flags cannot be
    retrieved). <em class="parameter"><code>subpoints</code></em> is an array of
    integers, the length is indicated in
    <em class="parameter"><code>resultlen</code></em>, it is allocated by the library,
    and <span class="emphasis"><em>must be freed by the caller</em></span>. The
    <em class="parameter"><code>type</code></em> parameter is what the subscriber uses
    to distinguish the different types of subscription
    notifications.</p><p>The <em class="parameter"><code>flags</code></em> return parameter can have
    the following bits set:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CDB_SUB_FLAG_IS_LAST</code></span></dt><dd><p>This bit is set when this notification is the last of
          its type for this subscription socket.</p></dd><dt><span class="term"><code class="constant">CDB_SUB_FLAG_HA_IS_SLAVE</code></span></dt><dd><p>This bit is set when <span class="phrase">ConfD</span>
           runs in HA mode, and
          the current HA mode is slave. I.e. it is a convenient way
          for the subscriber to know wether this node is in slave mode
          or not.</p></dd><dt><span class="term"><code class="constant">CDB_SUB_FLAG_TRIGGER</code></span></dt><dd><p>This bit is set when the cause of the subscription
          notification is that someone called
          <code class="function">cdb_trigger_subscriptions()</code>.</p></dd><dt><span class="term"><code class="constant">CDB_SUB_FLAG_REVERT</code></span></dt><dd><p>If a confirming commit is aborted it will look to the
          CDB subscriber as if a transaction happened that is the
          reverse of what the original transaction was. This bit will
          be set when such a transaction is the cause of the
          notification. Note that for a two-phase subscriber both a
          prepare and a commit notification is delivered. However it
          is not possible to reply by calling
          <code class="function">cdb_sub_abort_trans()</code> for the prepare
          notification in this case, instead the subscriber will have
          to take appropriate backup action if it needs to abort (for
          example: raise an alarm, restart, or even reboot the
          system).</p></dd><dt><span class="term"><code class="constant">CDB_SUB_FLAG_HA_SYNC</code></span></dt><dd><p>This bit is set when the cause of the subscription
          notification is initial synchronization of a HA slave from
          CDB on the master.</p></dd></dl></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_diff_iterate"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_diff_iterate</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_ret (*<var class="pdparam">iter</var>)(confd_hkeypath_t *<var class="pdparam">kp</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_op <var class="pdparam">op</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">oldv</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">newv</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">state</var>), </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">initstate</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>After reading the subscription socket the
    <code class="function">cdb_diff_iterate()</code> function can be used to
    iterate over the changes made in CDB data that matched the
    particular subscription point given by
    <em class="parameter"><code>subid</code></em>.</p><p>The user defined function <code class="function">iter()</code> will
    be called for each element that has been modified and matches the
    subscription. The <code class="function">iter()</code> callback receives
    the <em class="parameter"><code>confd_hkeypath_t kp</code></em> which uniquely
    identifies which node in the data tree that is affected, the
    operation, and optionally the values it has before and after the
    transaction. The <em class="parameter"><code>op</code></em> parameter gives the
    modification as:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">MOP_CREATED</span></dt><dd><p>The list entry, <code class="code">presence</code> container, or leaf
          of type <code class="code">empty</code> given
          by <em class="parameter"><code>kp</code></em> has been created.</p></dd><dt><span class="term">MOP_DELETED</span></dt><dd><p>The list entry, <code class="code">presence</code> container, or
          optional leaf given by <em class="parameter"><code>kp</code></em> has been
          deleted.</p><p>If the subscription was triggered because an ancestor
          was deleted, the <code class="function">iter()</code> function will
          not called at all if the delete was above the subscription
          point. However if the flag ITER_WANT_ANCESTOR_DELETE is
          passed to <code class="function">cdb_diff_iterate()</code> then
          deletes that trigger a descendant subscription will also
          generate a call to <code class="function">iter()</code>, and in this
          case <em class="parameter"><code>kp</code></em> will be the path that was
          actually deleted.</p></dd><dt><span class="term">MOP_MODIFIED</span></dt><dd><p>A descendant of the list entry
          given by <em class="parameter"><code>kp</code></em> has been
          modified.</p></dd><dt><span class="term">MOP_VALUE_SET</span></dt><dd><p>The value of the leaf given by
          <em class="parameter"><code>kp</code></em> has been set to
          <em class="parameter"><code>newv</code></em>.</p></dd><dt><span class="term">MOP_MOVED_AFTER</span></dt><dd><p>The list entry given by <em class="parameter"><code>kp</code></em>, in an
          <code class="code">ordered-by user</code> list, has been moved. If
          <em class="parameter"><code>newv</code></em> is NULL, the entry has been moved
          first in the list, otherwise it has been moved after the entry
          given by <em class="parameter"><code>newv</code></em>. In this case
          <em class="parameter"><code>newv</code></em> is a pointer to an array of key
          values identifying an entry in the list. The array is
          terminated with an element that has type C_NOEXISTS.</p></dd></dl></div><p>
      By setting the <em class="parameter"><code>flags</code></em> parameter
      ITER_WANT_REVERSE two-phase subscribers may use
      this function to traverse the reverse changeset in case of
      CDB_SUB_ABORT notification.

      In this scenario a two-phase subscriber traverses the changes in
      the prepare phase (CDB_SUB_PREPARE notification) and if the
      transaction is aborted the subscriber may iterate the inverse to
      the changes during the abort phase (CDB_SUB_PREPARE notification).
    </p><p>For configuration subscriptions, the previous value of the
    node can also be passed to <code class="function">iter()</code> if the
    <em class="parameter"><code>flags</code></em> parameter contains ITER_WANT_PREV, in
    which case
    <em class="parameter"><code>oldv</code></em> will be pointing to it (otherwise
    NULL). For operational data subscriptions, the ITER_WANT_PREV flag
    is ignored, and <em class="parameter"><code>oldv</code></em> is always NULL - there
    is no equivalent to CDB_PRE_COMMIT_RUNNING that holds "old"
    operational data.</p><p>If <code class="function">iter()</code> returns ITER_STOP, no more
    iteration is done, and CONFD_OK is returned.  If
    <code class="function">iter()</code> returns ITER_RECURSE iteration
    continues with all children to the node. If
    <code class="function">iter()</code> returns ITER_CONTINUE iteration
    ignores the children to the node (if any), and continues with the
    node's sibling, and if <code class="function">iter()</code> returns ITER_UP
    the iteration is continued with the node's parents sibling. If,
    for some reason, the <code class="function">iter()</code> function wants to
    return control to the caller of
    <code class="function">cdb_diff_iterate()</code>
    <span class="emphasis"><em>before</em></span> all the changes has been iterated over
    it can return ITER_SUSPEND. The caller then has to call
    <code class="function">cdb_diff_iterate_resume()</code> to continue/finish
    the iteration.</p><p>The <em class="parameter"><code>state</code></em> parameter can be used for
    any user supplied state (i.e. whatever is supplied as
    <em class="parameter"><code>initstate</code></em> is passed as
    <em class="parameter"><code>state</code></em> to <code class="function">iter()</code> in
    each invocation).</p><p>
      By default the traverse order is undefined but guaranteed to
      be the most efficient one.

      The traverse order may be changed by setting setting a bit in
      the <em class="parameter"><code>flags</code></em> parameter:
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ITER_WANT_SCHEMA_ORDER</span></dt><dd><p>
              The <code class="function">iter()</code> function will be invoked in
              <span class="emphasis"><em>schema</em></span> order (i.e. in the order in which the
              elements are defined in the YANG file).
            </p></dd><dt><span class="term">ITER_WANT_LEAF_FIRST_ORDER</span></dt><dd><p>
              The <code class="function">iter()</code> function will be invoked
              for leafs first, then non-leafs.
            </p></dd><dt><span class="term">ITER_WANT_LEAF_LAST_ORDER</span></dt><dd><p>
              The <code class="function">iter()</code> function will be invoked
              for non-leafs first, then leafs.
            </p></dd></dl></div><p>
    </p><p>If the <em class="parameter"><code>flags</code></em> parameter
    ITER_WANT_LEAF_LIST_AS_LEAF is given, changes to leaf-lists will
    cause invocations of <code class="function">iter()</code> as for leafs and
    and not as for lists, e.g. with MOP_VALUE_SET rather than
    MOP_CREATED / MOP_DELETED.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This flag is deprecated, and only present for temporary
    backward compatibility - it will be removed in a future
    release.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This flag is not supported when invoking
    <code class="function">cdb_diff_iterate()</code> on a HA slave.</p></div><p>
      <span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
      CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE, CONFD_ERR_PROTOUSAGE.
    </p><div class="funcsynopsis"><a name="fn.cdb_diff_iterate_resume"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_diff_iterate_resume</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_ret <var class="pdparam">reply</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_ret (*<var class="pdparam">iter</var>)(                                       confd_hkeypath_t *<var class="pdparam">kp</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_iter_op <var class="pdparam">op</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">oldv</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">newv</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">state</var>), </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">resumestate</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The application <span class="emphasis"><em>must</em></span> call this function
    whenever an iterator function has returned
    <code class="constant">ITER_SUSPEND</code> to finish up the iteration. If
    the application does not wish to continue iteration it must at
    least call <code class="code">cdb_diff_iterate_resume(s, ITER_STOP, NULL,
    NULL);</code> to clean up the state. The
    <em class="parameter"><code>reply</code></em> parameter is what the iterator
    function would have returned (i.e. normally ITER_RECURSE or
    ITER_CONTINUE) if it hadn't returned ITER_SUSPEND. Note that it is
    up to the iterator function to somehow communicate that it has
    returned ITER_SUSPEND to the caller of
    <code class="function">cdb_diff_iterate()</code>, this can for example be a
    field in a struct for which a pointer to can passed back and forth
    in the <code class="varname">state</code>/<code class="varname">resumestate</code>
    variable.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE.</p><div class="funcsynopsis"><a name="fn.cdb_diff_match"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_diff_match</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>struct xml_tag <var class="pdparam">tags[]</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">tagslen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function can be invoked when a subscription point has
    fired. Similar to the
    <code class="function">confd_hkp_tagmatch()</code> function it takes
    an argument which is an array of XML tags. The function will
    invoke <code class="function">cdb_diff_iterate()</code> on a subscription
    socket. Using combinations of <code class="constant">ITER_STOP</code>,
    <code class="constant">ITER_CONTINUE</code> and
    <code class="constant">ITER_RECURSE</code> return values, the function
    checks a tagpath and decides whether any changes (under the
    subscription point) has occurred that also match the provided path
    <em class="parameter"><code>tags</code></em>.  It is slightly easier to use this
    function than <code class="function">cdb_diff_iterate()</code> but can also
    be slower since it is a general purpose matcher.</p><p>If we have a subscription point at
    <code class="sgmltag-element">/root</code>, we could invoke this function
    as:</p><div class="informalexample"><pre class="programlisting">struct xml_tag tags[] = {{root_root, root__ns},
                         {root_servers, root__ns},
                         {root_server, root__ns}};
/* /root/servers/server */
int retv = cdb_diff_match(subsock, subpoint, tags, 3);</pre></div><p>The function returns 1 if there were any changes under
    <em class="parameter"><code>subpoint</code></em> that matched
    <em class="parameter"><code>tags</code></em>, 0 if no match was found and
    <code class="constant">CONFD_ERR</code> on error.</p><div class="funcsynopsis"><a name="fn.cdb_cli_diff_iterate"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_cli_diff_iterate</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>cli_diff_iter_function_t *<var class="pdparam">iter</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>void *<var class="pdparam">initstate</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Where the <span class="type">cli_diff_iter_function_t</span> is defined
    as:</p><div class="informalexample"><pre class="programlisting">typedef enum cdb_iter_ret
    (cli_diff_iter_function_t)(confd_hkeypath_t *kp,
                               enum cdb_iter_op op,
                               confd_value_t *oldv,
                               confd_value_t *newv,
                               char *clistr,
                               int token_count,
                               struct confd_cli_token *tokens,
                               void *state);</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function is DEPRECATED. Use
      cdb_get_modifications_cli() instead.</p></div><p>The function <code class="function">cdb_cli_diff_iterate()</code>
    works just like the <code class="function">cdb_diff_iterate()</code>
    function, except the <code class="function">iter()</code> function takes
    three additional parameters, <em class="parameter"><code>clistr</code></em>,
    <em class="parameter"><code>token_count</code></em>, and
    <em class="parameter"><code>tokens</code></em>. The <em class="parameter"><code>clistr</code></em>
    is a string containing the (C-style) rendering of the CLI commands
    equivalent to the current keypath/operation. The
    <em class="parameter"><code>tokens</code></em> is actually an array of length
    <em class="parameter"><code>token_count</code></em>, it contains the CLI string
    broken down by token.</p><p>The string and the token array (including all the strings in
    the array) are allocated by the library, and will be freed by the
    library when the <em class="parameter"><code>iter</code></em> function
    returns.</p><p>If <em class="parameter"><code>flags</code></em> has the
    <code class="constant">ITER_WANT_SCHEMA_ORDER</code> bit set, then the
    <code class="function">iter()</code> function will be invoked in
    <span class="emphasis"><em>schema</em></span> order (i.e. in the order in which the
    elements are defined in the YANG file). Normally the order is
    undefined, which is most efficient.</p><p>Note that the cli commands are independent of whether the
    originating request actually came in over the CLI or some other
    northbound interface.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOEXISTS, CONFD_ERR_BADSTATE.</p><div class="funcsynopsis"><a name="fn.cdb_get_modifications"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_modifications</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">nvalues</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The <code class="function">cdb_get_modifications()</code> function
    can be called after reception of a subscription notification to
    retrieve all the changes that caused the subscription
    notification. The socket <em class="parameter"><code>s</code></em> is the
    subscription socket, the subscription id must also be
    provided. Optionally a path can be used to limit what is returned
    further (only changes below the supplied path will be returned),
    if this isn't needed fmt can be set to
    <code class="constant">NULL</code>.</p><p>When <code class="function">cdb_get_modifications()</code> returns
    <code class="constant">CONFD_OK</code>, the results are in
    <em class="parameter"><code>values</code></em>, which is
    a tag value array with length <em class="parameter"><code>nvalues</code></em>. The
    library allocates memory for the results, which must be free:d by
    the caller. This can in all cases be done with code like
    this:</p><div class="informalexample"><pre class="programlisting">confd_tag_value_t *values;
int nvalues, i;

if (cdb_get_modifications(sock, subid, flags, &amp;values, &amp;nvalues,
                          "/some/path") == CONFD_OK) {
    ...
    for (i = 0; i &lt; nvalues; i++)
        confd_free_value(CONFD_GET_TAG_VALUE(&amp;values[i]));
    free(values);
}</pre></div><p>The tag value array differs somewhat between how it is
    described in the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual page,
    most notably only the values that were modified in this
    transaction are included. In addition to that these are the
    different values of the tags depending on what happened in the
    transaction:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A leaf of type empty that has been deleted has the value
        of <code class="constant">C_NOEXISTS</code>, and when it is created it
        has the value <code class="constant">C_XMLTAG</code>.</p></li><li class="listitem"><p>A leaf or a leaf-list that has been set to a new value
        (or its default value) is included with that new value. If the
        leaf or leaf-list is optional, then when it is deleted the
        value is <code class="constant">C_NOEXISTS</code>.</p></li><li class="listitem"><p>Presence containers are included when they are created
        or when they have modifications below them (by the usual
        <code class="constant">C_XMLBEGIN</code>, <code class="constant">C_XMLEND</code>
        pair). If a presence container has been deleted its tag is
        included, but has the value
        <code class="constant">C_NOEXISTS</code>.</p></li></ul></div><p>By default <code class="function">cdb_get_modifications()</code> does
    not include list instances (created, deleted, or modified) - but
    if the <code class="constant">CDB_GET_MODS_INCLUDE_LISTS</code> flag is
    included in the <em class="parameter"><code>flags</code></em> parameter, list
    instances will be included. Created and modified instances are
    included wrapped in the <code class="constant">C_XMLBEGIN</code> /
    <code class="constant">C_XMLEND</code> pair, with the keys first. Deleted
    list instances instead begin with
    <code class="constant">C_XMLBEGINDEL</code>, then follows the keys,
    immediately followed by a <code class="constant">C_XMLEND</code>.</p><p>If the <code class="constant">CDB_GET_MODS_SUPPRESS_DEFAULTS</code>
    flag is included in the <em class="parameter"><code>flags</code></em> parameter,
    a default value that comes into effect for a leaf due to an ancestor
    list entry or presence container being created will not be included,
    and a default value that comes into effect for a leaf due to a set
    value being deleted will be included as a deletion (i.e. with value
    <code class="constant">C_NOEXISTS</code>).</p><p>When processing a <code class="constant">CDB_SUB_ABORT</code>
    notification for a two phase subscription, it is also possible to
    request a list of "reverse" modifications instead of the normal
    "forward" list. This is done by including the
    <code class="constant">CDB_GET_MODS_REVERSE</code> flag in the
    <em class="parameter"><code>flags</code></em> parameter.</p><div class="funcsynopsis"><a name="fn.cdb_get_modifications_iter"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_modifications_iter</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">nvalues</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The <code class="function">cdb_get_modifications_iter()</code> is
    basically a convenient short-hand of the
    <code class="function">cdb_get_modifications()</code> function intended to
    be used from within a iteration function started by
    <code class="function">cdb_diff_iterate()</code>. In this case no
    subscription id is needed, and the path is implicitly the current
    position in the iteration.</p><p>Combining this call with
    <code class="function">cdb_diff_iterate()</code> makes it for example
    possible to iterate over a list, and for each list instance fetch
    the changes using
    <code class="function">cdb_get_modifications_iter()</code>, and then return
    <code class="constant">ITER_CONTINUE</code> to process next
    instance.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Note: The <code class="constant">CDB_GET_MODS_REVERSE</code> flag
    is ignored by <code class="function">cdb_get_modifications_iter()</code>.  It
    will instead return a "forward" or "reverse" list of modifications
    for a <code class="constant">CDB_SUB_ABORT</code> notification according to
    whether the <code class="constant">ITER_WANT_REVERSE</code> flag was included
    in the <em class="parameter"><code>flags</code></em> parameter of the
    <code class="function">cdb_diff_iterate()</code> call.</p></div><div class="funcsynopsis"><a name="fn.cdb_get_modifications_cli"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_modifications_cli</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">subid</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td>&nbsp;</td><td>char **<var class="pdparam">str</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>The <code class="function">cdb_get_modifications_cli()</code>
    function can be called after reception of a subscription
    notification to retrieve all the changes that caused the
    subscription notification as a string in Cisco CLI format. The
    socket <em class="parameter"><code>s</code></em> is the subscription socket, the
    subscription id must also be provided. The
    <em class="parameter"><code>flags</code></em> parameter is currently unused, and
    should be set to zero for future compatibility.</p><p>The CLI string is malloc(3)ed by the library, and the caller
    must free the memory using free(3) when it is not needed any
    longer.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_sync_subscription_socket"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sync_subscription_socket</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum cdb_subscription_sync_type <var class="pdparam">st</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Once we have read the subscription notification through a
    call to <code class="function">cdb_read_subscription_socket()</code> and
    optionally used the <code class="function">cdb_diff_iterate()</code> to
    iterate through the changes as well as acted on the changes to
    CDB, we must synchronize with CDB so that CDB can continue and
    deliver further subscription messages to subscribers with higher
    priority numbers.</p><p>There are four different types of synchronization replies
    the application can use in the <span class="type">enum
    cdb_subscription_sync_type</span> parameter:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">CDB_DONE_PRIORITY</code></span></dt><dd><p>This means that the application has acted on the
          subscription notification and CDB can continue to deliver
          further notifications.</p></dd><dt><span class="term"><code class="constant">CDB_DONE_SOCKET</code></span></dt><dd><p>This means that we are done. But regardless of
          priority, CDB shall not send any further notifications to us
          on our socket that are related to the currently executing
          transaction.</p></dd><dt><span class="term"><code class="constant">CDB_DONE_TRANSACTION</code></span></dt><dd><p>This means that CDB should not send any further
          notifications to any subscribers - including ourselves -
          related to the currently executing transaction.</p></dd><dt><span class="term"><code class="constant">CDB_DONE_OPERATIONAL</code></span></dt><dd><p>This should be used when a subscription notification
          for operational data has been read. It is the only type that
          should be used in this case, since the operational data does
          not have transactions and the notifications do not have
          priorities.</p></dd></dl></div><p>When using two phase subscriptions and
    <code class="function">cdb_read_subscription_socket2()</code> has returned
    the type as <code class="constant">CDB_SUB_PREPARE</code> or
    <code class="constant">CDB_SUB_ABORT</code> the only valid response is
    <code class="constant">CDB_DONE_PRIORITY</code>.</p><p>For configuration data, the transaction that generated the
    subscription notifications is pending until all notifications have
    been acknowledged.  A read lock on CDB is in effect while
    notifications are being delivered, preventing writes until
    delivery is complete.</p><p>For operational data, the writer that generated the
    subscription notifications is not directly affected, but the
    "subscription lock" remains in effect until all notifications have
    been acknowledged - thus subsequent attempts to obtain a "global"
    subscription lock, or a subscription lock using CDB_LOCK_PARTIAL for
    a non-disjuct subtree, will fail or block while notifications are being
    delivered (see <code class="function">cdb_start_session2()</code> above).
    Write operations that don't attempt to obtain the subscription
    lock will proceed independent of the delivery of subscription
    notifications.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_sub_progress"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sub_progress</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>After receiving a subscription notification (using
    <code class="function">cdb_read_subscription_socket()</code>) but before
    acknowledging it (or aborting, in the case of prepare
    subscriptions), it is possible to send progress reports back to
    ConfD using the <code class="function">cdb_sub_progress()</code>
    function. The socket <em class="parameter"><code>sock</code></em> must be the
    subscription socket, and it is allowed to call the function more
    than once to display more than one message. It is also possible to
    use this function in the diff-iterate callback function. A newline
    at the end of the string isn't necessary.</p><p>Depending on which north-bound interface that triggered the
    transaction, the string passed may be reported by that
    interface. Currently this is only presented in the CLI when the
    operator requests detailed reporting using the <span class="command"><strong>commit |
    details</strong></span> command.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_sub_abort_trans"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sub_abort_trans</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function is to be called instead of
    <code class="function">cdb_sync_subscription_socket()</code> when the
    subscriber wishes to abort the current transaction. It is only
    valid to call after
    <code class="function">cdb_read_subscription_socket2()</code> has returned
    with type set to <code class="constant">CDB_SUB_PREPARE</code>. The
    arguments after sock are the same as to
    <code class="function">confd_X_seterr_extended()</code> and give the caller
    a way of indicating the reason for the failure. Details can be
    found in the <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
    ERROR REPORTING</a> section in the <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a> manpage.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_sub_abort_trans_info"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_sub_abort_trans_info</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>enum confd_errcode <var class="pdparam">code</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_ns</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t <var class="pdparam">apptag_tag</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">error_info</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function does the same as
    <code class="function">cdb_sub_abort_trans()</code>, and additionally gives
    the possibility to provide contents for the NETCONF
    &lt;error-info&gt; element. See the <a class="link" href="rn02re13.html#man.3.confd_lib_lib.extended_error_reporting" title="EXTENDED ERROR REPORTING">EXTENDED
    ERROR REPORTING</a> section in the <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a> manpage.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC,
    CONFD_ERR_OS</p><div class="funcsynopsis"><a name="fn.cdb_get_user_session"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_user_session</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Returns the user session id for the transaction that
    triggered the current subscription notification. This function
    uses a subscription socket, and can only be called when a
    subscription notification for configuration data has been received
    on that socket, before
    <code class="function">cdb_sync_subscription_socket()</code> has been
    called. Additionally, it is not possible to call this function from
    the <code class="function">iter()</code> function passed to
    <code class="function">cdb_diff_iterate()</code>.
    To retrieve full information about the user session, use
    <code class="function">maapi_get_user_session()</code> (see <a class="link" href="rn02re14.html" title="confd_lib_maapi">confd_lib_maapi(3)</a>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Note: When the ConfD High Availability functionality
    is used, the user session information is not available on slave
    nodes.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADSTATE, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_get_transaction_handle"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_transaction_handle</b>(</code></td><td>int <var class="pdparam">sock</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Returns the transaction handle for the transaction that
    triggered the current subscription notification. This function
    uses a subscription socket, and can only be called when a
    subscription notification for configuration data has been received
    on that socket, before
    <code class="function">cdb_sync_subscription_socket()</code> has been
    called. Additionally, it is not possible to call this function from
    the <code class="function">iter()</code> function passed to
    <code class="function">cdb_diff_iterate()</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A CDB client is not expected to access the ConfD
    transaction store directly - this function should only be used for
    logging or debugging purposes.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When the ConfD High Availability functionality
    is used, the transaction information is not available on slave
    nodes.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADSTATE, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_get"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function reads a value from the path in
    <em class="parameter"><code>fmt</code></em> and writes the result into the result
    parameter <span class="type">confd_value_t</span>.  The path must lead to a leaf
    element in the XML data tree. Note that for the C_BUF, C_BINARY,
    C_LIST, C_OBJECTREF, C_OID, C_QNAME, C_HEXSTR, and C_BITBIG
    <span class="type">confd_value_t</span> types, the buffer(s) pointed to are
    allocated using malloc(3) - it is up to the user of this interface
    to free them using <code class="function">confd_free_value()</code>.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_NOEXISTS,
    CONFD_ERR_MALLOC, CONFD_ERR_OS, CONFD_ERR_BADPATH,
    CONFD_ERR_BADTYPE</p><p>All the type safe versions of <code class="function">cdb_get()</code>
    described below, as well as <code class="function">cdb_vget()</code>, also
    have the same possible Errors. When the type of the read value is
    wrong, <code class="varname">confd_errno</code> is set to CONFD_ERR_BADTYPE
    and the function returns CONFD_ERR. The YANG type is given in the
    descriptions below.</p><div class="funcsynopsis"><a name="fn.cdb_get_int8"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int8</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int8_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">int8</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_int16"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int16</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int16_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">int16</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_int32"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int32</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">int32</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_int64"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_int64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int64_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">int64</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_u_int8"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int8</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int8_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">uint8</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_u_int16"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int16</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int16_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">uint16</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_u_int32"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int32</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">uint32</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_u_int64"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_u_int64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int64_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">uint64</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_bit32"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bit32</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">bits</span> values where the highest assigned bit
    position for the type is 31.</p><div class="funcsynopsis"><a name="fn.cdb_get_bit64"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bit64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>u_int64_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">bits</span> values where the highest assigned bit
    position for the type is above 31 and below 64.</p><div class="funcsynopsis"><a name="fn.cdb_get_bitbig"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bitbig</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">bits</span> values where the highest assigned bit
    position for the type is above 63. Upon successful return
    <em class="parameter"><code>rval</code></em> is pointing to a buffer of size
    <em class="parameter"><code>bufsiz</code></em>. It is up to the user of this function
    to free the buffer using free(3) when it is not needed any
    longer.</p><div class="funcsynopsis"><a name="fn.cdb_get_ipv4"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv4</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct in_addr *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">inet:ipv4-address</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_ipv6"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv6</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct in6_addr *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">inet:ipv6-address</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_double"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_double</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>double *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">xs:float</span> and <span class="type">xs:double</span>
    values.</p><div class="funcsynopsis"><a name="fn.cdb_get_bool"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_bool</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">boolean</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_datetime"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_datetime</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_datetime *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">date-and-time</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_date"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_date</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_date *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">xs:date</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_time"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_time</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_time *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">xs:time</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_duration"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_duration</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_duration *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">xs:duration</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_enum_value"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_enum_value</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>int32_t *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read enumeration values. If we have:</p><div class="informalexample"><pre class="programlisting">typedef unboundedType {
  type enumeration {
    enum unbounded;
    enum infinity;
  }
}</pre></div><p>The two enumeration values <code class="constant">unbounded</code>
    and <code class="constant">infinity</code> will occur as two #define
    integers in the .h file which is generated from the YANG module. Thus
    this function <code class="function">cdb_get_enum_value()</code> populates
    an unsigned integer pointer.</p><div class="funcsynopsis"><a name="fn.cdb_get_objectref"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_objectref</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_hkeypath_t **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">instance-identifier</span> values. Upon successful
    return <em class="parameter"><code>rval</code></em> is pointing to an allocated
    <span class="type">confd_hkeypath_t</span>. It is up to the user of this
    function to free the hkeypath using
    <code class="function">confd_free_hkeypath()</code> when it is not needed
    any longer.</p><div class="funcsynopsis"><a name="fn.cdb_get_oid"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_oid</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_snmp_oid **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">object-identifier</span> values. Upon successful return
    <em class="parameter"><code>rval</code></em> is pointing to an allocated
    <span class="type">struct confd_snmp_oid</span>.  It is up to the user of this
    function to free the struct using free(3) when it is not needed
    any longer.</p><div class="funcsynopsis"><a name="fn.cdb_get_buf"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_buf</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">string</span> values. Upon
    successful return <em class="parameter"><code>rval</code></em> is pointing to a
    buffer of size <em class="parameter"><code>bufsiz</code></em>.  It is up to the
    user of this function to free the buffer using free(3) when it is
    not needed any longer.</p><div class="funcsynopsis"><a name="fn.cdb_get_buf2"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_buf2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">string</span> values. If the
    buffer returned by <code class="function">cdb_get()</code> fits into
    <em class="parameter"><code>*n</code></em> bytes CONFD_OK is returned and the
    buffer is copied into <em class="parameter"><code>*rval</code></em>. Upon
    successful return <em class="parameter"><code>*n</code></em> is set to the number
    of bytes copied into <em class="parameter"><code>*rval</code></em>.</p><div class="funcsynopsis"><a name="fn.cdb_get_str"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_str</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>char *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">string</span> values. If the
    buffer returned by <code class="function">cdb_get()</code> plus a
    terminating NUL fits into <em class="parameter"><code>n</code></em> bytes CONFD_OK
    is returned and the buffer is copied into
    <em class="parameter"><code>*rval</code></em> (as well as a terminating NUL
    character).</p><div class="funcsynopsis"><a name="fn.cdb_get_binary"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_binary</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code>, as
    <code class="function">cdb_get_buf()</code> but for
    <span class="type">binary</span> values.
    Upon successful return <em class="parameter"><code>rval</code></em> is
    pointing to a buffer of size <em class="parameter"><code>bufsiz</code></em>.  It is
    up to the user of this function to free the buffer using free(3)
    when it is not needed any longer.</p><div class="funcsynopsis"><a name="fn.cdb_get_hexstr"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_hexstr</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">bufsiz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code>, as
    <code class="function">cdb_get_buf()</code> but for
    <span class="type">yang:hex-string</span> values.
    Upon successful return <em class="parameter"><code>rval</code></em> is
    pointing to a buffer of size <em class="parameter"><code>bufsiz</code></em>.  It is
    up to the user of this function to free the buffer using free(3)
    when it is not needed any longer.</p><div class="funcsynopsis"><a name="fn.cdb_get_qname"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_qname</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">prefix</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">prefixsz</var>, </td></tr><tr><td>&nbsp;</td><td>unsigned char **<var class="pdparam">name</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">namesz</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">xs:QName</span> values. Note
    that <em class="parameter"><code>prefixsz</code></em> can be zero (in which case
    <em class="parameter"><code>*prefix</code></em> will be set to NULL). The space for
    prefix and name is allocated using <code class="function">malloc()</code>,
    it is up to the user of this function to free them when no longer
    in use.</p><div class="funcsynopsis"><a name="fn.cdb_get_list"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_list</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t **<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int *<var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read values of a YANG <code class="code">leaf-list</code>. The function will
    <code class="function">malloc()</code> an array of <span class="type">confd_value_t</span>
    elements for the list, and return a pointer to the array via the
    <em class="parameter"><code>**values</code></em> parameter and the length of the
    array via the <em class="parameter"><code>*n</code></em> parameter. The caller must
    free the memory for the values (see <code class="function">cdb_get()</code>)
    and the array itself. An example that reads and prints the elements
    of a list of strings:</p><div class="informalexample"><pre class="programlisting">confd_value_t *values;
int i, n;

cdb_get_list(sock, &amp;values, &amp;n, "/system/cards");
for (i = 0; i &lt; n; i++) {
    printf("card %d: %s\n", i, CONFD_GET_BUFPTR(&amp;values[i]));
    confd_free_value(&amp;values[i]);
}
free(values);</pre></div><div class="funcsynopsis"><a name="fn.cdb_get_ipv4prefix"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv4prefix</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv4_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">inet:ipv4-prefix</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_ipv6prefix"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv6prefix</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv6_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">inet:ipv6-prefix</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_decimal64"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_decimal64</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_decimal64 *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">decimal64</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_identityref"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_identityref</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_identityref *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">identityref</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_get_ipv4_and_plen"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv4_and_plen</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv4_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">tailf:ipv4-address-and-prefix-length</span>
    values.</p><div class="funcsynopsis"><a name="fn.cdb_get_ipv6_and_plen"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_ipv6_and_plen</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_ipv6_prefix *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">tailf:ipv6-address-and-prefix-length</span>
    values.</p><div class="funcsynopsis"><a name="fn.cdb_get_dquad"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_dquad</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>struct confd_dotted_quad *<var class="pdparam">rval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Type safe variant of <code class="function">cdb_get()</code> which is
    used to read <span class="type">yang:dotted-quad</span> values.</p><div class="funcsynopsis"><a name="fn.cdb_vget"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_vget</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">v</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>va_list <var class="pdparam">args</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function does the same as
    <code class="function">cdb_get()</code>, but takes a single <span class="type">va_list</span>
    argument instead of a variable number of arguments - i.e. similar
    to <code class="function">vprintf()</code>. Corresponding
    <span class="type">va_list</span> variants exist for all the functions that take
    a path as a variable number of arguments.</p><div class="funcsynopsis"><a name="fn.cdb_get_object"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_object</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>In some cases it can be motivated to read multiple values in
    one request - this will be more efficient since it only incurs a
    single round trip to ConfD, but usage is a bit more complex.  This
    function reads at most <em class="parameter"><code>n</code></em> values from the
    container or list entry specified by the path, and places them in the
    <em class="parameter"><code>values</code></em> array, which is provided by the
    caller. The array is populated according to the specification of
    the <span class="emphasis"><em>Value Array</em></span> format in the <span class="emphasis"><em>XML
    STRUCTURES</em></span> section of the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
    page.</p><p>When reading from a container or list entry with mixed
    configuration and operational data (i.e. a config container or list
    entry that has some number of
    operational elements), some elements will have the "wrong" type -
    i.e. operational data in a session for CDB_RUNNING/CDB_STARTUP, or
    config data in a session for CDB_OPERATIONAL. Leaf elements of the
    "wrong" type will have a "value" of C_NOEXISTS in the array, while
    static or (existing) optional sub-container elements will have
    C_XMLTAG in all cases. Sub-containers or leafs provided by external
    data providers will always be represented with C_NOEXISTS, whether
    config or not.</p><p>On success, the function returns the actual number of
    elements in the container or list entry.
    I.e. if the return value is bigger than
    <em class="parameter"><code>n</code></em>, only the values for the first
    <em class="parameter"><code>n</code></em> elements are in the array, and the
    remaining values have been discarded. Note that given the
    specification of the array contents, there is always a fixed upper
    bound on the number of actual elements, and if there are no
    presence sub-containers, the number is constant.</p><p>As an example, with the YANG fragment in the <a class="link" href="rn02re09.html#man.3.confd_lib_cdb.paths" title="PATHS">PATHS</a> section above,
    this code could be used to read the values for interface "eth0" on
    host "buzz":</p><div class="informalexample"><pre class="programlisting">char *path = "/hosts/host{buzz}/interfaces/interface{%s}";
confd_value_t v[4];
struct in_addr ip, mask;
int enabled;

cdb_get_object(sock, v, 4, path, "eth0");
/* v[0] is interface name, already known
   - must be freed since it's a C_BUF   */
confd_free_value(&amp;v[0]);
ip = CONFD_GET_IPV4(&amp;v[1]);
mask = CONFD_GET_IPV4(&amp;v[2]);
enabled = CONFD_GET_BOOL(&amp;v[3]);</pre></div><p>In this simple example, we assumed that the application was
    aware of the details of the data model, specifically that a
    <span class="type">confd_value_t</span> array of length 4 would be sufficient for
    the values we wanted to retrieve, and at which positions in the
    array those values could be found. If we make use of schema
    information loaded from the ConfD daemon into the library (see <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a>), we can avoid
    "hardwiring" these details. The following, more complex, example
    does the same as the above, but using only the names (in the form of
    #defines from the header file generated by <span class="command"><strong>confdc
    --emit-h</strong></span>) of the relevant leafs:</p><div class="informalexample"><pre class="programlisting">char *path = "/hosts/host{buzz}/interfaces/interface{%s}";
struct confd_cs_node *object = confd_cs_node_cd(NULL, path);
struct confd_cs_node *cur;
int n = confd_max_object_size(object);
int i;
confd_value_t v[n];
struct in_addr ip, mask;
int enabled;

cdb_get_object(sock, v, n, path, "eth0");
for (cur = object-&gt;children, i = 0;
     cur != NULL;
     cur = confd_next_object_node(object, cur, &amp;v[i]), i++) {
    switch (cur-&gt;tag) {
    case hst_ip:
        ip = CONFD_GET_IPV4(&amp;v[i]);
        break;
    case hst_mask:
        mask = CONFD_GET_IPV4(&amp;v[i]);
        break;
    case hst_enabled:
        enabled = CONFD_GET_BOOL(&amp;v[i]);
        break;
    }
    /* always free - it is a no-op if not needed */
    confd_free_value(&amp;v[i]);
}</pre></div><p>See <a class="link" href="rn02re13.html" title="confd_lib_lib">confd_lib_lib(3)</a> for the
    specification of the <code class="function">confd_max_object_size()</code>
    and <code class="function">confd_next_object_node()</code> functions. Also
    worth noting is that the return value from
    <code class="function">confd_max_object_size()</code> is a constant for a
    given node in a given data model - thus we could optimize the above
    by calling <code class="function">confd_max_object_size()</code> only at the
    first invocation of <code class="function">cdb_get_object()</code> for a
    given node, making use of the <code class="varname">opaque</code> element of
    <span class="type">struct confd_cs_node</span> to store the value:</p><div class="informalexample"><pre class="programlisting">char *path = "/hosts/host{buzz}/interfaces/interface{%s}";
struct confd_cs_node *object = confd_cs_node_cd(NULL, path);
int n;
struct in_addr ip, mask;
int enabled;

if (object-&gt;opaque == NULL) {
    n = confd_max_object_size(object);
    object-&gt;opaque = (void *)n;
} else {
    n = (int)object-&gt;opaque;
}

{
    struct confd_cs_node *cur;
    confd_value_t v[n];
    int i;

    cdb_get_object(sock, v, n, path, "eth0");
    for (cur = object-&gt;children, i = 0;
         cur != NULL;
         cur = confd_next_object_node(object, cur, &amp;v[i]), i++) {
        ...
    }
}</pre></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH</p><div class="funcsynopsis"><a name="fn.cdb_get_objects"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_objects</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">ix</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">nobj</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Similar to <code class="function">cdb_get_object()</code>, but reads
    multiple entries of a list based on the "instance
    integer" otherwise given within square brackets in the path - here
    the path must specify the list without the instance
    integer.  At most <em class="parameter"><code>n</code></em> values from each of
    <em class="parameter"><code>nobj</code></em> entries, starting at entry
    <em class="parameter"><code>ix</code></em>, are read and placed in the
    <em class="parameter"><code>values</code></em> array.</p><p>The array must be at least <code class="code">n * nobj</code> elements
    long, and the values for list entry <code class="code">ix + i</code> start at
    element <code class="code">array[i * n]</code> (i.e. <code class="code">ix</code> starts at
    <code class="code">array[0]</code>, <code class="code">ix+1</code> at <code class="code">array[n]</code>,
    and so on). On success, the highest actual number of values in any
    of the list entries read is returned.  An error (CONFD_ERR_NOEXISTS)
    will be returned if we attempt to read more entries than
    actually exist (i.e. if <code class="code">ix + nobj - 1</code> is outside the
    range of actually existing list entries). Example - read the data for
    all interfaces on the host "buzz" (assuming that we have memory
    enough for that):</p><div class="informalexample"><pre class="programlisting">char *path = "/hosts/host{buzz}/interfaces/interface";
int n;

n = cdb_num_instances(sock, path);
{
    confd_value_t v[n*4];
    char name[n][64];
    struct in_addr ip[n], mask[n];
    int enabled[n];
    int i;

    cdb_get_objects(sock, v, 4, 0, n, path);
    for (i = 0; i &lt; n*4; i += 4) {
        confd_pp_value(&amp;name[i][0], 64, &amp;v[i]);
        /* value must be freed since it's a C_BUF */
        confd_free_value(&amp;v[i]);
        ip[i] = CONFD_GET_IPV4(&amp;v[i+1]);
        mask[i] = CONFD_GET_IPV4(&amp;v[i+2]);
        enabled[i] = CONFD_GET_BOOL(&amp;v[i+3]);
    }

    /* configure interfaces... */
}</pre></div><p>This simple example can of course be enhanced to use loaded
    schema information in a similar manner as for
    <code class="function">cdb_get_object()</code> above.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_get_values"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_values</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Read an arbitrary set of sub-elements of a container
    or list entry. The <em class="parameter"><code>values</code></em> array must be
    pre-populated with <em class="parameter"><code>n</code></em> values based on the
    specification of the <span class="emphasis"><em>Tagged Value Array</em></span>
    format in the <span class="emphasis"><em>XML STRUCTURES</em></span> section of the
    <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
    page, where the <span class="type">confd_value_t</span> value element is given
    as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>C_NOEXISTS means that the value should be read from CDB
        and stored in the array.</p></li><li class="listitem"><p>C_PTR also means that the value should be read from CDB,
        but instead gives the expected type and a pointer to the
        type-specific variable where the value should be stored.  Thus
        this gives a functionality similar to the type safe versions
        of <code class="function">cdb_get()</code>.</p></li><li class="listitem"><p>C_XMLBEGIN and C_XMLEND are used as per the
        specification.</p></li><li class="listitem"><p>Key values to select list entries can
        be given with their values.</p></li><li class="listitem"><p>As a special case, the "instance integer" can be used to
        select a list entry by using C_CDBBEGIN instead of
        C_XMLBEGIN (and no key values).</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When we use C_PTR, we need to take special care to free
    any allocated memory. When we use C_NOEXISTS and the value is stored
    in the array, we can just use
    <code class="function">confd_free_value()</code> regardless of the type,
    since the <span class="type">confd_value_t</span> has the type information. But
    with C_PTR, only the actual value is stored in the pointed-to
    variable, just as for <code class="function">cdb_get_buf()</code>,
    <code class="function">cdb_get_binary()</code>, etc, and we need to free the
    memory specifically allocated for the types listed in the
    description of <code class="function">cdb_get()</code> above. See the
    corresponding <code class="function">cdb_get_xxx()</code> functions for the
    details of how to do this.</p></div><p>All elements have the same position in the array after the
    call, in order to simplify extraction of the values - this means
    that optional elements that were requested but didn't exist will
    have C_NOEXISTS rather than being omitted from the array. However
    requesting a list entry that doesn't exist, or requesting
    non-CDB data, or operational vs config data, is an error. Note
    that when using C_PTR, the only indication of a non-existing value
    is that the destination variable has not been modified - it's up
    to the application to set it to some "impossible" value before the
    call when optional leafs are read.</p><p>In this rather complex example we first read only the "name"
    and "enabled" values for all interfaces, and then read "ip" and
    "mask" for those that were enabled - a total of two requests. Note
    that since the "interface" list begin/end elements are in the
    array, the path must not include the "interface" component. When
    reading values from a single container, it is generally simpler to
    have the container component (and keys or instance integer) in the
    path instead.</p><div class="informalexample"><pre class="programlisting">char *path = "/hosts/host{buzz}/interfaces";
int n = cdb_num_instances(sock, "%s/interface", path);
{
  /* when reading ip/mask, we need 5 elements per interface:
     begin + name (key) + ip + mask + end                    */
  confd_tag_value_t tv[n*5];
  char name[n][64];
  struct in_addr ip[n], mask[n];
  int i, j;
  int n_if;

  /* read name and enabled for all interfaces */
  j = 0;
  for (i = 0; i &lt; n; i++) {
    CONFD_SET_TAG_CDBBEGIN(&amp;tv[j], hst_interface, hst__ns, i); j++;
    CONFD_SET_TAG_NOEXISTS(&amp;tv[j], hst_name);                  j++;
    CONFD_SET_TAG_NOEXISTS(&amp;tv[j], hst_enabled);               j++;
    CONFD_SET_TAG_XMLEND(&amp;tv[j], hst_interface, hst__ns);      j++;
  }
  cdb_get_values(sock, tv, j, path);

  /* extract name for enabled interfaces */
  j = 0;
  for (i = 0; i &lt; n*4; i += 4) {
    int enabled = CONFD_GET_BOOL(CONFD_GET_TAG_VALUE(&amp;tv[i+2]));
    confd_value_t *v = CONFD_GET_TAG_VALUE(&amp;tv[i+1]);
    if (enabled) {
      confd_pp_value(&amp;name[j][0], 64, v);
      j++;
    }
    /* name must be freed regardless since it's a C_BUF */
    confd_free_value(v);
  }
  n_if = j;

  /* read ip and mask for enabled interfaces by key value (name) */
  j = 0;
  for (i = 0; i &lt; n_if; i++) {
    CONFD_SET_TAG_XMLBEGIN(&amp;tv[j], hst_interface, hst__ns);    j++;
    CONFD_SET_TAG_STR(&amp;tv[j], hst_name, &amp;name[i][0]);          j++;
    CONFD_SET_TAG_PTR(&amp;tv[j], hst_ip, C_IPV4, &amp;ip[i]);         j++;
    CONFD_SET_TAG_PTR(&amp;tv[j], hst_mask, C_IPV4, &amp;mask[i]);     j++;
    CONFD_SET_TAG_XMLEND(&amp;tv[j], hst_interface, hst__ns);      j++;
  }
  cdb_get_values(sock, tv, j, path);

  for (i = 0; i &lt; n_if; i++) {
    /* configure interface i with ip[i] and mask[i]... */
  }
}</pre></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_get_case"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_get_case</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">choice</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">rcase</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>When we use the YANG <code class="code">choice</code> statement in the
    data model, this function can be used to find the currently selected
    <code class="code">case</code>,
    avoiding useless <code class="function">cdb_get()</code> etc requests for
    elements that belong to other cases.  The <em class="parameter"><code>fmt,
    ...</code></em> arguments give the path to the container or list
    entry where the
    choice is defined, and <em class="parameter"><code>choice</code></em> is the name
    of the choice.  The case value is returned to the
    <span class="type">confd_value_t</span> that <em class="parameter"><code>rcase</code></em>
    points to, as type C_XMLTAG - i.e. we can use the
    <code class="function">CONFD_GET_XMLTAG()</code> macro to retrieve the
    hashed tag value.  If no case is currently selected (i.e. for an
    optional choice that doesn't have a default case), the function
    will fail with CONFD_ERR_NOEXISTS.</p><p>If we have "nested" choices, i.e. multiple levels of
    <code class="code">choice</code> statements without intervening
    <code class="code">container</code> or <code class="code">list</code> statements in the data
    model, the <em class="parameter"><code>choice</code></em> argument must give a
    '/'-separated path with alternating choice and case names, from the
    data node given by the <em class="parameter"><code>fmt, ...</code></em> arguments to
    the specific choice that the request pertains to.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOEXISTS</p></div><div class="refsect1"><a name="man.3.confd_lib_cdb.operational_data"></a><h2>OPERATIONAL DATA</h2><p>It is possible for an application to store operational data
    (i.e. status and statistical information) in CDB, instead of
    providing it on demand via the callback interfaces described in
    the <a class="link" href="rn02re10.html" title="confd_lib_dp">confd_lib_dp(3)</a> manual
    page. The operational database has no transactions and normally
    avoids the use of locks in order to provide light-weight access
    methods, however when the multi-value API functions below are
    used, all updates requested by a given function call are carried
    out atomically. Read about how to specify the storage of
    operational data in CDB via the <code class="code">tailf:cdb-oper</code>
    extension in the <a class="link" href="rn03re20.html" title="tailf_yang_extensions">tailf_yang_extensions(5)</a>
    manual page.</p><p>To establish a session for operational data, the application
    needs to use <code class="function">cdb_connect()</code> with
    CDB_DATA_SOCKET and <code class="function">cdb_start_session()</code> with
    CDB_OPERATIONAL. After this, all the read and access functions
    above are available for use with operational data, and
    additionally the write functions described below.  Configuration
    data can not be accessed in a session for operational data, nor
    vice versa - however it is possible to have both types of sessions
    active simultaneously on two different sockets, or to alternate
    the use of one socket via
    <code class="function">cdb_end_session()</code>. The write functions can
    never be used in a session for configuration data.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In order to trigger subscriptions on operational data,
    we must obtain a subscription lock via the use of
    <code class="function">cdb_start_session2()</code> instead of
    <code class="function">cdb_start_session()</code>, see above.</p></div><p>In YANG it is possible to define a list of operational data
    without any keys. For this type of list, we use a single "pseudo"
    key which is always of type C_INT64 - see the <a class="link" href="ch06.html#ug.opdata.without_keys" title="6.11.&nbsp;Operational data lists without keys">Operational Data chapter in the
    User Guide</a>. This key isn't visible in the northbound agent
    interfaces, but is used in the functions described here just as if
    it was a "normal" key.</p><div class="funcsynopsis"><a name="fn.cdb_set_elem"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_elem</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">val</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><div class="funcsynopsis"><a name="fn.cdb_set_elem2"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_elem2</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">strval</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>There are two different functions to set the value of a
    single leaf.  The first takes the value from a
    <span class="type">confd_value_t</span> struct, the second takes the string
    representation of the value.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE, CONFD_ERR_NOT_WRITABLE</p><div class="funcsynopsis"><a name="fn.cdb_vset_elem"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_vset_elem</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>confd_value_t *<var class="pdparam">val</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>va_list <var class="pdparam">args</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>This function does the same as
    <code class="function">cdb_set_elem()</code>, but takes a single
    <span class="type">va_list</span> argument instead of a variable number of
    arguments - i.e. similar to
    <code class="function">vprintf()</code>. Corresponding <span class="type">va_list</span>
    variants exist for all the functions that take a path as a variable
    number of arguments.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE,
    CONFD_ERR_NOT_WRITABLE</p><div class="funcsynopsis"><a name="fn.cdb_create"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_create</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Create a new list entry, presence container, or leaf of type
    <code class="code">empty</code>. Note that for list entries and
    containers, sub-elements will not exist until created or
    set via some of the other functions, thus doing implicit create
    via <code class="function">cdb_set_object()</code> or
    <code class="function">cdb_set_values()</code> may be preferred in this
    case.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOTCREATABLE,
    CONFD_ERR_ALREADY_EXISTS</p><div class="funcsynopsis"><a name="fn.cdb_delete"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_delete</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Delete a list entry, presence container, or leaf of type
    <code class="code">empty</code>, and all its child
    elements (if any).</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOT_WRITABLE, CONFD_ERR_NOTDELETABLE,
    CONFD_ERR_NOEXISTS</p><div class="funcsynopsis"><a name="fn.cdb_set_object"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_object</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Set all elements corresponding to the complete contents of a
    container or list entry, except for sub-lists. The
    <em class="parameter"><code>values</code></em> array must be populated with
    <em class="parameter"><code>n</code></em> values according to the specification of
    the <span class="emphasis"><em>Value Array</em></span> format in the <span class="emphasis"><em>XML
    STRUCTURES</em></span> section of the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
    page.</p><p>If the container or list entry itself, or any sub-elements
    that are specified as existing, do not exist before this call, they
    will be created, otherwise the existing values will be updated.
    Non-mandatory leafs and presence containers that are specified as
    not existing in the array, i.e. with value C_NOEXISTS, will be
    deleted if they existed before the call.</p><p>When writing to a container with mixed configuration and
    operational data (i.e. a config container or list entry that has
    some number of operational elements), all config leaf elements must
    be specified
    as C_NOEXISTS in the corresponding array elements, while config
    sub-container elements are specified with C_XMLTAG just as for
    operational data.</p><p>For a list entry, since the key elements must be
    present in the array, it is not required that the key values are
    included in the path given by <em class="parameter"><code>fmt</code></em>. If the key
    values <span class="emphasis"><em>are</em></span> included in the path, the values
    of the key elements in the array are ignored.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE,
    CONFD_ERR_NOT_WRITABLE</p><div class="funcsynopsis"><a name="fn.cdb_set_values"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_values</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const confd_tag_value_t *<var class="pdparam">values</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">n</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Set arbitrary sub-elements of a container or list entry. The
    <em class="parameter"><code>values</code></em> array must be populated with
    <em class="parameter"><code>n</code></em> values according to the specification of
    the <span class="emphasis"><em>Tagged Value Array</em></span> format in the
    <span class="emphasis"><em>XML STRUCTURES</em></span> section of the <a class="link" href="rn02re15.html" title="confd_types">confd_types(3)</a> manual
    page.</p><p>If the container or list entry itself, or any sub-elements that
    are specified as existing, do not exist before this call, they
    will be created, otherwise the existing values will be
    updated. Both mandatory and optional elements may be omitted
    from the array, and all omitted elements are left unchanged. To
    actually delete a non-mandatory leaf or presence container as
    described for
    <code class="function">cdb_set_object()</code>, it may (as an extension of
    the format) be specified as C_NOEXISTS instead of being
    omitted.</p><p>For a list entry, the key values can be specified
    either in the path or via key elements in the array - if the
    values are in the path, the key elements can be omitted from the
    array. For sub-lists present in the array, the key
    elements must of course always also be present though, immediately
    following the C_XMLBEGIN element and in the order defined by the
    data model. It is also possible to delete a list entry by using a
    C_XMLBEGINDEL element, followed by the keys in data model order,
    followed by a C_XMLEND element.</p><p>For a list without keys (see above), the "pseudo" key may (or
    in some cases must) be present in the array, but of course there is
    no tag value for it, since it isn't present in the data model. In
    this case we must use a tag value of 0, i.e. it can be set with code
    like:</p><div class="informalexample"><pre class="programlisting">confd_tag_value_t tv[7];

CONFD_SET_TAG_INT64(&amp;tv[1], 0, 42);
</pre></div><p>The same method is used when reading data from such a list
    with the <code class="function">cdb_get_values()</code> function described
    above.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_BADTYPE,
    CONFD_ERR_NOT_WRITABLE</p><div class="funcsynopsis"><a name="fn.cdb_set_case"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_set_case</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">choice</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">scase</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">fmt</var>, </td></tr><tr><td>&nbsp;</td><td>...<code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>When we use the YANG <code class="code">choice</code> statement in the
    data model, this function can be used to select the current
    <code class="code">case</code>. When
    configuration data is modified by northbound agents, the current
    case is implicitly selected (and elements for other cases
    potentially deleted) by the setting of elements in a choice. For
    operational data in CDB however, this is under direct control of
    the application, which needs to explicitly set the current
    case. Setting the case will also automatically delete elements
    belonging to other cases, but it is up to the application to not
    set any elements in the "wrong" case.</p><p>The <em class="parameter"><code>fmt, ...</code></em> arguments give the path
    to the container or list entry where the choice is defined, and
    <em class="parameter"><code>choice</code></em> and <em class="parameter"><code>scase</code></em> are
    the choice and case names.  For an optional choice, it is possible
    to have no case at all selected.  To indicate that the previously
    selected case should be deleted without selecting another case, we
    can pass NULL for the <em class="parameter"><code>scase</code></em>
    argument.</p><p>If we have "nested" choices, i.e. multiple levels of
    <code class="code">choice</code> statements without intervening
    <code class="code">container</code> or <code class="code">list</code> statements in the data
    model, the <em class="parameter"><code>choice</code></em> argument must give a
    '/'-separated path with alternating choice and case names, from the
    data node given by the <em class="parameter"><code>fmt, ...</code></em> arguments to
    the specific choice that the request pertains to.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_BADPATH, CONFD_ERR_NOTDELETABLE</p><div class="funcsynopsis"><a name="fn.cdb_load_file"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_load_file</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">filename</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Load operational data from <em class="parameter"><code>filename</code></em>
    into CDB operational. The file must be in xml format, and
    <em class="parameter"><code>sock</code></em> must be connected to CDB operational
    (i.e. <code class="function">cdb_start_session()</code> or
    <code class="function">cdb_start_session2()</code> must have been called with
    CDB_OPERATIONAL). If the file contains config data, or operational
    data not residing in CDB, that data will be silently ignored. If the
    name of the file ends in .gz (or .Z) then the file is assumed to be
    gzipped, and will be uncompressed as it is loaded.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you use a relative pathname for
    <em class="parameter"><code>filename</code></em>, it is taken as relative to the
    working directory of the ConfD daemon, i.e. the directory where the
    daemon was started.</p></div><p>Note that there are no transactions in CDB operational, so
    there will not be any validation or transactional commit of the
    file. However the file will be completely parsed before CDB tries
    to set the values, with the result that any errors in the file
    will abort the operation without changing anything in CDB
    operational.</p><p>The flags parameter is currently not used, and should be set
    to 0.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This function is DEPRECATED. Use
      <code class="function">maapi_load_config()</code> instead.</p></div><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOT_WRITABLE, CONFD_ERR_BADPATH, CONFD_ERR_EXTERNAL</p><div class="funcsynopsis"><a name="fn.cdb_load_str"></a><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">cdb_load_str</b>(</code></td><td>int <var class="pdparam">sock</var>, </td></tr><tr><td>&nbsp;</td><td>const char *<var class="pdparam">xml_str</var>, </td></tr><tr><td>&nbsp;</td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&nbsp;</div></div><p>Load operational data from the string
    <em class="parameter"><code>xml_str</code></em> into CDB operational. I.e.  instead
    of having the xml data read from a file as for
    <code class="function">cdb_load_file()</code>, it is passed as a string to
    the function. Besides this, the function works the same as
    <code class="function">cdb_load_file()</code>.</p><p><span class="emphasis"><em>Errors</em></span>: CONFD_ERR_MALLOC, CONFD_ERR_OS,
    CONFD_ERR_NOT_WRITABLE, CONFD_ERR_EXTERNAL</p></div><div class="refsect1"><a name="man.3.confd_lib_cdb.see_also"></a><h2>SEE ALSO</h2><p><span class="citerefentry"><span class="refentrytitle">confd_lib</span>(3)</span>
    - Confd lib</p><p><span class="citerefentry"><span class="refentrytitle">confd_types</span>(3)</span>
    - ConfD C data types</p><p>The ConfD User Guide</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rn02re08.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="rn02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="rn02re10.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">confd_lib&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;confd_lib_dp</td></tr></table></div></body></html>