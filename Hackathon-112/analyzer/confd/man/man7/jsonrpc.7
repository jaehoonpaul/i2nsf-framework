.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "JSONRPC" "" "February 2016" "" ""
.
.SH "PROTOCOL OVERVIEW"
The JSON\-RPC 2\.0 Specification \fIhttp://www\.jsonrpc\.org/specification\fR contains all the details you need in order to understand the protocol but here is the short version\.
.
.P
A request payload typically looks like this:
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "method": "subtract",
 "params": [42, 23]}
.
.fi
.
.IP "" 0
.
.P
where the \fBmethod\fR and \fBparams\fR properties are as defined in this manual page\.
.
.P
A response payload typically looks like this:
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": 19}
.
.fi
.
.IP "" 0
.
.P
or
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "error":
 {"code": \-32601,
   "type": "rpc\.request\.method\.not_found",
   "message": "Method not found"}}
.
.fi
.
.IP "" 0
.
.P
The request \fBid\fR param is returned as\-is in the response to make it easy to pair requests and responses\.
.
.P
The batch JSON\-RPC standard is dependent on matching requests and responses by \fBid\fR, since the server processes requests in any order it sees fit e\.g\.:
.
.IP "" 4
.
.nf

[{"jsonrpc": "2\.0",
  "id": 1,
  "method": "subtract",
  "params": [42, 23]}
,{"jsonrpc": "2\.0",
  "id": 2,
  "method": "add",
  "params": [42, 23]}]
.
.fi
.
.IP "" 0
.
.P
with a possible response like (first result for "add", second result for "substract"):
.
.IP "" 4
.
.nf

[{"jsonrpc": "2\.0",
  "id": 2,
  "result": 65}
,{"jsonrpc": "2\.0",
  "id": 1,
  "result": 19}]
.
.fi
.
.IP "" 0
.
.SH "COMMON CONCEPTS"
The URL for the JSON\-RPC API is \fB/jsonrpc\fR\. For logging and debugging purposes, you can add anything as a subpath to the URL, for example turning the URL into \fB/jsonrpc/<method>\fR which will allow you to see the exact method in different browsers\' \fIDeveloper Tools\fR \- \fINetwork\fR tab \- \fIName\fR column, rather than just an opaque "jsonrpc"\.
.
.P
For brevity, in the upcoming descriptions of each methods, only the input \fBparams\fR and the output \fBresult\fR are mentioned, although they are part of a fully formed JSON\-RPC payload\.
.
.P
Authorization is based on HTTP cookies\. The response to a successful call to \fBlogin\fR would create a session, and set a HTTP\-only cookie, and even a HTTP\-only secure cookie over HTTPS, named \fBsessionid\fR\. All subsequent calls are authorized by the presence and the validity of this cookie\.
.
.P
The \fBth\fR param is a transaction handle identifier as returned from a call to \fBnew_read_trans\fR or \fBnew_write_trans\fR\.
.
.P
The \fBcomet_id\fR param is a unique id (decided by the client) which must be given first in a call to the \fBcomet\fR method, and then to upcoming calls which trigger comet notifications\.
.
.P
The \fBhandle\fR param needs to a semantic value (not just a counter) prefixed with the comet id (for disambiguation), and overrides the handle that would have otherwise been returned by the call\. This gives more freedom to the client and set semantic handles\.
.
.SS "COMMON ERRORS"
The JSON\-RPC specification defines the following error \fBcode\fR values:
.
.IP "\(bu" 4
\-32700 \- Invalid JSON was received by the server\. An error occurred on the server while parsing the JSON text\.
.
.IP "\(bu" 4
\-32600 \- The JSON sent is not a valid Request object\.
.
.IP "\(bu" 4
\-32601 \- The method does not exist / is not available\.
.
.IP "\(bu" 4
\-32602 \- Invalid method parameter(s)\.
.
.IP "\(bu" 4
\-32603 \- Internal JSON\-RPC error\.
.
.IP "\(bu" 4
\-32000 to \-32099 \- Reserved for application defined errors (see below)
.
.IP "" 0
.
.P
To make server errors easier to read, along the numeric \fBcode\fR, we use a \fBtype\fR param that yields a literal error token\. For all application defined errors, the \fBcode\fR is always \-32000\. It\'s best to ignore the \fBcode\fR and just use the \fBtype\fR param\.
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "method": "login",
 "params":
 {"foo": "joe",
  "bar": "SWkkasE32"}}
.
.fi
.
.IP "" 0
.
.P
which results in:
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "error":
 {"code": \-32602,
  "type": "rpc\.method\.unexpected_params",
  "message": "Unexpected params",
  "data":
  {"param": "foo"}}}
.
.fi
.
.IP "" 0
.
.P
The \fBmessage\fR param is a free text string in English meant for human consumption, which is a one\-to\-one match with the \fBtype\fR param\. To remove noise from the examples, this param is omitted from the following descriptions\.
.
.P
An additional method\-specific \fBdata\fR param may be added to give further details on the error, most predominantly a \fBreason\fR param which is also a free text string in English meant for human consumption\. To remove noise from the examples, this param is omitted from the following descriptions\. But any additional \fBdata\fR params will be noted by each method description\.
.
.SS "APPLICATION DEFINED ERRORS"
All methods may return one of the following JSON RPC or application defined errors, in addition to others, specific to each method\.
.
.IP "" 4
.
.nf

{"type": "rpc\.request\.parse_error"}
{"type": "rpc\.request\.invalid"}
{"type": "rpc\.method\.not_found"}
{"type": "rpc\.method\.invalid_params", "data": {"param": <string>}}
{"type": "rpc\.internal_error"}


{"type": "rpc\.request\.eof_parse_error"}
{"type": "rpc\.request\.multipart_broken"}
{"type": "rpc\.request\.too_big"}
{"type": "rpc\.request\.method_denied"}


{"type": "rpc\.method\.unexpected_params", "data": {"param": <string>}}
{"type": "rpc\.method\.invalid_params_type", "data": {"param": <string>}}
{"type": "rpc\.method\.missing_params", "data": {"param": <string>}}
{"type": "rpc\.method\.unknown_params_value", "data": {"param": <string>}}


{"type": "rpc\.method\.failed"}
{"type": "rpc\.method\.denied"}
{"type": "rpc\.method\.timeout"}

{"type": "session\.missing_sessionid"}
{"type": "session\.invalid_sessionid"}
{"type": "session\.overload"}
.
.fi
.
.IP "" 0
.
.SH "FAQ"
.
.SS "WHAT ARE THE SECURITY CHARACTERISTICS OF THE JSON\-RPC API?"
JSON\-RPC runs on top the embedded web server (see "The web server" chapter), which accepts HTTP and/or HTTPS\.
.
.P
The JSON\-RPC session ties the client and the server via an HTTP cookie, named "sessionid" which contains a randomly server\-generated number\. This cookie is not only secure (when the requests come over HTTPS), meaning that HTTPS cookies do not leak over HTTP, but even more importantly this cookie is also http\-only, meaning that only the server and the browser (e\.g\. not the JavaScript code) have access to the cookie\. Furthermore, this cookie is a session cookie, meaning that a browser restart would delete the cookie altogether\.
.
.P
The JSON\-RPC session lives as long as the user does not request to logout, as long as the user is active within a 30 minute (default value, which is configurable) time frame, as long as there are no severe server crashes\. When the session dies, the server will reply with the intention to delete any "sessionid" cookies stored in the browser (to prevent any leaks)\.
.
.P
When used in a browser, the JSON\-RPC API does not accept cross\-domain requests by default, but can be configured to do so via the custom headers functionality in the embedded web server, or by adding a reverse\-proxy (see "The web server" chapter)\.
.
.SS "WHAT IS THE PROPER WAY TO USE THE JSON\-RPC API IN A CORS SETUP?"
The embedded server allows for custom headers to be se, in this case CORS headers, like:
.
.IP "" 4
.
.nf

Access\-Control\-Allow\-Origin: http://webpage\.com
Access\-Control\-Allow\-Credentials: true
Access\-Control\-Allow\-Headers: Origin, Content\-Type, Accept
Access\-Control\-Request\-Method: POST
.
.fi
.
.IP "" 0
.
.P
A server hosted at http://server\.com responding with these headers, would mean that the JSON\-RPC API can be contacted from a browser which is showing a web page from http://webpage\.com, and will allow the browser to make POST requests, with a limited amount of headers and with credentials (i\.e\. cookies)\.
.
.P
This is not enough though, because the browser also needs to be told that your JavaScript code really wants to make a CORS request\. A jQuery example would show like this:
.
.IP "" 4
.
.nf

// with jQuery
$\.ajax({
  type: \'post\',
  url: \'http://server\.com/jsonrpc\',
  contentType: \'application/json\',
  data: JSON\.stringify({
    jsonrpc: \'2\.0\',
    id: 1,
    method: \'login\',
    params: {
      \'user\': \'joe\',
      \'passwd\': \'SWkkasE32\'
    }
  }),
  dataType: \'json\',
  crossDomain: true,       // CORS specific
  xhrFields: {             // CORS specific
    withCredentials: true  // CORS specific
  }                        // CORS specific
})
.
.fi
.
.IP "" 0
.
.P
Without this setup, you will notice that the browser will not send the "sessionid" cookie on post\-login JSON\-RPC calls\.
.
.SS "WHAT IS A TAG/KEYPATH?"
A \fBtagpath\fR is a path pointing to a specific position in a YANG module\'s schema\.
.
.P
A \fBkeypath\fR is a path pointing to specific position in a YANG module\'s instance\.
.
.P
These kind of paths are used for several of the API methods (e\.g\. \fBset_value\fR, \fBget_value\fR, \fBsubscribe_changes\fR), and could be seen as XPath path specifications in abbreviated format\.
.
.P
Lets look at some examples using the following YANG module as input:
.
.IP "" 4
.
.nf

module devices {
    namespace "http://acme\.com/ns/devices";
    prefix d;

    container config {
        leaf description { type string; }
        list device {
            key "interface";
            leaf interface { type string; }
            leaf date { type string; }
        }
    }
}
.
.fi
.
.IP "" 0
.
.P
Valid tagpaths:
.
.IP "\(bu" 4
\fB/d:config/description\fR
.
.IP "\(bu" 4
\fB/d:config/device/interface\fR
.
.IP "" 0
.
.P
Valid keypaths:
.
.IP "\(bu" 4
\fB/d:config/device{eth0}/date\fR \- the date leaf value within a device with an \fBinterface\fR key set to \fBeth0\fR
.
.IP "" 0
.
.P
Note how the prefix is prepended to the first tag in the path\. This prefix is compulsory\.
.
.SS "RESTRICTING ACCESS TO METHODS"
The AAA infrastructure can be used to restrict access to library functions using command rules:
.
.IP "" 4
.
.nf

<cmdrule xmlns="http://tail\-f\.com/yang/acm">
  <name>webui</name>
  <context xmlns="http://tail\-f\.com/yang/acm">webui</context>
  <command>::jsonrpc:: get_schema</command>
  <access\-operations>read exec</access\-operations>
  <action>deny</action>
</cmdrule>
.
.fi
.
.IP "" 0
.
.P
Note how the command is prefixed with "::jsonrpc:: "\. This tells the AAA engine to apply the command rule to JSON\-RPC API functions\.
.
.P
You can read more about command rules in "The AAA infrastructure" chapter in this User Guide\.
.
.SS "What is session\.overload error?"
A series of limits are imposed on the load that one session can put on the system\.
.
.P
This reduces the risk that a session takes overs the whole system and brings it into a DoS situation\.
.
.P
The response will include details about the limit that triggered the error\.
.
.P
Known limits:
.
.SH "\- only 10000 commands/subscriptions are allowed per session"
date: 2014\-03\-07 layout: post title: API \- Commands description: "Reference and usage examples of the API \- Commands\." modified:
.
.SH "tags: [api, commands]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_cmds\fR \- Get a list of all the session\'s batch commands
.
.IP "\(bu" 4
\fIinit_cmd\fR \- Starts a batch command
.
.IP "\(bu" 4
\fIsend_cmd_data\fR \- Sends data to batch command started with \fBinit_cmd\fR
.
.IP "\(bu" 4
\fIstart_cmd\fR \- Signals that a batch command can start to generate output
.
.IP "\(bu" 4
\fIsuspend_cmd\fR \- Suspends output from a batch command
.
.IP "\(bu" 4
\fIresume_cmd\fR \- Resumes output from a batch command
.
.IP "\(bu" 4
\fIstop_cmd\fR \- Stops a batch command
.
.IP "" 0
.
.SH "METHOD get_cmds"
Get a list of the session\'s batch commands
.
.SS "PARAMS"
.
.nf

{}
.
.fi
.
.SS "RESULT"
.
.nf

{"cmds": <array of cmd>}

cmd =
 {"params": <object>,
  "comet_id": <string>,
  "handle": <string>,
  "tag": <"string">,
  "started": <boolean>,
  "stopped": <boolean; should be always false>}
.
.fi
.
.SH "METHOD init_cmd"
Starts a batch command
.
.P
.
.P
\fBNOTE\fR: the \fBstart_cmd\fR method must be called to actually get the batch command to generate any messages\.
.
.P
\fBNOTE\fR: As soon as the batch command prints anything on stdout it will be sent as a message and turn up as a result to your polling call to the \fBcomet\fR method\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "name": <string>,
 "args": <string>,
 "emulate": <boolean, default: false>,
 "width": <integer, default: 80>,
 "height": <integer, default: 24>,
 "scroll": <integer, default: 0>,
 "comet_id": <string>,
 "handle": <string, optional>}
.
.fi
.
.P
The \fBname\fR param is one on the named commands defined in \.
.
.P
The \fBargs\fR param any extra arguments to be provided to the command expect for the ones specified in \.
.
.P
The \fBemulate\fR param specifies if terminal emulation should be enabled\.
.
.P
The \fBwidth\fR, \fBheight\fR, \fBscroll\fR properties define the screen properties\.
.
.SS "RESULT"
.
.nf

{"handle": <string>}
.
.fi
.
.P
A handle to the batch command is returned (equal to \fBhandle\fR if provided)\.
.
.SH "METHOD send_cmd_data"
Sends data to batch command started with \fBinit_cmd\fR
.
.SS "PARAMS"
.
.nf

{"handle": <string>,
 "data": <string>}
.
.fi
.
.P
The \fBhandle\fR param is as returned from a call to \fBinit_cmd\fR and the \fBdata\fR param is what is to be sent to the batch command started with \fBinit_cmd\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "cmd\.not_initialized"}
.
.fi
.
.SH "METHOD start_cmd"
Signals that a batch command can start to generate output\.
.
.P
\fBNOTE\fR: This method must be called to actually start the activity initiated by calls to one of the methods \fBinit_cmd\fR\.
.
.SS "PARAMS"
.
.nf

{"handle": <string>}
.
.fi
.
.P
The \fBhandle\fR param is as returned from a call to \fBinit_cmd\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD suspend_cmd"
Suspends output from a batch command
.
.P
\fBNOTE\fR: the \fBinit_cmd\fR method must have been called with the \fBemulate\fR param set to true for this to work
.
.SS "PARAMS"
.
.nf

{"handle": <string>}
.
.fi
.
.P
The \fBhandle\fR param is as returned from a call to \fBinit_cmd\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD resume_cmd"
Resumes a batch command started with \fBinit_cmd\fR
.
.P
\fBNOTE\fR: the \fBinit_cmd\fR method must have been called with the \fBemulate\fR param set to true for this to work
.
.SS "PARAMS"
.
.nf

{"handle": <string>}
.
.fi
.
.P
The \fBhandle\fR param is as returned from a call to \fBinit_cmd\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD stop_cmd"
Stops a batch command
.
.P
\fBNOTE\fR: This method must be called to stop the activity started by calls to one of the methods \fBinit_cmd\fR\.
.
.SS "PARAMS"
.
.nf

{"handle": <string>}
.
.fi
.
.P
The \fBhandle\fR param is as returned from a call to \fBinit_cmd\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Subscribe commands description: "Reference and usage examples of the API \- Subscribe commands\." modified:
.
.SH "tags: [api, commands, events, subscriptions]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_subscriptions\fR \- Get a list of all the session\'s subscriptions
.
.IP "\(bu" 4
\fIsubscribe_cdboper\fR \- Starts a subscriber to operational data in CDB
.
.IP "\(bu" 4
\fIsubscribe_changes\fR \- Starts a subscriber to configuration data in CDB
.
.IP "\(bu" 4
\fIsubscribe_poll_leaf\fR \- Starts a polling subscriber to any type of operational and configuration data (outside of CDB as well)
.
.IP "\(bu" 4
\fIsubscribe_upgrade\fR \- Starts a subscriber to upgrade messages
.
.IP "\(bu" 4
\fIsubscribe_jsonrpc_batch\fR \- Starts a subscriber to JSONRPC messages for batch requests
.
.IP "\(bu" 4
\fIstart_subscription\fR \- Signals that a subscribe command can start to generate output
.
.IP "\(bu" 4
\fIunsubscribe\fR \- Stops a subscriber
.
.IP "" 0
.
.SH "METHOD get_subscriptions"
Get a list of the session\'s subscriptions
.
.SS "PARAMS"
.
.nf

{}
.
.fi
.
.SS "RESULT"
.
.nf

{"subscriptions": <array of subscription>}

subscription =
 {"params": <object>,
  "comet_id": <string>,
  "handle": <string>,
  "tag": <"string">,
  "started": <boolean>,
  "stopped": <boolean; should be always false>}
.
.fi
.
.SH "METHOD subscribe_cdboper"
Starts a subscriber to operational data in CDB\. Changes done to configuration data will not be seen here\.
.
.P
\fBNOTE\fR: the \fBstart_subscription\fR method must be called to actually get the subscription to generate any messages, unless the \fBhandle\fR is provided as input\.
.
.P
\fBNOTE\fR: the \fBunsubscribe\fR method should be used to end the subscription\.
.
.P
\fBNOTE\fR: As soon as a subscription message is generated it will be sent as a message and turn up as result to your polling call to the \fBcomet\fR method\.
.
.SS "PARAMS"
.
.nf

{"comet_id": <string>,
 "handle": <string, optional>,
 "path": <string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath restricting the subscription messages to only be about changes done under that specific keypath\.
.
.SS "RESULT"
.
.nf

{"handle": <string>}
.
.fi
.
.P
A handle to the subscription is returned (equal to \fBhandle\fR if provided)\.
.
.P
Subscription messages will end up in the \fBcomet\fR method and the format of that message will be an array of changes of the same type as returned by the \fBchanges\fR method\. See above\.
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "db\.cdb_operational_not_enabled"}
.
.fi
.
.SH "METHOD subscribe_changes"
Starts a subscriber to configuration data in CDB\. Changes done to operational data in CDB data will not be seen here\. Furthermore, subscription messages will only be generated when a transaction is successfully committed\.
.
.P
\fBNOTE\fR: the \fBstart_subscription\fR method must be called to actually get the subscription to generate any messages, unless the \fBhandle\fR is provided as input\.
.
.P
\fBNOTE\fR: the \fBunsubscribe\fR method should be used to end the subscription\.
.
.P
\fBNOTE\fR: As soon as a subscription message is generated it will be sent as a message and turn up as result to your polling call to the \fBcomet\fR method\.
.
.SS "PARAMS"
.
.nf

{"comet_id": <string>,
 "handle": <string, optional>,
 "path": <string>,
 "skip_local_changes": <boolean, default: false>,
 "hide_changes": <boolean, default: false>,
 "hide_values": <boolean, default: false>}
.
.fi
.
.P
The \fBpath\fR param is a keypath restricting the subscription messages to only be about changes done under that specific keypath\.
.
.P
The \fBskip_local_changes\fR param specifies if configuration changes done by the owner of the read\-write transaction should generate subscription messages\.
.
.P
The \fBhide_changes\fR and \fBhide_values\fR params specify a lower level of information in subscription messages, in case it is enough to receive just a "ping" or a list of changed keypaths, respectively, but not the new values resulted in the changes\.
.
.SS "RESULT"
.
.nf

{"handle": <string>}
.
.fi
.
.P
A handle to the subscription is returned (equal to \fBhandle\fR if provided)\.
.
.P
Subscription messages will end up in the \fBcomet\fR method and the format of that message will be an object such as:
.
.IP "" 4
.
.nf

{"db": <"running" | "startup" | "candidate">,
 "user": <string>,
 "ip": <string>,
 "changes": <array>}
.
.fi
.
.IP "" 0
.
.P
The \fBuser\fR and \fBip\fR properties are the username and ip\-address of the committing user\.
.
.P
The \fBchanges\fR param is an array of changes of the same type as returned by the \fBchanges\fR method\. See above\.
.
.SH "METHOD subscribe_poll_leaf"
Starts a polling subscriber to any type of operational and configuration data (outside of CDB as well)\.
.
.P
\fBNOTE\fR: the \fBstart_subscription\fR method must be called to actually get the subscription to generate any messages, unless the \fBhandle\fR is provided as input\.
.
.P
\fBNOTE\fR: the \fBunsubscribe\fR method should be used to end the subscription\.
.
.P
\fBNOTE\fR: As soon as a subscription message is generated it will be sent as a message and turn up as result to your polling call to the \fBcomet\fR method\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "interval": <number>,
 "comet_id": <string>,
 "handle": <string, optional>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to a leaf value\.
.
.P
The \fBinterval\fR is a timeout in seconds between when to poll the value\.
.
.SS "RESULT"
.
.nf

{"handle": <string>}
.
.fi
.
.P
A handle to the subscription is returned (equal to \fBhandle\fR if provided)\.
.
.P
Subscription messages will end up in the \fBcomet\fR method and the format of is a simple string value\.
.
.SH "METHOD subscribe_upgrade"
Starts a subscriber to upgrade messages\.
.
.P
\fBNOTE\fR: the \fBstart_subscription\fR method must be called to actually get the subscription to generate any messages, unless the \fBhandle\fR is provided as input\.
.
.P
\fBNOTE\fR: the \fBunsubscribe\fR method should be used to end the subscription\.
.
.P
\fBNOTE\fR: As soon as a subscription message is generated it will be sent as a message and turn up as result to your polling call to the \fBcomet\fR method\.
.
.SS "PARAMS"
.
.nf

{"comet_id": <string>,
 "handle": <string, optional>}
.
.fi
.
.SS "RESULT"
.
.nf

{"handle": <string>}
.
.fi
.
.P
A handle to the subscription is returned (equal to \fBhandle\fR if provided)\.
.
.P
Subscription messages will end up in the \fBcomet\fR method and the format of that message will be an object such as:
.
.IP "" 4
.
.nf

{"upgrade_state": <"wait_for_init" | "init" | "abort" | "commit">,
 "timeout": <number, only if "upgrade_state" === "wait_for_init">}
.
.fi
.
.IP "" 0
.
.SH "METHOD subscribe_jsonrpc_batch"
Starts a subscriber to JSONRPC messages for batch requests\.
.
.P
\fBNOTE\fR: the \fBstart_subscription\fR method must be called to actually get the subscription to generate any messages, unless the \fBhandle\fR is provided as input\.
.
.P
\fBNOTE\fR: the \fBunsubscribe\fR method should be used to end the subscription\.
.
.P
\fBNOTE\fR: As soon as a subscription message is generated it will be sent as a message and turn up as result to your polling call to the \fBcomet\fR method\.
.
.SS "PARAMS"
.
.nf

{"comet_id": <string>,
 "handle": <string, optional>}
.
.fi
.
.SS "RESULT"
.
.nf

{"handle": <string>}
.
.fi
.
.P
A handle to the subscription is returned (equal to \fBhandle\fR if provided)\.
.
.P
Subscription messages will end up in the \fBcomet\fR method having exact same structure like a JSONRPC response:
.
.IP "" 4
.
.nf

{"jsonrpc":"2\.0",
 "result":"admin",
 "id":1}
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "error":
 {"code": \-32602,
  "type": "rpc\.method\.unexpected_params",
  "message": "Unexpected params",
  "data":
  {"param": "foo"}}}
.
.fi
.
.IP "" 0
.
.SH "METHOD start_subscription"
Signals that a subscribe command can start to generate output\.
.
.P
\fBNOTE\fR: This method must be called to actually start the activity initiated by calls to one of the methods \fBsubscribe_cdboper\fR, \fBsubscribe_changes\fR, \fBsubscribe_messages\fR, \fBsubscribe_poll_leaf\fR or \fBsubscribe_upgrade\fR \fBwith no \fBhandle\fR\fR
.
.SS "PARAMS"
.
.nf

{"handle": <string>}
.
.fi
.
.P
The \fBhandle\fR param is as returned from a call to \fBsubscribe_cdboper\fR, \fBsubscribe_changes\fR, \fBsubscribe_messages\fR, \fBsubscribe_poll_leaf\fR or \fBsubscribe_upgrade\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD unsubscribe"
Stops a subscriber
.
.P
\fBNOTE\fR: This method must be called to stop the activity started by calls to one of the methods \fBsubscribe_cdboper\fR, \fBsubscribe_changes\fR, \fBsubscribe_messages\fR, \fBsubscribe_poll_leaf\fR or \fBsubscribe_upgrade\fR\.
.
.SS "PARAMS"
.
.nf

{"handle": <string>}
.
.fi
.
.P
The \fBhandle\fR param is as returned from a call to \fBsubscribe_cdboper\fR, \fBsubscribe_changes\fR, \fBsubscribe_messages\fR, \fBsubscribe_poll_leaf\fR or \fBsubscribe_upgrade\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Data description: "Reference and usage examples of the API \- Data\." modified:
.
.SH "tags: [api, data]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIcreate\fR \- Create a list entry, a presence container, or a leaf of type empty
.
.IP "\(bu" 4
\fIdelete\fR \- Deletes an existing list entry, a presence container, or an optional leaf and all its children (if any)
.
.IP "\(bu" 4
\fIexists\fR \- Checks if optional data exists
.
.IP "\(bu" 4
\fIget_case\fR \- Get the case of a choice leaf
.
.IP "\(bu" 4
\fIshow_config\fR \- Retrieves a compact string representation of the configuration
.
.IP "" 0
.
.SH "METHOD create"
Create a list entry, a presence container, or a leaf of type empty
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to data to be created\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "db\.locked"}
.
.fi
.
.SH "METHOD delete"
Deletes an existing list entry, a presence container, or an optional leaf and all its children (if any)
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to data to be deleted\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "db\.locked"}
.
.fi
.
.SH "METHOD exists"
Checks if optional data exists
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to data to be checked for existence\.
.
.SS "RESULT"
.
.nf

{"exists": <boolean>}
.
.fi
.
.SH "METHOD get_case"
Get the case of a choice leaf
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "choice": <string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to data that contains the choice leaf given by the \fBchoice\fR param\.
.
.SS "RESULT"
.
.nf

{"case": <string>}
.
.fi
.
.SH "METHOD show_config"
Retrieves a compact string representation of the configuration
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath to the configuration to be returned in a compact string format\.
.
.SS "RESULT"
.
.nf

{"config": <string>}
.
.fi
.
.P
date: 2015\-04\-08 layout: post title: API \- Data (attrs) description: "Reference and usage examples of the API \- Data (attr)\." modified:
.
.SH "tags: [api, data]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_attrs\fR \- Get node attributes
.
.IP "\(bu" 4
\fIset_attrs\fR \- Set node attributes
.
.IP "" 0
.
.SH "METHOD get_attrs"
Get node attributes
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "names": <array of string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to the node and the \fBnames\fR param is a list of attribute names that you want to retrieve\.
.
.SS "RESULT"
.
.nf

{"attrs": <object of attribute name/value>}
.
.fi
.
.SH "METHOD set_attrs"
Set node attributes
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "attrs": <object of attribute name/value>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to the node and the \fBattrs\fR param is an object that maps attribute names to their values\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Data (leafs) description: "Reference and usage examples of the API \- Data (leafs)\." modified:
.
.SH "tags: [api, data]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_value\fR \- Gets a leaf value
.
.IP "\(bu" 4
\fIget_values\fR \- Get leaf values
.
.IP "\(bu" 4
\fIset_value\fR \- Sets a leaf value
.
.IP "" 0
.
.SH "METHOD get_value"
Gets a leaf value
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to a value\.
.
.SS "RESULT"
.
.nf

{"value": <string>}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "get_value", \e
         "params": {"th": 4711, \e
                    "path": "/dhcp:dhcp/max\-lease\-time"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{
  "jsonrpc": "2\.0",
  "id": 1,
  "result": {"value": "7200"}
}
.
.fi
.
.IP "" 0
.
.SH "METHOD get_values"
Get leaf values
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "leafs": <array of string>}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to a container\. the \fBleafs\fR param is an array of children names residing under the parent container in the YANG module\.
.
.SS "RESULT"
.
.nf

{"values": <array of value/error>}

value  = {"value": <string>, "access": <access>}
error  = {"error": <string>, "access": <access>} |
         {"exists": true, "access": <access>} |
         {"not_found": true, "access": <access>}
access = {"read": true, write: true}
.
.fi
.
.P
\fBNOTE\fR: The access object has no "read" and/or "write" properties if there are no read and/or access rights\.
.
.SH "METHOD set_value"
Sets a leaf value
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "value": <string | boolean | integer | array | null>,
 "dryrun": <boolean, default: false}
.
.fi
.
.P
The \fBpath\fR param is the keypath to give a new value as specified with the \fBvalue\fR param\.
.
.P
\fBvalue\fR can be an array when the \fBpath\fR is a leaf\-list node\.
.
.P
When \fBvalue\fR is \fBnull\fR, the \fBset_value\fR method acts like \fBdelete\fR\.
.
.P
When \fBdryrun\fR is \fBtrue\fR, this function can be used to test if a value is valid or not\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "data\.already_exists"}
{"type": "data\.not_found"}
{"type": "data\.not_writable"}
{"type": "db\.locked"}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "set_value", \e
         "params": {"th": 4711, \e
                    "path": "/dhcp:dhcp/max\-lease\-time", \e
                    "value": "4500"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": {}
}
.
.fi
.
.IP "" 0
.
.P
date: 2014\-03\-07 layout: post title: API \- Data (leafref) description: "Reference and usage examples of the API \- Data (leafref)\." modified:
.
.SH "tags: [api, data]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIderef\fR \- Dereferences a leaf with a leafref type
.
.IP "\(bu" 4
\fIget_leafref_values\fR \- Gets all possible values for a leaf with a leafref type
.
.IP "" 0
.
.SH "METHOD deref"
Dereferences a leaf with a leafref type
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "result_as": <"paths" | "target", default: "paths">}
.
.fi
.
.P
The \fBpath\fR param is a keypath pointing to a leaf with a leafref type\.
.
.SS "RESULT"
.
.nf

{"paths": <array of string, a keypath to a leaf>}
.
.fi
.
.IP "" 4
.
.nf

{"target": <a keypath to a leaf/list>}
.
.fi
.
.IP "" 0
.
.SH "METHOD get_leafref_values"
Gets all possible values for a leaf with a leafref type
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "skip_grouping": <boolean, default: false>,
 "keys": <array of string>}
.
.fi
.
.P
The \fBth\fR param is as returned from a call to \fBnew_read_trans\fR or \fBnew_write_trans\fR\. The \fBpath\fR param is a keypath pointing to a leaf with a leafref type\.
.
.P
The \fBskip_grouping\fR param is by default set to false and is only needed to be set to true if if a set of sibling leafref leafs points to a list instance with multiple keys \fIand\fR if \fBget_leafref_values\fR should return an array of possible leaf values instead an array of arrays with possible key value combinations\.
.
.P
The \fBkeys\fR param is an optional array of values that should be set if a more than one leafref statement is used within action input parameters \fIand\fR if they refer to each other using \fBderef()\fR or \fBcurrent()\fR XPath functions\.
.
.SS "RESULT"
.
.nf

{"values": <array of string>,
 "source": <string>}
.
.fi
.
.SH "The <code>source</code> param will point to the keypath where the values originate\."
date: 2014\-03\-07 layout: post title: API \- Data (lists) description: "Reference and usage examples of the API \- Data (lists)\." modified:
.
.SH "tags: [api, data]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIrename_list_entry\fR \- Renames a list entry
.
.IP "\(bu" 4
\fImove_list_entry\fR \- Moves an ordered by user list entry relative to its siblings
.
.IP "\(bu" 4
\fIcount_list_keys\fR \- Counts the number of keys in a list
.
.IP "\(bu" 4
\fIget_list_keys\fR \- Enumerate keys in a list
.
.IP "" 0
.
.SH "METHOD rename_list_entry"
Renames a list entry\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "from_path": <string>,
 "to_keys": <array of string>}
.
.fi
.
.P
The \fBfrom_path\fR is a keypath pointing out the list entry to be renamed\.
.
.P
The list entry to be renamed will, under the hood, be deleted all together and then recreated with the content from the deleted list entry copied in\.
.
.P
The \fBto_keys\fR param is an array with the new key values\. The array must contain a full set of key values\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "data\.already_exists"}
{"type": "data\.not_found"}
{"type": "data\.not_writable"}
.
.fi
.
.SH "METHOD move_list_entry"
Moves an ordered\-by user list entry relative to its siblings\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "from_path": <string>,
 "to_path": <string>,
 "mode": <"first" | "last" | "before" | "after">}
.
.fi
.
.P
The \fBfrom_path\fR is a keypath pointing out the list entry to be moved\.
.
.P
The list entry to be moved can either be moved to the first or the last position, i\.e\. if the \fBmode\fR param is set to \fBfirst\fR or \fBlast\fR the \fBto_path\fR keypath param has no meaning\.
.
.P
If the \fBmode\fR param is set to \fBbefore\fR or \fBafter\fR the \fBto_path\fR param must be specified, i\.e\. the list entry will be moved to the position before or after the list entry which the \fBto_path\fR keypath param points to\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "db\.locked"}
.
.fi
.
.SH "METHOD count_list_keys"
Counts the number of keys in a list\.
.
.SS "PARAMS"
.
.nf

{"th": <number>
 "path": <string>}
.
.fi
.
.P
The \fBpath\fR parameter is a keypath pointing to a list\.
.
.SS "RESULT"
.
.nf

{"count": <number>}
.
.fi
.
.SH "METHOD get_list_keys"
Enumerates keys in a list\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "chunk_size": <string>,
 "start_with": <array of string, optional>,
 "lh": <number, optional>}
.
.fi
.
.P
The \fBth\fR parameter is the transaction handle\.
.
.P
The \fBpath\fR parameter is a keypath pointing to a list\. Required on first invocation \- optional in following\.
.
.P
The \fBchunk_size\fR parameter is the number of requested keys in the result\. Optional \- default is unlimited\.
.
.P
The \fBstart_with\fR parameter will be used to filter out all those keys that do not start with the provided strings\. The parameter supports multiple keys e\.g\. if the list has two keys, then \fBstart_with\fR can hold two items\.
.
.P
The \fBlh\fR (list handle) parameter is optional (on the first invocation) but must be used in following invocations\.
.
.SS "RESULT"
.
.nf

{"keys": <array of array of string>,
 "total_count": <number>,
 "lh": <number>}
.
.fi
.
.P
Each invocation of \fBget_list_keys\fR will return at most \fBchunk_size\fR keys\. The returned \fBlh\fR must be used in following invocations to retrieve next chunk of keys\. When no more keys are available the returned \fBlh\fR will be set to \fB\-1\fR\.
.
.P
On the first invocation \fBlh\fR can either be omitted or set to \fB\-1\fR\.
.
.P
date: 2014\-03\-07 layout: post title: API \- Data (query) description: "Reference and usage examples of the API \- Data (query)\." modified:
.
.SH "tags: [api, data, query]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIquery\fR \- Run a one\-time one\-chunk query and stop it
.
.IP "\(bu" 4
\fIstart_query\fR \- Starts a new query attached to a transaction handle
.
.IP "\(bu" 4
\fIrun_query\fR \- Runs the query and retrieves the next chunk of results
.
.IP "\(bu" 4
\fIreset_query\fR \- Reset/rewind a running query
.
.IP "\(bu" 4
\fIstop_query\fR \- Stops a running query
.
.IP "" 0
.
.SH "METHOD query"
Starts a new query attached to a transaction handle, retrieves the results, and stops the query immediately\. This is a convenience method for calling \fBstart_query\fR, \fBrun_query\fR and \fBstop_query\fR in a one\-time sequence\.
.
.P
This method should not be used for paginated results, as it results in performance degradation \- use \fBstart_query\fR, multiple \fBrun_query\fRand \fBstop_query\fRinstead\.
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie "sessionid=sess11635875109111642;"
    \-X POST
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "query", \e
         "params": {"th": 1, \e
                    "xpath_expr": "/dhcp:dhcp/dhcp:foo", \e
                    "result_as": "keypath\-value"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result":
 {"current_position": 2,
  "total_number_of_results": 4,
  "number_of_results": 2,
  "number_of_elements_per_result": 2,
  "results": ["foo", "bar"]}}
.
.fi
.
.IP "" 0
.
.SH "METHOD start_query"
Starts a new query attached to a transaction handle\. On success a query handle is returned to be in subsequent calls to \fBrun_query\fR\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "xpath_expr": <string>,
 "selection": <array of xpath expressions, optional>
 "chunk_size": <number, optional>
 "initial_offset": <number, optional>,
 "sort", <array of xpath expressions, optional>,
 "sort_order": <"ascending" | "descending", optional>,
 "include_total": <boolean, default: true>,
 "context_node": <string, keypath, optional>,
 "result_as": <"string" | "keypath\-value", default: "string">}
.
.fi
.
.P
The \fBxpath_expr\fR param is the primary XPath expression to base the query on\.
.
.P
A query is a way of evaluating an XPath expression and returning the results in chunks\. The primary XPath expression must evaluate to a node\-set, i\.e\. the result\. For each node in the result a \fBselection\fR Xpath expression is evaluated with the result node as its context node\.
.
.P
\fBNote\fR: The terminology used here is as defined in http://en\.wikipedia\.org/wiki/XPath\.
.
.P
For example, given this YANG snippet:
.
.IP "" 4
.
.nf

list interface {
  key name;
  unique number;
  leaf name {
    type string;
  }
  leaf number {
    type uint32;
    mandatory true;
  }
  leaf enabled {
    type boolean;
    default true;
  }
}
.
.fi
.
.IP "" 0
.
.P
The \fBxpath_expr\fR could be \fB/interface[enabled=\'true\']\fR and \fBselection\fR could be \fB{ "name", "number" }\fR\.
.
.P
Note that the \fBselection\fR expressions must be valid XPath expressions, e\.g\. to figure out the name of an interface and whether its number is even or not, the expressions must look like: \fB{ "name", "(number mod 2) == 0" }\fR\.
.
.P
The result are then fetched using \fBrun_query\fR, which returns the result on the format specified by \fBresult_as\fR param\.
.
.P
There are two different types of result:
.
.IP "\(bu" 4
\fBstring\fR result is just an array with resulting strings of evaluating the \fBselection\fR XPath expressions
.
.IP "\(bu" 4
\fBkeypath\-value\fR result is an array the keypaths or values of the node that the \fBselection\fR XPath expression evaluates to\.
.
.IP "" 0
.
.P
This means that care must be taken so that the combination of \fBselection\fR expressions and return types actually yield sensible results (for example \fB1 + 2\fR is a valid \fBselection\fR XPath expression, and would result in the string \fB3\fR when setting the result type to \fBstring\fR \- but it is not a node, and thus have no keypath\-value\.
.
.P
It is possible to sort the result using the built\-in XPath function \fBsort\-by()\fR but it is also also possible to sort the result using expressions specified by the \fBsort\fR param\. These expressions will be used to construct a temporary index which will live as long as the query is active\. For example to start a query sorting first on the enabled leaf, and then on number one would call:
.
.IP "" 4
.
.nf

$\.post("/jsonrpc", {
  jsonrpc: "2\.0",
  id: 1,
  method: "start_query",
  params:  {
    th: 1,
    xpath_expr: "/interface[enabled=\'true\']",
    selection: ["name", "number", "enabled"],
    sort: ["enabled", "number"]
  }
})
    \.done(\.\.\.);
.
.fi
.
.IP "" 0
.
.P
The \fBcontext_node\fR param is a keypath pointing out the node to apply the query on; only taken into account when the \fBxpath_expr\fR uses relatives paths\. Lack of a \fBcontext_node\fR, turns relatives paths into absolute paths\.
.
.P
The \fBchunk_size\fR param specifies how many result entries to return at a time\. If set to 0 a default number will be used\.
.
.P
The \fBinitial_offset\fR param is the result entry to begin with (1 means to start from the beginning)\.
.
.SS "RESULT"
.
.nf

{"qh": <number>}
.
.fi
.
.P
A new query handler handler id to be used when calling \fBrun_query\fR etc
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie "sessionid=sess11635875109111642;"
    \-X POST
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "start_query", \e
         "params": {"th": 1, \e
                    "xpath_expr": "/dhcp:dhcp/dhcp:foo", \e
                    "result_as": "keypath\-value"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": 47}
.
.fi
.
.IP "" 0
.
.SH "METHOD run_query"
Retrieves the result to a query (as chunks)\. For more details on queries please read the description of "start_query"\.
.
.SS "PARAMS"
.
.nf

{"qh": <number>}
.
.fi
.
.P
The \fBqh\fR param is as returned from a call to "start_query"\.
.
.SS "RESULT"
.
.nf

{"position": <number>,
 "total_number_of_results": <number>,
 "number_of_results": <number>,
 "chunk_size": <number>,
 "result_as": <"string" | "keypath\-value">,
 "results": <array of result>}

result = <string> |
         {"keypath": <string>, "value": <string>}
.
.fi
.
.P
The \fBposition\fR param is the number of the first result entry in this chunk, i\.e\. for the first chunk it will be 1\.
.
.P
How many result entries there are in this chunk is indicated by the \fBnumber_of_results\fR param\. It will be 0 for the last chunk\.
.
.P
The \fBchunk_size\fR and the \fBresult_as\fR properties are as given in the call to \fBstart_query\fR\.
.
.P
The \fBtotal_number_of_results\fR param is total number of result entries retrieved so far\.
.
.P
The \fBresult\fR param is as described in the description of \fBstart_query\fR\.
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie "sessionid=sess11635875109111642;" \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "run_query", \e
         "params": {"qh": 22}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result":
 {"current_position": 2,
  "total_number_of_results": 4,
  "number_of_results": 2,
  "number_of_elements_per_result": 2,
  "results": ["foo", "bar"]}}
.
.fi
.
.IP "" 0
.
.SH "METHOD reset_query"
Reset/rewind a running query so that it starts from the beginning again\. Next call to "run_query" will then return the first chunk of result entries\.
.
.SS "PARAMS"
.
.nf

{"qh": <number>}
.
.fi
.
.P
The \fBqh\fR param is as returned from a call to \fBstart_query\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "reset_query", \e
         "params": {"qh": 67}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": true}
.
.fi
.
.IP "" 0
.
.SH "METHOD stop_query"
Stops the running query identified by query handler\. If a query is not explicitly closed using this call it will be cleaned up when the transaction the query is linked to ends\.
.
.SS "PARAMS"
.
.nf

{"qh": <number>}
.
.fi
.
.P
The \fBqh\fR param is as returned from a call to "start_query"\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "stop_query", \e
         "params": {"qh": 67}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": true}
.
.fi
.
.IP "" 0
.
.P
date: 2014\-03\-07 layout: post title: API \- Database description: "Reference and usage examples of the API \- Database\." modified:
.
.SH "tags: [api, database]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIreset_candidate_db\fR \- Resets the candidate datastore
.
.IP "\(bu" 4
\fIlock_db\fR \- Takes a database lock
.
.IP "\(bu" 4
\fIunlock_db\fR \- Releases a database lock
.
.IP "\(bu" 4
\fIcopy_running_to_startup_db\fR \- Copies the running datastore to the startup datastore
.
.IP "" 0
.
.SH "METHOD reset_candidate_db"
Resets the candidate datastore
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD lock_db"
Takes a database lock
.
.SS "PARAMS"
.
.nf

{"db": <"startup" | "running" | "candidate">}
.
.fi
.
.P
The \fBdb\fR param specifies which datastore to lock\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "db\.locked", "data": {"sessions": <array of string>}}
.
.fi
.
.P
The \fBdata\.sessions\fR param is an array of strings describing the current sessions of the locking user, e\.g\. an array of "admin tcp (cli from 192\.245\.2\.3) on since 2006\-12\-20 14:50:30 exclusive"\.
.
.SH "METHOD unlock_db"
Releases a database lock
.
.SS "PARAMS"
.
.nf

{"db": <"startup" | "running" | "candidate">}
.
.fi
.
.P
The \fBdb\fR param specifies which datastore to unlock\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD copy_running_to_startup_db"
Copies the running datastore to the startup datastore
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- General description: "Reference and usage examples of the API \- General\." modified:
.
.SH "tags: [api, comet, events, notifications, xpath, system]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIcomet\fR \- Listens on a comet channel
.
.IP "\(bu" 4
\fIget_system_setting\fR \- Get system setting
.
.IP "\(bu" 4
\fIabort\fR \- Abort a JSON\-RPC method by its associated id
.
.IP "\(bu" 4
\fIeval_xpath\fR \- Evaluates an xpath expression on the server side
.
.IP "" 0
.
.SH "METHOD comet"
Listens on a comet channel, i\.e\. all asynchronous messages from batch commands started by calls to \fBstart_cmd\fR, \fBsubscribe_cdboper\fR, \fBsubscribe_changes\fR, \fBsubscribe_messages\fR, \fBsubscribe_poll_leaf\fR or \fBsubscribe_upgrade\fR ends up on the comet channel\.
.
.P
You are expected to have a continuous long polling call to the \fBcomet\fR method at any given time\. As soon as the browser or server closes the socket, due to browser or server connect timeout, the \fBcomet\fR method should be called again\.
.
.P
As soon as the \fBcomet\fR method returns with values they should be dispatched and the \fBcomet\fR method should be called again\.
.
.SS "PARAMS"
.
.nf

{"comet_id": <string>}
.
.fi
.
.SS "RESULT"
.
.nf

[{"handle": <number>,
  "message": <a context specific json object, see example below>},
 \.\.\.]
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "comet\.duplicated_channel"}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "subscribe_changes", \e
         "params": {"comet_id": "main", \e
                    "path": "/dhcp:dhcp"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": {"handle": "2"}}
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "batch_init_done", \e
         "params": {"handle": "2"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": {}}
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

curl \e
    \-m 15 \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "comet", \e
         "params": {"comet_id": "main"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 0
.
.P
hangs\.\.\. and finally\.\.\.
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result":
 [{"handle": "1",
   "message":
   {"db": "running",
    "changes":
    [{"keypath": "/dhcp:dhcp/default\-lease\-time",
      "op": "value_set",
      "value": "100"}],
    "user": "admin",
    "ip": "127\.0\.0\.1"}}]}
.
.fi
.
.IP "" 0
.
.P
In this case the admin user seems to have set \fB/dhcp:dhcp/default\-lease\-time\fR to \fB100\fR\.
.
.SH "METHOD get_system_setting"
Extracts system settings such as capabilities, supported datastores, etc\.
.
.SS "PARAMS"
.
.nf

{"operation": <"capabilities" | "customizations" | "models" | "user" | "version" | "all" | "namespaces", default: "all">}
.
.fi
.
.P
The \fBoperation\fR param specifies which system setting to get:
.
.IP "\(bu" 4
\fBcapabilities\fR \- the server\-side settings are returned, e\.g\. is rollback and confirmed commit supported
.
.IP "\(bu" 4
\fBcustomizations\fR \- an array of all webui customizations
.
.IP "\(bu" 4
\fBmodels\fR \- an array of all loaded YANG modules are returned, i\.e\. prefix, namespace, name
.
.IP "\(bu" 4
\fBuser\fR \- the username of the currently logged in user is returned
.
.IP "\(bu" 4
\fBversion\fR \- the system version
.
.IP "\(bu" 4
\fBall\fR \- all of the above is returned\.
.
.IP "\(bu" 4
(DEPRECATED) \fBnamespaces\fR \- an object of all loaded YANG modules are returned, i\.e\. prefix to namespace
.
.IP "" 0
.
.SS "RESULT"
.
.nf

{"user:" <string>,
 "models:" <array of YANG modules>,
 "version:" <string>,
 "customizations": <array of customizations>,
 "capabilities":
 {"rollback": <boolean>,
  "copy_running_to_startup": <boolean>,
  "exclusive": <boolean>,
  "confirmed_commit": <boolean>
 },
 "namespaces": <object of YANG modules prefix/namespace>}
.
.fi
.
.P
The above is the result if using the \fBall\fR operation\.
.
.SH "METHOD abort"
Abort a JSON\-RPC method by its associated id\.
.
.SS "PARAMS"
.
.nf

{"id": <integer>}
.
.fi
.
.P
The \fBxpath_expr\fR param is the XPath expression to be evaluated\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD eval_xpath"
Evaluates an xpath expression on the server side
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "xpath_expr": <string>}
.
.fi
.
.P
The \fBxpath_expr\fR param is the XPath expression to be evaluated\.
.
.SS "RESULT"
.
.nf

{"value": <string>}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Messages description: "Reference and usage examples of the API \- Messages\." modified:
.
.SH "tags: [api, chat]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIsend_message\fR \- Sends a message to another user in the CLI or Web UI
.
.IP "\(bu" 4
\fIsubscribe_messages\fR \- Starts a subscriber to messages
.
.IP "" 0
.
.SH "METHOD send_message"
Sends a message to another user in the CLI or Web UI
.
.SS "PARAMS"
.
.nf

{"to": <string>,
 "message": <string>}
.
.fi
.
.P
The \fBto\fR param is the user name of the user to send the message to and the \fBmessage\fR param is the actual message\.
.
.P
\fBNOTE\fR: The username "all" will broadcast the message to all users\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD subscribe_messages"
Starts a subscriber to messages\.
.
.P
\fBNOTE\fR: the \fBstart_subscription\fR method must be called to actually get the subscription to generate any messages, unless the \fBhandle\fR is provided as input\.
.
.P
\fBNOTE\fR: the \fBunsubscribe\fR method should be used to end the subscription\.
.
.P
\fBNOTE\fR: As soon as a subscription message is generated it will be sent as a message and turn up as result to your polling call to the \fBcomet\fR method\.
.
.SS "PARAMS"
.
.nf

{"comet_id": <string>,
 "handle": <string, optional>}
.
.fi
.
.SS "RESULT"
.
.nf

<string>
.
.fi
.
.P
A handle to the subscription is returned (equal to \fBhandle\fR if provided)\.
.
.P
Subscription messages will end up in the \fBcomet\fR method and the format of these messages depend on what has happened\.
.
.P
When a new user has logged in:
.
.IP "" 4
.
.nf

{"new_user": <number, a session id to be used by "kick_user">
 "me": <boolean, is it myself?>
 "user": <string>,
 "proto": <"ssh" | "tcp" | "console" | "http" | "https" | "system">,
 "ctx": <"cli" | "webui" | "netconf">
 "ip": <string, user\'s ip\-address>,
 "login": <string, login timestamp>}
.
.fi
.
.IP "" 0
.
.P
When a user logs out:
.
.IP "" 4
.
.nf

{"del_user": <number, a session id>,
 "user": <string>}
.
.fi
.
.IP "" 0
.
.P
When receiving a message:
.
.IP "" 4
.
.nf

{"sender": <string>,
 "message": <string>}
.
.fi
.
.IP "" 0
.
.P
date: 2014\-03\-07 layout: post title: API \- &product; specific description: "Reference and usage examples of the API \- &product;\." modified:
.
.SH "tags: [api, ncs]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_service_points\fR \- Extracts paths to all &product; services
.
.IP "\(bu" 4
\fIget_template_variables\fR \- Extracts all variables from a &product; service/device template
.
.IP "" 0
.
.SH "METHOD get_service_points"
Extracts paths to all &product; services
.
.SS "RESULT"
.
.nf

{"service_points": <array of key\-value objects>}
.
.fi
.
.SH "METHOD get_template_variables"
Extracts all variables from a &product; service/device template
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "name": <string>}
.
.fi
.
.P
The \fBname\fR param is the name of the template to extract variables from\.
.
.SS "RESULT"
.
.nf

{"template_variables": <array of string>}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Rollbacks description: "Reference and usage examples of the API \- Rollbacks\." modified:
.
.SH "tags: [api, rollbacks]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_rollbacks\fR \- Lists all available rollback files
.
.IP "\(bu" 4
\fIget_rollback\fR \- Gets the content of a specific rollback file
.
.IP "\(bu" 4
\fIload_rollback\fR \- Loads a specific rollback file into an existing transaction
.
.IP "\(bu" 4
\fIinstall_rollback\fR \- Installs a specific rollback file into a new transaction and commits it
.
.IP "" 0
.
.SH "METHOD get_rollbacks"
Lists all available rollback files
.
.SS "RESULT"
.
.nf

{"rollbacks": <array of rollback>}

rollback =
 {"nr": <number>,
  "creator": <string>,
  "date": <string>,
  "via": <"system" | "cli" | "webui" | "netconf">,
  "comment": <string>,
  "label": <string>}
.
.fi
.
.P
The \fBnr\fR param is a rollback number to be used in calls to \fBload_rollback\fR etc\.
.
.P
The \fBcreator\fR and \fBdate\fR properties identify the name of the user responsible for committing the configuration stored in the rollback file and when it happened\.
.
.P
The \fBvia\fR param identifies the interface that was used to create the rollback file\.
.
.P
The \fBlabel\fR and \fBcomment\fR properties is as given calling the methods \fBset_comment\fR and \fBset_label\fR on the transaction\.
.
.SH "METHOD get_rollback"
Gets the content of a specific rollback file\. The rollback format is as defined in a curly bracket format as defined in the CLI\.
.
.SS "PARAMS"
.
.nf

{"nr": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

<string, rollback file in curly bracket format>
.
.fi
.
.SH "METHOD install_rollback"
Installs a specific rollback file into a new transaction and commits it\. The configuration is restored to the one stored in the rollback file and no further operations are needed\. It is the equivalent of creating a new private write private transaction handler with \fBnew_write_trans\fR, followed by calls to the methods \fBload_rollback\fR, \fBvalidate_commit\fR and \fBcommit\fR\.
.
.SS "PARAMS"
.
.nf

{"nr": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD load_rollback"
Rolls back within an existing transaction, starting with the latest rollback file, down to a specified rollback file, or selecting only the specified rollback file (also known as "selective rollback")\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "nr": <number>,
 "path": <string>,
 "selective": <boolean, default: false>}
.
.fi
.
.P
The \fBnr\fR param is a rollback number returned by \fBget_rollbacks\fR\.
.
.P
The \fBpath\fR param is a keypath that restrict the rollback to be applied only to a subtree\.
.
.P
The \fBselective\fR param, false by default, can restrict the rollback process to use only the rollback specified by \fBnr\fR, rather than applying all known rollbacks files starting with the latest down to the one specified by \fBnr\fR\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Schema description: "Reference and usage examples of the API \- Schema\." modified:
.
.SH "tags: [api, yang, schema]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_schema\fR \- Exports a JSON schema for a selected part (or all) of a specific YANG module (with optional instance data inserted)
.
.IP "\(bu" 4
\fIhide_schema\fR \- Hides data which has been adorned with a "hidden" statement
.
.IP "\(bu" 4
\fIunhide_schema\fR \- Unhides data which has been adorned with a "hidden" statement
.
.IP "\(bu" 4
\fIrun_action\fR \- Invokes an action or rpc defined in a YANG module
.
.IP "" 0
.
.SH "METHOD get_schema"
Exports a JSON schema for a selected part (or all) of a specific YANG module (with optional instance data inserted)
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "namespace": <string, optional>,
 "path": <string, optional>,
 "levels": <number, default: \-1>,
 "insert_values": <boolean, default: false>,
 "evaluate_when_entries": <boolean, default: false>}
.
.fi
.
.P
One of the properties \fBnamespace\fR or \fBpath\fR must be specified\.
.
.P
A \fBnamespace\fR is as specified in a YANG module\.
.
.P
A \fBpath\fR is a tagpath/keypath pointing into a specific sub\-tree of a YANG module\.
.
.P
The \fBlevels\fR param limits the maximum depth of containers and lists from which a JSON schema should be produced (\-1 means unlimited depth)\.
.
.P
The \fBinsert_values\fR param signals that instance data for leafs should be inserted into the schema\. This way the need for explicit forthcoming calls to \fBget_elem\fR are avoided\.
.
.P
The \fBevaluate_when_entries\fR param signals that schema entries should be included in the schema even though their "when" or "tailf:display\-when" statements evaluate to false, i\.e\. instead a boolean \fBevaluated_when_entry\fR param is added to these schema entries\.
.
.SS "RESULT"
.
.nf

{"meta":
 {"namespace": <string, optional>,
  "keypath": <string, optional>,
  "prefix": <string>,
  "types": <array of type>},
 "data": <array of child>}

type = <array of {<string, type name with prefix>: <type_stack>}>

type_stack = <array of type_stack_entry>

type_stack_entry =
 {"bits": <array of string>, "size": <32 | 64>} |
 {"leaf_type": <type_stack>, "list_type": <type_stack>} |
 {"union": <array of type_stack>} |
 {"name": <primitive_type | "user_defined">,
  "info": <string, optional>,
  "readonly": <boolean, optional>,
  "facets": <array of facet, only if not primitive type>}

primitive_type =
 "empty" |
 "binary" |
 "bits" |
 "date\-and\-time" |
 "instance\-identifier" |
 "int64" |
 "int32" |
 "int16" |
 "uint64" |
 "uint32" |
 "uint16" |
 "uint8" |
 "ip\-prefix" |
 "ipv4\-prefix" |
 "ipv6\-prefix" |
 "ip\-address\-and\-prefix\-length" |
 "ipv4\-address\-and\-prefix\-length" |
 "ipv6\-address\-and\-prefix\-length" |
 "hex\-string" |
 "dotted\-quad" |
 "ip\-address" |
 "ipv4\-address" |
 "ipv6\-address" |
 "gauge32" |
 "counter32" |
 "counter64" |
 "object\-identifier"

facet_entry =
 {"enumeration": {"label": <string>, "info": <string, optional>}} |
 {"fraction\-digits": {"value": <number>}} |
 {"length": {"value": <number>}} |
 {"max\-length": {"value": <number>}} |
 {"min\-length": {"value": <number>}} |
 {"leaf\-list": <boolean>} |
 {"max\-inclusive": {"value": <number>}} |
 {"max\-length": {"value": <number>}} |
 {"range": {"value": <array of range_entry>}} |
 {"min\-exclusive": {"value": <number>}} |
 {"min\-inclusive": {"value": <number>}} |
 {"min\-length": {"value": <number>}} |
 {"pattern": {"value": <string, regular expression>}} |
 {"total\-digits": {"value": <number>}}

range_entry =
 "min" |
 "max" |
 <number> |
 [<number, min value>, <number, max value>]

child =
 {"kind": <kind>,
  "name": <string>,
  "qname": <string, same as "name" but with prefix prepended>,
  "info": <string>,
  "namespace": <string>,
  "is_action_input": <boolean>,
  "is_action_output": <boolean>,
  "is_cli_preformatted": <boolean>,
  "presence": <boolean>,
  "ordered_by": <boolean>,
  "is_config_false_callpoint": <boolean>,
  "key": <boolean>,
  "exists": <boolean>,
  "value": <string | number | boolean>,
  "is_leafref": <boolean>,
  "hidden": <boolean>,
  "default_ref":
  {"namespace": <string>,
   "tagpath": <string>
  },
  "access":
  {"create": <boolean>,
   "update": <boolean>,
   "delete": <boolean>,
   "execute": <boolean>
  },
  "config": <boolean>,
  "readonly": <boolean>,
  "suppress_echo": <boolean>,
  "type":
  {"name": <primitive_type>,
   "primitive": <boolean>
  }
  "generated_name": <string>,
  "units": <string>,
  "leafref_groups": <array of string>,
  "active": <string, active case, only if "kind" is "choice">,
  "cases": <array of case, only of "kind" is "choice">,
  "default": <string | number | boolean>,
  "mandatory": <boolean>,
  "children": <children>
 }

kind =
 "module" |
 "access\-denies" |
 "list\-entry" |
 "choice" |
 "key" |
 "leaf\-list" |
 "action" |
 "container" |
 "leaf" |
 "list" |
 "notification"

case_entry =
 {"kind": "case",
  "name": <string>,
  "children": <array of child>
 }
.
.fi
.
.P
This is a fairly complex piece of JSON but it essentially maps what is seen in a YANG module\. Keep that in mind when scrutinizing the above\.
.
.P
The \fBmeta\fR param contains meta\-information about the YANG module such as namespace and prefix but it also contains type stack information for each type used in the YANG module represented in the \fBdata\fR param\. Together with the \fBmeta\fR param, the \fBdata\fR param constitutes a complete YANG module in JSON format\.
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie "sessionid=sess11635875109111642;" \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "get_schema", \e
         "params": {"th": 2, \e
                    "path": "/aaa:aaa/authentication/users/user{admin}", \e
                    "levels": \-1, \e
                    "insert_values": true}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result":
 {"meta":
  {"namespace": "http://tail\-f\.com/ns/aaa/1\.1",
   "keypath": "/aaa:aaa/authentication/users/user{admin}",
   "prefix": "aaa",
   "types":
   {"http://tail\-f\.com/ns/aaa/1\.1:passwdStr":
    [{"name": "http://tail\-f\.com/ns/aaa/1\.1:passwdStr"},
     {"name": "MD5DigestString"}]}}},
 "data":
 {"kind": "list\-entry",
  "name": "user",
  "qname": "aaa:user",
  "access":
  {"create": true,
   "update": true,
   "delete": true},
  "children":
  [{"kind": "key",
    "name": "name",
    "qname": "aaa:name",
    "info": {"string": "Login name of the user"},
    "mandatory": true,
    "access": {"update": true},
    "type": {"name": "string", "primitive": true}},
   \.\.\.]}}
.
.fi
.
.IP "" 0
.
.SH "METHOD hide_schema"
Hides data which has been adorned with a "hidden" statement in YANG modules\. "hidden" statements is an extension defined in the tail\-common YANG module (http://tail\-f\.com/yang/common)\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "group_name": <string>
.
.fi
.
.P
The \fBgroup_name\fR param is as defined by a "hidden" statement in a YANG module\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD unhide_schema"
Unhides data which has been adorned with a "hidden" statement in YANG modules\. "hidden" statements is an extension defined in the tail\-common YANG module (http://tail\-f\.com/yang/common)\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "group_name": <string>,
 "passwd": <string>}
.
.fi
.
.P
The \fBgroup_name\fR param is as defined by a "hidden" statement in a YANG module\.
.
.P
The \fBpasswd\fR param is a password needed to hide the data that has been adorned with a "hidden" statement\. The password is as defined in the  file\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD run_action"
Invokes an action or rpc defined in a YANG module\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "path": <string>,
 "params": <json, optional>
 "format": <"normal" | "bracket", default: "normal">,
 "comet_id": <string, optional>,
 "handle": <string, optional>}
.
.fi
.
.P
Actions are as specified in th YANG module, i\.e\. having a specific name and a well defined set of parameters and result\. the \fBpath\fR param is a keypath pointing to an action or rpc in and the \fBparams\fR param is a JSON object with action parameters\.
.
.P
The \fBformat\fR param defines if the result should be an array of key values or a pre\-formatted string on bracket format as seen in the CLI\. The result is also as specified by the YANG module\.
.
.P
Both a \fBcomet_id\fR and \fBhandle\fR need to be provided in order to receive notifications\.
.
.SS "RESULT"
.
.nf

<string | array of result>

result = {"name": <string>, "value": <string>}
.
.fi
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "action\.invalid_result", "data": {"path": <string, path to invalid result>}}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", id: 1, \e
         "method": "run_action", \e
         "params": {"th": 2, \e
                    "path": "/dhcp:dhcp/set\-clock", \e
                    "params": {"clockSettings": "2014\-02\-11T14:20:53\.460%2B01:00"}}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": [{"name":"systemClock", "value":"0000\-00\-00T03:00:00+00:00"},
            {"name":"inlineContainer/bar", "value":"false"},
            {"name":"hardwareClock","value":"0000\-00\-00T04:00:00+00:00"}]}
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

curl \e
    \-s \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d\'{"jsonrpc": "2\.0", "id": 1, \e
        "method": "run_action", \e
        "params": {"th": 2, \e
                   "path": "/dhcp:dhcp/set\-clock", \e
                   "params": {"clockSettings": \e
    "2014\-02\-11T14:20:53\.460%2B01:00"}, \e
                   "format": "bracket"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": "systemClock 0000\-00\-00T03:00:00+00:00\eninlineContainer  {\en    \e
     bar false\en}\enhardwareClock 0000\-00\-00T04:00:00+00:00\en"}
.
.fi
.
.IP "" 0
.
.P
date: 2014\-03\-07 layout: post title: API \- Session description: "Reference and usage examples of the API \- Session\." modified:
.
.SH "tags: [api, session]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIlogin\fR \- Creates a user session and sets a browser cookie
.
.IP "\(bu" 4
\fIlogout\fR \- Removes a user session and invalidates the browser cookie
.
.IP "\(bu" 4
\fIkick_user\fR \- Kills a user session, i\.e\. kicking out the user
.
.IP "" 0
.
.SH "METHOD login"
Creates a user session and sets a browser cookie
.
.SS "PARAMS"
.
.nf

{"user": <string>, "passwd": <string>}
.
.fi
.
.P
The \fBuser\fR and \fBpasswd\fR are the credentials to be used in order to create a user session\. The common AAA engine in &product; is used to verify the credentials\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
\fBNOTE\fR The response will have a \fBSet\-Cookie\fR HTTP header with a \fBsessionid\fR cookie which will be your authentication token for upcoming JSON\-RPC requests\.
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "login", \e
         "params": {"user": "joe", \e
                    "passwd": "SWkkasE32"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "error":
 {"code": \-32000,
  "type": "rpc\.method\.failed",
  "message": "Method failed"}}
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

curl \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "login", \e
         "params": {"user": "admin", \e
         "passwd": "admin"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": {}}
.
.fi
.
.IP "" 0
.
.P
\fBNOTE\fR \fBsessionid\fR cookie is set at this point in your User Agent (browser)\. In our examples, we set the cookie explicitly in the upcoming requests for clarity\.
.
.IP "" 4
.
.nf

curl \e
    \-\-cookie "sessionid=sess4245223558720207078;" \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "get_trans"}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": {"trans": []}}
.
.fi
.
.IP "" 0
.
.SH "METHOD logout"
Removes a user session and invalidates the browser cookie
.
.P
The HTTP cookie identifies the user session so no input parameters are needed\.
.
.SS "PARAMS"
None\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie "sessionid=sess4245223558720207078;" \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "logout"}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": {}}
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

curl \e
    \-\-cookie "sessionid=sess4245223558720207078;" \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "logout"}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 0
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "error":
 {"code": \-32000,
  "type": "session\.invalid_sessionid",
  "message": "Invalid sessionid"}}
.
.fi
.
.IP "" 0
.
.SH "METHOD kick_user"
Kills a user session, i\.e\. kicking out the user
.
.SS "PARAMS"
.
.nf

{"user": <string | number>}
.
.fi
.
.P
The \fBuser\fR param is either the username of a logged in user or session id\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Session (data) description: "Reference and usage examples of the API \- Session (data)\." modified:
.
.SH "tags: [api, session]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_session_data\fR \- Gets session data from the session store
.
.IP "\(bu" 4
\fIput_session_data\fR \- Puts session data into the session store
.
.IP "\(bu" 4
\fIerase_session_data\fR \- Erases session data previously stored with \fBput_session_data\fR
.
.IP "" 0
.
.SH "METHOD get_session_data"
Gets session data from the session store
.
.SS "PARAMS"
.
.nf

{"key": <string>}
.
.fi
.
.P
The \fBkey\fR param for which to get the stored data for\. Read more about the session store in the \fBput_session_data\fR method\.
.
.SS "RESULT"
.
.nf

{"value": <string>}
.
.fi
.
.SH "METHOD put_session_data"
Puts session data into the session store\. The session store is small key\-value server\-side database where data can be stored under a unique key\. The data may be an arbitrary object, but not a function object\. The object is serialized into a JSON string and then stored on the server\.
.
.SS "PARAMS"
.
.nf

{"key": <string>,
 "value": <string>}
.
.fi
.
.P
The \fBkey\fR param is the unique key for which the data in the \fBvalue\fR param is to be stored\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD erase_session_data"
Erases session data previously stored with "put_session_data"\.
.
.SS "PARAMS"
.
.nf

{"key": <string>}
.
.fi
.
.P
The \fBkey\fR param for which all session data will be erased\. Read more about the session store in the \fBput_session_data\fR method\.
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Transaction description: "Reference and usage examples of the API \- Transaction\." modified:
.
.SH "tags: [api, transactions]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_trans\fR \- Lists all active read transactions
.
.IP "\(bu" 4
\fInew_trans\fR \- Creates a transaction (read\-only or read\-write)
.
.IP "\(bu" 4
\fIdelete_trans\fR \- Deletes a transaction created by "new_read_trans" or "new_write_trans"
.
.IP "\(bu" 4
\fIset_trans_comment\fR \- Adds a comment to the active read\-write transaction
.
.IP "\(bu" 4
\fIset_trans_label\fR \- Adds a label to the active read\-write transaction
.
.IP "" 0
.
.SH "METHOD get_trans"
Lists all transactions
.
.SS "PARAMS"
None\.
.
.SS "RESULT"
.
.nf

{"trans": <array of transaction>}

transaction =
 {"db": <"running" | "startup" | "candidate">,
  "mode": <"read" | "read_write", default: "read">,
  "conf_mode": <"private" | "shared" | "exclusive", default: "private">,
  "tag": <string>,
  "th": <integer>}
.
.fi
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "get_trans"}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result":
 {"trans":
  [{"db": "running",
    "th": 2}]}}
.
.fi
.
.IP "" 0
.
.SH "METHOD new_trans"
Creates a new transaction
.
.SS "PARAMS"
.
.nf

{"db": <"startup" | "running" | "candidate", default: "running">,
 "mode": <"read" | "read_write", default: "read">,
 "conf_mode": <"private" | "shared" | "exclusive", default: "private">,
 "tag": <string>}
.
.fi
.
.P
The \fBconf_mode\fR param specifies which transaction semantics to use when it comes to lock and commit strategies\. These three modes mimics the modes available in the CLI\.
.
.P
The meaning of \fBprivate\fR, \fBshared\fR and \fBexclusive\fR have slightly different meaning depending on how the system is configured; with a writable running, startup or candidate configuration\.
.
.P
\fBprivate\fR (\fIwritable running enabled\fR) \- Edit a private copy of the running configuration, no lock is taken\.
.
.P
\fBprivate\fR (\fIwritable running disabled, startup enabled\fR) \- Edit a private copy of the startup configuration, no lock is taken\.
.
.P
\fBexclusive\fR (\fIcandidate enabled\fR) \- Lock the running configuration and the candidate configuration and edit the candidate configuration\.
.
.P
\fBexclusive\fR (\fIcandidate disabled, startup enabled\fR) \- Lock the running configuration (if enabled) and the startup configuration and edit the startup configuration\.
.
.P
\fBshared\fR (\fIwritable running enabled, candidate enabled\fR) \- Edit the candidate configuration without locking it\.
.
.P
The \fBtag\fR param is a way to tag transactions with a keyword, so that they can be filtered out when you call the \fBget_trans\fR method\.
.
.SS "RESULT"
.
.nf

{"th": <number>}
.
.fi
.
.P
A new transaction handler id
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "trans\.confirmed_commit_in_progress"}
{"type": "db\.locked", "data": {"sessions": <array of string>}}
.
.fi
.
.P
The \fBdata\.sessions\fR param is an array of strings describing the current sessions of the locking user, e\.g\. an array of "admin tcp (cli from 192\.245\.2\.3) on since 2006\-12\-20 14:50:30 exclusive"\.
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
         "method": "new_trans", \e
         "params": {"db": "running", \e
                    "mode": "read"}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result": 2}
.
.fi
.
.IP "" 0
.
.SH "METHOD delete_trans"
Deletes a transaction created by \fBnew_trans\fR or \fBnew_webui_trans\fR
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD set_trans_comment"
Adds a comment to the active read\-write transaction\. This comment will be stored in rollback files and can be seen with a call to \fBget_rollbacks\fR\.
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD set_trans_label"
Adds a label to the active read\-write transaction\. This label will be stored in rollback files and can be seen with a call to \fBget_rollbacks\fR\.
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Transaction (changes) description: "Reference and usage examples of the API \- Transaction (changes)\." modified:
.
.SH "tags: [api, transactions, changes]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIis_trans_modified\fR \- Checks if any modifications has been done to a transaction
.
.IP "\(bu" 4
\fIget_trans_changes\fR \- Extracts modifications done to a transaction
.
.IP "\(bu" 4
\fIvalidate_trans\fR \- Validates a transaction
.
.IP "\(bu" 4
\fIget_trans_conflicts\fR \- Gets the conflicts registered in a transaction
.
.IP "\(bu" 4
\fIresolve_trans\fR \- Tells the server that the conflicts have been resolved
.
.IP "" 0
.
.SH "METHOD is_trans_modified"
Checks if any modifications has been done to a transaction
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{"modified": <boolean>}
.
.fi
.
.SH "METHOD get_trans_changes"
Extracts modifications done to a transaction
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{"changes": <array of change>}

change =
 {"keypath": <string>,
  "op": <"created" | "deleted" | "modified" | "value_set">,
  "value": <string,>,
  "old": <string>
 }
.
.fi
.
.P
The \fBvalue\fR param is only interesting if \fBop\fR is set to one of \fBcreated\fR, \fBmodified\fR or \fBvalue_set\fR\.
.
.P
The \fBold\fR param is only interesting if \fBop\fR is set to \fBmodified\fR\.
.
.SS "EXAMPLE"
.
.nf

curl \e
    \-\-cookie \'sessionid=sess12541119146799620192;\' \e
    \-X POST \e
    \-H \'Content\-Type: application/json\' \e
    \-d \'{"jsonrpc": "2\.0", "id": 1, \e
        "method": "changes", \e
        "params": {"th": 2}}\' \e
    http://127\.0\.0\.1:8008/jsonrpc
.
.fi
.
.IP "" 4
.
.nf

{"jsonrpc": "2\.0",
 "id": 1,
 "result":
 [{"keypath":"/dhcp:dhcp/default\-lease\-time",
   "op": "value_set",
   "value": "100",
   "old": ""}]}
.
.fi
.
.IP "" 0
.
.SH "METHOD validate_trans"
Validates a transaction
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
or
.
.IP "" 4
.
.nf

{"warnings": <array of warning>}

warning = {"paths": <array of string>, "message": <string>}
.
.fi
.
.IP "" 0
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "trans\.resolve_needed", "data": {"users": <array string>}}
.
.fi
.
.P
The \fBdata\.users\fR param is an array of conflicting usernames\.
.
.IP "" 4
.
.nf

{"type": "trans\.validation_failed", "data": {"errors": <array of error>}}

error = {"paths": <array of string>, "message": <string>}
.
.fi
.
.IP "" 0
.
.P
The \fBdata\.errors\fR param points to a keypath that is invalid\.
.
.SH "METHOD get_trans_conflicts"
Gets the conflicts registered in a transaction
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{"conflicts:" <array of conflicts>}

conflict =
 {"keypath": <string>,
  "op": <"created" | "deleted" | "modified" | "value_set">,
  "value": <string>,
  "old": <string>}
.
.fi
.
.P
The \fBvalue\fR param is only interesting if \fBop\fR is set to one of \fBcreated\fR, \fBmodified\fR or \fBvalue_set\fR\.
.
.P
The \fBold\fR param is only interesting if \fBop\fR is set to \fBmodified\fR\.
.
.SH "METHOD resolve_trans"
Tells the server that the conflicts have been resolved
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Transaction (commit changes) description: "Reference and usage examples of the API \- Transaction (commit changes)\." modified:
.
.SH "tags: [api, transactions, changes, commit]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIvalidate_commit\fR \- Validates a transaction before calling "commit"
.
.IP "\(bu" 4
\fIclear_validate_lock\fR \- Releases validate lock taken by "validate_commit"
.
.IP "\(bu" 4
\fIcommit\fR \- Copies the configuration into the running datastore
.
.IP "\(bu" 4
\fIconfirm_commit\fR \- Confirms the currently pending confirmed commit
.
.IP "\(bu" 4
\fIabort_commit\fR \- Aborts the currently pending confirmed commit
.
.IP "" 0
.
.SH "METHOD validate_commit"
Validates a transaction before calling \fBcommit\fR\. If this method succeeds (with or without warnings) then the next operation \fImust\fR be all call to either \fBcommit\fR or \fBclear_validate_lock\fR\. The configuration will be locked for access by other users until one of these methods are called\.
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
or
.
.IP "" 4
.
.nf

{"warnings": <array of warning>}

warning = {"paths": <array of string>, "message": <string>}
.
.fi
.
.IP "" 0
.
.SS "ERRORS (SPECIFIC)"
Same as for the \fBvalidate_trans\fR method\.
.
.SH "METHOD clear_validate_lock"
Releases validate lock taken by \fBvalidate_commit\fR
.
.SS "PARAMS"
.
.nf

{"th": <number>}
.
.fi
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD commit"
Copies the configuration into the running datastore\.
.
.SS "PARAMS"
.
.nf

{"th": <number>,
 "timeout": <number, default: 0>,
 "release_locks" <boolean, default: true>}
.
.fi
.
.P
The \fBtimeout\fR param represents the confirmed commit timeout, i\.e\. set it to zero (0) to commit without timeout\.
.
.P
.
.P
Commit behaviour can be changed via an extra \fBflags\fR param:
.
.IP "" 4
.
.nf

{"flags": <flags, default: []>}

flags = <array of string or bitmask>
.
.fi
.
.IP "" 0
.
.P
The \fBflags\fR param is a list of flags that can change the commit behavior:
.
.IP "\(bu" 4
no\-revision\-drop \- do not drop revision
.
.IP "\(bu" 4
async\-commit\-queue \- if some device is non\-operational or has data waiting in the commit queue, the data in this transaction will be placed in the commit queue; a \fBcommit_queue_id\fR will be found in the response
.
.IP "\(bu" 4
no\-networking \- do not send data to the devices; this is a way to manipulate CDB in &product; without generating any southbound traffic
.
.IP "\(bu" 4
dry\-run=XXX \- where XXX is the desired output format: xml, cli or native\. Do not send data to the devices; this is a way to see the effects that would have taken place as a diff
.
.IP "\(bu" 4
no\-out\-of\-sync\-check \- continue with the transaction even if &product; detects that a device\'s configuration is out of sync
.
.IP "\(bu" 4
no\-overwrite \- &product; will check that the data that should be modified has not changed on the device compared to &product;\'s view of the data
.
.IP "\(bu" 4
sync\-commit\-queue \- if some device is non\-operational or has data waiting in the commit queue, the data in this transaction will be placed in the commit queue; that flag will cause the operation to not return until the transaction has been sent to all devices, or a timeout occurs; a \fBcommit_queue_id\fR will be found in the response if the timeout occurs
.
.IP "\(bu" 4
sync\-commit\-timeout=XXX \- where XXX is a timeout in seconds; only allowed after sync\-commit\-queue
.
.IP "" 0
.
.P
For backwards compatibility, the \fBflags\fR param can also be a bit mask with the following limit values:
.
.IP "\(bu" 4
\fB1 << 0\fR \- Do not release locks, overridden by the \fBrelease_locks\fR if set
.
.IP "\(bu" 4
\fB1 << 2\fR \- Do not drop revision
.
.IP "" 0
.
.P
.
.IP "\(bu" 4
If a call to \fBconfirm_commit\fR is not done within \fBtimeout\fR seconds an automatic rollback is performed\. This method can also be used to "extend" a confirmed commit that is already in progress, i\.e\. set a new timeout or add changes\.
.
.IP "\(bu" 4
A call to \fBabort_commit\fR can be made to abort the confirmed commit\.
.
.IP "" 0
.
.P
\fBNOTE\fR: Must be preceded by a call to \fBvalidate_commit\fR
.
.P
\fBNOTE\fR: The transaction handler is deallocated as a side effect of this method
.
.SS "RESULT"
.
.nf

{"commit_queue_id": <integer>}
.
.fi
.
.P
The \fBcommit_queue_id\fR is only returned if the method is run with the \fBasync_commit_queue\fR flag, or with the \fBsync_commit_queue\fR flag and a timeout occurs\.
.
.SS "ERRORS (SPECIFIC)"
.
.nf

{"type": "trans\.confirmed_commit_in_progress"}
.
.fi
.
.SH "METHOD abort_commit"
Aborts the active read\-write transaction
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.SH "METHOD confirm_commit"
Confirms the currently pending confirmed commit
.
.SS "RESULT"
.
.nf

{}
.
.fi
.
.P
date: 2014\-03\-07 layout: post title: API \- Transaction (webui) description: "Reference and usage examples of the API \- Transaction (webui)\." modified:
.
.SH "tags: [api, transactions]"
.
.IP "\(bu" 4
API Overview \fIapi\fR
.
.IP "\(bu" 4
\fIget_webui_trans\fR \- Gets current write transaction
.
.IP "\(bu" 4
\fInew_webui_trans\fR \- Creates the active read\-write transaction
.
.IP "" 0
.
.SH "METHOD get_webui_trans"
Gets the webui read\-write transaction
.
.SS "RESULT"
.
.nf

{"trans": <array of trans>}

trans =
 {"db": <"startup" | "running" | "candidate", default: "running">,
  "conf_mode": <"private" | "shared" | "exclusive", default: "private">,
  "th": <integer>
 }
.
.fi
.
.SH "METHOD new_webui_trans"
Creates a read\-write transaction that can be retrieved by \'get_webui_trans\'\.
.
.SS "PARAMS"
.
.nf

{"db": <"startup" | "running" | "candidate", default: "running">,
 "conf_mode": <"private" | "shared" | "exclusive", default: "private">}
.
.fi
.
.P
See \'new_trans\' for semantics of the parameters and specific errors\.
.
.SS "RESULT"
.
.nf

{"th": <number>}
.
.fi
.
.P
A new transaction handler id
