/*
 * Copyright 2005-2008 Tail-F Systems AB
 */


#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/poll.h>
#ifdef __QNX__
/* On QNX, POLLIN is actually POLLRDNORM|POLLRDBAND, and a
   poll() bug may make it deliver POLLRDBAND on a pipe(!) */
#undef POLLIN
#define POLLIN POLLRDNORM
#endif
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <ctype.h>
#include <stdarg.h>
#include <syslog.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/file.h>

#include <confd_lib.h>
#include <confd_dp.h>

/* file generated by confdc from aaa.cs */
#include "aaa_bridge.h"


/* global variables need for confdlib API */
static struct confd_db_cbs dbcbs;
static struct confd_trans_cbs trans;
static struct confd_daemon_ctx *dctx;
static struct confd_data_cbs  data;
static int ctlsock;
static int workersock;

/* default value of aaa config file */
static char *conf_file = "/etc/confd/aaa.conf";
static int conf_file_lock_fd = -1;
static char prep_file[256], ckp_file[256], startup_file[256];
static FILE *estream;
static int use_startup = 0;
static struct confd_type *cmd_ops_type, *data_ops_type;


struct user {
    char *name;
    int uid; int gid;
    char *password;
    char *ssh_keydir;
    char *homedir;
};

static struct user users[1024];
static int num_users = 0;

struct group {
    char *name;
    char *users;
    int gid;
};

static struct group groups[32];
static int num_groups = 0;

struct cmdrule {
    u_int32_t index;
    char *context;
    char *command;
    char *group;
    char *ops;
    int action;
};

struct datarule {
    u_int32_t index;
    char *namespace;
    char *context;
    char *keypath;
    char *group;
    char *ops;
    int action;
};

static struct datarule drules[1024];
static struct cmdrule crules[1024];
static int num_drules = 0;
static int num_crules = 0;


static int all_spaces(char *buf)
{
    int i, len;
    if (!isspace(buf[0]))
        return 0;
    len = strlen(buf);
    for(i=0; i<len; i++) {
        if (! isspace(buf[i]))
            return 0;
    }
    return 1;
}


enum ExitStatus {
    NORMAL = 0,
    /* confd_fatal will use exit code 1 */
    OPENERR = 2,
    PROTOERR = 3,
    WRITEERR = 4,
    MALLOCFAIL = 5,
    CONNECTERR = 6,
    LIBERR = 7,
    SYSERR = 8,
    BADCONF = 9,
    HUP = 129
};


static void err() { fprintf(stderr, "Return err\n"); }

#define RET_ERR() {  err(); return CONFD_ERR; }

static void fatal(enum ExitStatus ecode, char *fmt, ...)
{
    va_list args;

    if (strlen(fmt) > 0) {
        va_start(args,fmt);
        vsyslog(LOG_ERR, fmt, args);
        vfprintf(estream,fmt,args);
        va_end(args);
    }
    closelog();
    exit(ecode);
}


static void schema_err(int num)
{
    fatal(PROTOERR, "Got unexpected XML data from ConfD, error: %d", num);
}


static int fpsave(FILE *fp)
{
    int i;

    fprintf(fp, "# auth file saved by confd_aaa_bridge \n\n"
            "[users]\n\n");

    for(i=0; i<num_users; i++) {
        fprintf(fp, "%s\t%d\t%d\t%s\t%s\t%s\n",
                users[i].name,
                users[i].uid, users[i].gid,
                users[i].password,
                users[i].ssh_keydir,
                users[i].homedir);
    }
    fprintf(fp, "\n\n[groups]\n\n");
    for(i=0; i<num_groups; i++) {
        fprintf(fp, "%s\t%d\t%s\n",
                groups[i].name,
                groups[i].gid,
                groups[i].users
                );
    }
    fprintf(fp, "\n\n[cmdrules]\n\n");
    for(i=0; i<num_crules; i++) {
        char *action = "?";
        switch (crules[i].action) {
        case aaa_accept:
            action = "accept";
            break;
        case aaa_accept_log:
            action = "accept_log";
            break;
        case aaa_reject:
            action = "reject";
            break;
        }
        fprintf(fp, "%d\t%s\t%s\t%s\t%s\t%s\n",
                crules[i].index,
                crules[i].context,
                crules[i].command,
                crules[i].group,
                crules[i].ops,
                action);
    }
    fprintf(fp, "\n");

    fprintf(fp, "\n\n[datarules]\n\n");
    for(i=0; i<num_drules; i++) {
        char *action = "?";
        switch (drules[i].action) {
        case aaa_accept:
            action = "accept";
            break;
        case aaa_accept_log:
            action = "accept_log";
            break;
        case aaa_reject:
            action = "reject";
            break;
        }
        fprintf(fp, "%d\t%s\t%s\t%s\t%s\t%s\t%s\n",
                drules[i].index,
                drules[i].namespace,
                drules[i].context,
                drules[i].keypath,
                drules[i].group,
                drules[i].ops,
                action);
    }
    fprintf(fp, "\n");


    return 1;
}

static int save(char *file)
{
    FILE *fp;
    int i;

    if ((fp = fopen(file, "w")) == NULL)
        return -1;
    i = fpsave(fp);
    fclose(fp);
    return i;
}

static void xfree(void *ptr)
{
    if (ptr != NULL)
        free(ptr);
}


/* parse an auth file in .ini syntax and return 1 if ok */
/* and < 0 on error */

static int restore(char *file)
{
    int seen_users, seen_groups, seen_rules, seen_drules;
    FILE *fp;
    char buf[BUFSIZ];
    int i;
    int lineno = 0;
    char *sep = " \t\r\n";
    confd_value_t v;

    if ((fp = fopen(file, "r")) == NULL)
        return -2;

    num_users = num_groups = num_crules = num_drules = 0;
    seen_users = seen_groups = seen_rules = seen_drules = 0;

    /* first look for the [users] mark */
    while (fgets(&buf[0], BUFSIZ, fp) != NULL) {
        lineno++;
        if ((buf[0] == '#') || all_spaces(buf))
            continue;
        if (strncmp(buf, "[users]", strlen("[users]")) == 0) {
            seen_users = 1;
            break;
        }
        if ( ! all_spaces(buf)) {
            goto err;
        }
    }

    if (!seen_users) goto err;


    /* Now it's time to collect the users */
     while (fgets(&buf[0], BUFSIZ, fp) != NULL) {
         char *name, *password, *ssh_keydir, *homedir, *uid, *gid;

         lineno++;
         if ((buf[0] == '#') || all_spaces(buf))
            continue;
         if (strncmp(buf, "[groups]", strlen ("[groups]")) == 0) {
             seen_groups = 1;
             break;
         }
         name =strtok(buf, sep);
         uid = strtok(NULL, sep);
         gid = strtok(NULL, sep);
         password = strtok(NULL, sep);
         ssh_keydir = strtok(NULL, sep);
         homedir = strtok(NULL, sep);
         if (name == NULL || password == NULL || ssh_keydir == NULL ||
             uid == NULL || gid == NULL || homedir == NULL) goto err;

         users[num_users].name = strdup(name);
         users[num_users].uid = atoi(uid);
         users[num_users].gid = atoi(gid);
         users[num_users].password = strdup(password);
         users[num_users].ssh_keydir = strdup(ssh_keydir);
         users[num_users++].homedir = strdup(homedir);
     }
     if (!seen_groups) goto err;

     /* collect the groups */
     while (fgets(&buf[0], BUFSIZ, fp) != NULL) {
          char *name, *users, *gid;

         lineno++;
         if ((buf[0] == '#') || all_spaces(buf))
             continue;
         if (strncmp(buf, "[cmdrules]", strlen ("[cmdrules]")) == 0) {
             seen_rules = 1;
             break;
         }
         name= strtok(buf, sep);
         gid = strtok(NULL, sep);
         users = strtok(NULL, "\n");

         if (name == NULL || users == NULL || gid == NULL) goto err;
         groups[num_groups].name = strdup(name);
         groups[num_groups].users = strdup(users);
         groups[num_groups++].gid = atoi(gid);
     }

     if (!seen_rules) goto err;

     /* collect the command rules */
     while (fgets(&buf[0], BUFSIZ, fp) != NULL) {
          char *indexstr, *context, *path, *group, *ops, *actionstr;
          int action;
          int k, index;

          lineno++;
          if ((buf[0] == '#') || all_spaces(buf))
              continue;
          if (strncmp(buf, "[datarules]", strlen ("[datarules]")) == 0) {
              seen_drules = 1;
             break;
          }
          indexstr = strtok(buf, sep);
          context = strtok(NULL, sep);
          path = strtok(NULL, sep);
          group = strtok(NULL, sep);
          ops = strtok(NULL, sep);
          actionstr = strtok(NULL, sep);

          if (indexstr == NULL || context == NULL || path == NULL ||
              ops == NULL || actionstr == NULL) goto err;
          if (strcmp(actionstr, "accept") == 0)
              action = aaa_accept;
          else if (strcmp(actionstr, "accept_log") == 0)
              action = aaa_accept_log;
          else if (strcmp(actionstr, "reject") == 0)
              action = aaa_reject;
          else
              goto err;
          index = atoi(indexstr);
          /* check index is unique */
          for(k=0; k<num_crules; k++)
              if (crules[k].index == index)
                  goto err;
          if (confd_str2val(cmd_ops_type, ops, &v) != CONFD_OK)
              goto err;
          crules[num_crules].index = index;
          crules[num_crules].context = strdup(context);
          crules[num_crules].command = strdup(path);
          crules[num_crules].group = strdup(group);
          crules[num_crules].ops = strdup(ops);
          crules[num_crules++].action = action;
      }

      if (!seen_drules) goto err;
      /* collect the data rules */
      while (fgets(&buf[0], BUFSIZ, fp) != NULL) {
          char *indexstr, *namespace, *context, *path, *group, *ops, *actionstr;
          int action;
          int k, index;

          lineno++;
          if ((buf[0] == '#') || all_spaces(buf))
              continue;

          indexstr = strtok(buf, sep);
          namespace = strtok(NULL, sep);
          context = strtok(NULL, sep);
          path = strtok(NULL, sep);
          group = strtok(NULL, sep);
          ops = strtok(NULL, sep);
          actionstr = strtok(NULL, sep);

          if (indexstr == NULL || context == NULL || path == NULL ||
              ops == NULL || actionstr == NULL) goto err;
          if (strcmp(actionstr, "accept") == 0)
              action = aaa_accept;
          else if (strcmp(actionstr, "accept_log") == 0)
              action = aaa_accept_log;
          else if (strcmp(actionstr, "reject") == 0)
              action = aaa_reject;
          else
              goto err;
          index = atoi(indexstr);
          /* check index is unique */
          for(k=0; k<num_drules; k++)
              if (drules[k].index == index)
                  goto err;
          if (confd_str2val(data_ops_type, ops, &v) != CONFD_OK)
              goto err;
          drules[num_drules].index = index;
          drules[num_drules].namespace = strdup(namespace);
          drules[num_drules].context = strdup(context);
          drules[num_drules].keypath = strdup(path);
          drules[num_drules].group = strdup(group);
          drules[num_drules].ops = strdup(ops);
          drules[num_drules++].action = action;
      }


      return 1;

  err:
      syslog(LOG_ERR, "Unexpected chars at line %d in %s\n",
             lineno, file);
      fprintf(estream, "Unexpected chars at line %d in %s\n",
              lineno, file);

      for (i=0; i< num_users; i++) {
          free(users[i].name);
          free(users[i].password);
          free(users[i].ssh_keydir);
          free(users[i].homedir);
      }
      num_users =0;

      for (i=0; i< num_groups; i++) {
          free(groups[i].name);
          free(groups[i].users);
      }
      num_groups = 0;
      for (i=0; i< num_crules; i++) {
          free(crules[i].context);
          free(crules[i].command);
          free(crules[i].group);
          free(crules[i].ops);
      }
      for (i=0; i< num_drules; i++) {
          free(drules[i].namespace);
          free(drules[i].context);
          free(drules[i].keypath);
          free(drules[i].group);
          free(drules[i].ops);
      }

      num_crules = num_drules = 0;
      fclose(fp);
      return -1;
}

static struct  user *find_user(confd_value_t *u)
{
    int i;
    for (i=0; i<num_users; i++) {
        if (confd_svcmp(users[i].name, u) == 0)
            return &users[i];
    }
    return NULL;
}

static struct  group *find_group(confd_value_t *u)
{
    int i;
    for (i=0; i<num_groups; i++) {
        if (confd_svcmp(groups[i].name, u) == 0)
            return &groups[i];
    }
    return NULL;
}


static struct  cmdrule *find_crule(confd_value_t *v)
{
    int i;
    for (i=0; i<num_crules; i++) {
        if (crules[i].index == CONFD_GET_UINT32(v))
            return &crules[i];
    }
    return NULL;
}


static struct  datarule *find_drule(confd_value_t *v)
{
    int i;
    for (i=0; i<num_drules; i++) {
        if (drules[i].index == CONFD_GET_UINT32(v))
            return &drules[i];
    }
    return NULL;
}



static int t_init(struct confd_trans_ctx *tctx)
{
    confd_trans_set_fd(tctx, workersock);
    tctx->t_opaque = 0;
    return CONFD_OK;
}

static int t_abort(struct confd_trans_ctx *tctx)
{
    restore(conf_file);
    unlink(prep_file);
    tctx->t_opaque = 0;
    return CONFD_OK;
}


static char *bufdup(confd_value_t *v)
{
    char *buf;
    int sz = CONFD_GET_BUFSIZE(v);
    if ((buf = (char*) malloc(1+sz)) == NULL)
        exit(MALLOCFAIL);
    memcpy(buf, CONFD_GET_BUFPTR(v),sz);
    buf[sz] = 0;
    return buf;
}

/* assume that other apps also try to lockf/fcntl */
static int t_lock(struct confd_trans_ctx *tctx)
{
    if ((conf_file_lock_fd = open(conf_file, O_RDWR)) > 0) {
        if (lockf(conf_file_lock_fd, F_TLOCK, 0) != 0) {
            close(conf_file_lock_fd);
            return CONFD_ALREADY_LOCKED;
        }
        return CONFD_OK;
    }
    RET_ERR();
}

static int tt_unlock(struct confd_trans_ctx *tctx)
{
    if (conf_file_lock_fd > 0) {
        lockf(conf_file_lock_fd, F_ULOCK, 0);
        close(conf_file_lock_fd);
    }
    return CONFD_OK;
}


static int t_unlock(struct confd_trans_ctx *tctx)
{
    return tt_unlock(tctx);
}



static int t_prepare(struct confd_trans_ctx *tctx)
{
    if (save(prep_file) < 0)
        RET_ERR();
    return CONFD_OK;
}


static int t_commit(struct confd_trans_ctx *tctx)
{
    if (rename(prep_file, conf_file) == 0) {
        return CONFD_OK;
    }
    RET_ERR();
}


static int t_finish(struct confd_trans_ctx *tctx)
{
    if (tctx->t_opaque !=  0) {
        /* perform the equivalent of */
        /* confd --clear-aaa-cache but from the C code */
        confd_aaa_reload(tctx);
    }
    return tt_unlock(tctx);
}


static int ret_null(struct confd_trans_ctx *tctx)
{
    confd_data_reply_next_key(tctx, NULL, -1, -1);
    return CONFD_OK;
}

static int get_next(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *keypath,
                    long next)
{
    confd_value_t v;
    switch(CONFD_GET_XMLTAG(&(keypath->v[0][0]))) {
    case aaa_user:
        /* get first user */
        if (num_users == 0) return ret_null(tctx);
        if (next == num_users) return ret_null(tctx);
        if (next == -1) {
            CONFD_SET_STR(&v, users[0].name);
            confd_data_reply_next_key(tctx, &v, 1, 1);
        }
        else {
             CONFD_SET_STR(&v, users[next].name);
             confd_data_reply_next_key(tctx, &v, 1, next+1);
        }
        return CONFD_OK;
    case aaa_group:
        if (num_groups == 0) return ret_null(tctx);
        if (next == num_groups) return ret_null(tctx);
        if (next == -1) {
            CONFD_SET_STR(&v, groups[0].name);
            confd_data_reply_next_key(tctx, &v, 1, 1);
        }
        else {
             CONFD_SET_STR(&v, groups[next].name);
            confd_data_reply_next_key(tctx, &v, 1, next+1);
        }
        return CONFD_OK;
    case aaa_cmdrule:
        if (num_crules == 0) return ret_null(tctx);
        if (next == num_crules) return ret_null(tctx);
        if (next == -1) {
            CONFD_SET_UINT32(&v, crules[0].index);
            confd_data_reply_next_key(tctx, &v, 1, 1);
        }
        else {
            CONFD_SET_UINT32(&v, crules[next].index);
            confd_data_reply_next_key(tctx, &v, 1, next+1);
        }
        return CONFD_OK;
    case aaa_datarule:
        if (num_drules == 0) return ret_null(tctx);
        if (next == num_drules) return ret_null(tctx);
        if (next == -1) {
            CONFD_SET_UINT32(&v, drules[0].index);
            confd_data_reply_next_key(tctx, &v, 1, 1);
        }
        else {
            CONFD_SET_UINT32(&v, drules[next].index);
            confd_data_reply_next_key(tctx, &v, 1, next+1);
        }
        return CONFD_OK;

    default:
        schema_err(1);
    }
    RET_ERR();
}


static int exists_optional(struct confd_trans_ctx *tctx,
                           confd_hkeypath_t *keypath)
{
    /* No support for /aaa/ios yet. */
    confd_data_reply_not_found(tctx);
    return CONFD_OK;
}

static int get_elem(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *keypath)
{
    confd_value_t v;
    confd_value_t *leaf = &(keypath->v[0][0]);

/* it's a get_elem in one of the dynamic elements */
    struct user *u;
    struct group *g;
    struct datarule *dr;
    struct cmdrule *cr;
    switch (CONFD_GET_XMLTAG(&(keypath->v[2][0]))) {
    case aaa_user:
        if ((u = find_user(&(keypath->v[1][0]))) == NULL) {
            confd_data_reply_not_found(tctx);
            return CONFD_OK;
        }
        switch(CONFD_GET_XMLTAG(leaf)) {
        case aaa_name:
            CONFD_SET_STR(&v, u->name);
            break;
        case aaa_uid:
            CONFD_SET_INT32(&v, u->uid);
            break;
        case aaa_gid:
            CONFD_SET_INT32(&v, u->gid);
            break;
        case aaa_password:
            CONFD_SET_STR(&v, u->password);
            break;
        case aaa_ssh_keydir:
            CONFD_SET_STR(&v, u->ssh_keydir);
            break;
        case aaa_homedir:
            CONFD_SET_STR(&v, u->homedir);
            break;
        default:
            schema_err(2);
        }
        break;
    case aaa_group:
        if ((g = find_group(&(keypath->v[1][0]))) == NULL) {
            confd_data_reply_not_found(tctx);
            return CONFD_OK;
        }
        switch(CONFD_GET_XMLTAG(leaf)) {
        case aaa_name:
            CONFD_SET_STR(&v, g->name);
            break;
        case aaa_users:
            CONFD_SET_STR(&v, g->users);
            break;
        case aaa_gid:
            if (g->gid == -1) {
                confd_data_reply_not_found(tctx);
                return CONFD_OK;
            }
            CONFD_SET_INT32(&v, g->gid);
            break;
        default:
            schema_err(3);
        }
        break;
    case aaa_cmdrule:
        if ((cr = find_crule(&(keypath->v[1][0]))) == NULL) {
            confd_data_reply_not_found(tctx);
            return CONFD_OK;
        }
        switch (CONFD_GET_XMLTAG(leaf)) {
        case aaa_index:
            CONFD_SET_UINT32(&v, cr->index);
            break;
        case aaa_context:
            CONFD_SET_STR(&v, cr->context);
            break;
        case aaa_command:
            CONFD_SET_STR(&v, cr->command);
            break;
        case aaa_group:
            CONFD_SET_STR(&v, cr->group);
            break;
        case aaa_ops:
            confd_str2val(cmd_ops_type, cr->ops, &v);
            break;
        case aaa_action:
            CONFD_SET_ENUM_HASH(&v, cr->action);
            break;
        default:
            schema_err(4);
        }
        break;


    case aaa_datarule:
        if ((dr = find_drule(&(keypath->v[1][0]))) == NULL) {
            confd_data_reply_not_found(tctx);
            return CONFD_OK;
        }
        switch (CONFD_GET_XMLTAG(leaf)) {
        case aaa_index:
            CONFD_SET_UINT32(&v, dr->index);
            break;
        case aaa_namespace:
            CONFD_SET_STR(&v, dr->namespace);
            break;
        case aaa_context:
            CONFD_SET_STR(&v, dr->context);
            break;
        case aaa_keypath:
            CONFD_SET_STR(&v, dr->keypath);
            break;
        case aaa_group:
            CONFD_SET_STR(&v, dr->group);
            break;
        case aaa_ops:
            confd_str2val(data_ops_type, dr->ops, &v);
            break;
        case aaa_action:
            CONFD_SET_ENUM_HASH(&v, dr->action);
            break;
        default:
            schema_err(4);
        }
        break;

    default:
        schema_err(5);
    }
    confd_data_reply_value(tctx, &v);
    return CONFD_OK;
}


static int set_elem(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *keypath,
                    confd_value_t *newval)
{
    confd_value_t *leaf = &(keypath->v[0][0]);

    /* it's a get_elem in one of the dynamic elements */
    struct user *u;
    struct group *g;
    struct datarule *dr;
    struct cmdrule *cr;
    switch (CONFD_GET_XMLTAG(&(keypath->v[2][0]))) {
    case aaa_user:
        if ((u = find_user(&(keypath->v[1][0]))) == NULL) {
            confd_trans_seterr(tctx, "no such user found");
            RET_ERR();
        }
        switch(CONFD_GET_XMLTAG(leaf)) {
        case aaa_name:
            xfree(u->name);
            u->name = bufdup(newval);
            break;
        case aaa_uid:
            u->uid = CONFD_GET_INT32(newval);
            break;
        case aaa_gid:
            u->gid = CONFD_GET_INT32(newval);
            break;
        case aaa_password:
            xfree(u->password);
            u->password = bufdup(newval);
            break;
        case aaa_ssh_keydir:
            xfree(u->ssh_keydir);
            u->ssh_keydir = bufdup(newval);
            break;
        case aaa_homedir:
            xfree(u->homedir);
            u->homedir = bufdup(newval);
            break;
        default:
            schema_err(6);
        }
        break;
    case aaa_group:
        if ((g = find_group(&(keypath->v[1][0]))) == NULL) {
            confd_trans_seterr(tctx, "no such group found");
            RET_ERR();
        }
        switch(CONFD_GET_XMLTAG(leaf)) {
        case aaa_name:
            xfree(g->name);
            g->name = bufdup(newval);
            break;
        case aaa_users:
            xfree(g->users);
            g->users = bufdup(newval);
            break;
        case aaa_gid:
            g->gid = CONFD_GET_INT32(newval);
            break;
        default:
            schema_err(7);
        }
        break;
    case aaa_cmdrule:
        if ((cr = find_crule(&(keypath->v[1][0]))) == NULL) {
            confd_trans_seterr(tctx, "no such rule found");
            RET_ERR();
        }
        switch (CONFD_GET_XMLTAG(leaf)) {
        case aaa_index:
            cr->index = CONFD_GET_UINT32(newval);
            break;
        case aaa_context:
            xfree(cr->context);
            cr->context = bufdup(newval);
            break;
        case aaa_command:
            xfree(cr->command);
            cr->command = bufdup(newval);
            break;
        case aaa_group:
            xfree(cr->group);
            cr->group = bufdup(newval);
            break;
        case aaa_ops:
            xfree(cr->ops);
            cr->ops = strdup(confd_val2str_ptr(cmd_ops_type, newval));
            break;
        case aaa_action:
            cr->action = CONFD_GET_ENUM_HASH(newval);
            break;
        default:
            schema_err(8);
        }
        break;

    case aaa_datarule:
        if ((dr = find_drule(&(keypath->v[1][0]))) == NULL) {
            confd_trans_seterr(tctx, "no such rule found");
            RET_ERR();
        }
        switch (CONFD_GET_XMLTAG(leaf)) {
        case aaa_index:
            dr->index = CONFD_GET_UINT32(newval);
            break;
        case aaa_namespace:
            xfree(dr->namespace);
            dr->namespace = bufdup(newval);
            break;
        case aaa_context:
            xfree(dr->context);
            dr->context = bufdup(newval);
            break;
        case aaa_keypath:
            xfree(dr->keypath);
            dr->keypath = bufdup(newval);
            break;
        case aaa_group:
            xfree(dr->group);
            dr->group = bufdup(newval);
            break;
        case aaa_ops:
            xfree(dr->ops);
            dr->ops = strdup(confd_val2str_ptr(data_ops_type, newval));
            break;
        case aaa_action:
            dr->action = CONFD_GET_ENUM_HASH(newval);
            break;
        default:
            schema_err(8);
        }
        break;
    default:
        schema_err(9);
    }
    tctx->t_opaque = (void*) 1;
    return CONFD_OK;
}

static int create(struct confd_trans_ctx *tctx,
                  confd_hkeypath_t *keypath)
{
    struct user *u;
    struct group *g;
    struct cmdrule *cr;
    struct datarule *dr;

    confd_value_t *leaf = &(keypath->v[0][0]);
    switch (CONFD_GET_XMLTAG(&(keypath->v[1][0]))) {
    case aaa_user:
        u = &users[num_users++];
        memset(u, 0, sizeof(struct user));
        u->name = bufdup(leaf);
        break;
    case aaa_group:
        g = &groups[num_groups++];
        memset(g, 0, sizeof(struct group));
        g->name = bufdup(leaf);
        break;
    case aaa_cmdrule:
        cr = &crules[num_crules++];
        memset(cr, 0, sizeof(struct cmdrule));
        cr->index = CONFD_GET_UINT32(leaf);
        break;
    case aaa_datarule:
        dr = &drules[num_drules++];
        memset(dr, 0, sizeof(struct datarule));
        dr->index = CONFD_GET_UINT32(leaf);
        break;

    default:
        schema_err(10);
    }
    tctx->t_opaque = (void*) 1;
    return CONFD_OK;
}


static int dbremove(struct confd_trans_ctx *tctx,
                    confd_hkeypath_t *keypath)
{
    int i, j;
    confd_value_t *leaf = &(keypath->v[0][0]);

    if (leaf->type == C_XMLTAG) {
        struct group *g;
        /* groups/group/gid is the only optional leaf we have */
        assert(CONFD_GET_XMLTAG(leaf) == aaa_gid);
        assert(CONFD_GET_XMLTAG(&(keypath->v[2][0])) == aaa_group);
        if ((g = find_group(&(keypath->v[1][0]))) == NULL) {
            confd_trans_seterr(tctx, "no such group found");
            return CONFD_ERR;
        }
        g->gid = -1;
        return CONFD_OK;
    }
    switch (CONFD_GET_XMLTAG(&(keypath->v[1][0]))) {
    case aaa_user:
        for (i=0; i< num_users; i++) {
            if (confd_svcmp(users[i].name, leaf) == 0) {
                xfree(users[i].name);
                xfree(users[i].password);
                xfree(users[i].ssh_keydir);
                xfree(users[i].homedir);
                for (j=i+1; j< num_users; j++) {
                    users[j-1] = users[j];
                }
                num_users--;
                tctx->t_opaque = (void*) 1;
                return CONFD_OK;
            }
        }
        break;
      case aaa_group:
          for (i=0; i< num_groups; i++) {
            if (confd_svcmp(groups[i].name, leaf) == 0) {
                xfree(groups[i].name);
                xfree(groups[i].users);
                for (j=i+1; j< num_groups; j++) {
                    groups[j-1] = groups[j];
                }
                num_groups--;
                tctx->t_opaque = (void*) 1;
                return CONFD_OK;
            }
        }
          break;
    case aaa_cmdrule:
        for (i=0; i< num_crules; i++) {
            if (crules[i].index == CONFD_GET_UINT32(leaf)) {
                xfree(crules[i].context);
                xfree(crules[i].command);
                xfree(crules[i].group);
                xfree(crules[i].ops);
                for (j=i+1; j< num_crules; j++) {
                    crules[j-1] = crules[j];
                }
                num_crules--;
                tctx->t_opaque = (void*) 1;
                return CONFD_OK;
            }
        }
        break;

    case aaa_datarule:
        for (i=0; i< num_drules; i++) {
            if (drules[i].index == CONFD_GET_UINT32(leaf)) {
                xfree(drules[i].namespace);
                xfree(drules[i].context);
                xfree(drules[i].keypath);
                xfree(drules[i].group);
                xfree(drules[i].ops);
                for (j=i+1; j< num_drules; j++) {
                    drules[j-1] = drules[j];
                }
                num_drules--;
                tctx->t_opaque = (void*) 1;
                return CONFD_OK;
            }
        }
        break;
    }
    tctx->t_opaque = (void*) 1;
    return CONFD_OK;
}


static int add_checkpoint_running(struct confd_db_ctx *dbx)
{
    if (save(ckp_file) < 0 )
        RET_ERR();
    return CONFD_OK;
}

static int  del_checkpoint_running  (struct confd_db_ctx *dbx)
{
    unlink(ckp_file);
    return CONFD_OK;
}

static int activate_checkpoint_running (struct confd_db_ctx *dbx)
{
    if (restore(ckp_file) < 0)
        RET_ERR();
    return CONFD_OK;
}

static int copy_running_to_startup(struct confd_db_ctx *dbx)
{
    if (save(startup_file) < 0 )
        RET_ERR();
    return CONFD_OK;
}

static int running_chk_not_modified(struct confd_db_ctx *dbx)
{
    struct stat st_startup, st_conf;

    if (stat(startup_file, &st_startup) == 0 &&
        (stat(conf_file, &st_conf) != 0 ||
         st_startup.st_mtime > st_conf.st_mtime))
        return CONFD_OK;
    else
        return CONFD_ERR;
}


static void init_db()
{
    int ret;
    if (restore(ckp_file) == 1) {
        unlink(ckp_file);
        return;
    }
    if (use_startup && restore(startup_file) == 1) {
        return;
    }
    ret = restore(conf_file);
    if (ret == 1)
        return;
    else if (ret == -1)
        fatal(OPENERR, "Failed to parse %s\n", conf_file);
    else if (ret == -2)
        fatal(OPENERR, "Failed to open %s\n", conf_file);

}




int main(int argc, char *argv[]) {
    struct sockaddr_in addr;
    int debuglevel = CONFD_SILENT;
    int interactive = 0;
    int oc;

    estream = stderr;
#ifdef LOG_AUTHPRIV
    openlog("confd_aaa_bridge", 0, LOG_AUTHPRIV);
#else
    openlog("confd_aaa_bridge", 0, LOG_AUTH);
#endif

    /* option character */
    while ((oc = getopt(argc, argv, "iqdtpsc:")) != -1) {
        switch (oc) {
        case 'i':
            interactive = 1;
            debuglevel = CONFD_TRACE;
            break;
        case 'q':
            debuglevel = CONFD_SILENT;
            break;
        case 'd':
            debuglevel = CONFD_DEBUG;
            break;
        case 't':
            debuglevel = CONFD_TRACE;
            break;
        case 'p':
            debuglevel = CONFD_PROTO_TRACE;
            break;
        case 's':
            use_startup = 1;
            break;
        case 'c':
            conf_file = optarg;
            break;
        default:
            fatal(BADCONF, "usage: %s [-qdti][-c aaa_file]\n", argv[0]);
        }
    }
    sprintf(prep_file, "%s.prep", conf_file);
    sprintf(ckp_file, "%s.ckp", conf_file);
    sprintf(startup_file, "%s.startup", conf_file);
    if (!use_startup)
        unlink(startup_file);

    if (!interactive)
        if ((estream = fopen("/tmp/confd_aaa_bridge.err", "a")) == NULL)
            estream = stderr;

    /* Transaction callbacks */
    trans.init = t_init;
    trans.trans_lock = t_lock;
    trans.trans_unlock = t_unlock;
    trans.write_start = NULL;
    trans.prepare = t_prepare;
    trans.abort = t_abort;
    trans.commit = t_commit;
    trans.finish = t_finish;


    /* And finallly these are our read/write callbacks for  */
    /* the servers database */
    data.get_elem = get_elem;
    data.get_next = get_next;
    data.set_elem = set_elem;
    data.create   = create;
    data.remove   = dbremove;
    data.exists_optional = exists_optional;
    strcpy(data.callpoint, "aaa");


    /* And these are our candidate and db callbacks */
    /* This code is written inder the assumption that ConfD */
    /* owns the candidate - thus we have no cand cbs */
    dbcbs.add_checkpoint_running = add_checkpoint_running;
    dbcbs.del_checkpoint_running = del_checkpoint_running;
    dbcbs.activate_checkpoint_running = activate_checkpoint_running;
    if (use_startup) {
        dbcbs.copy_running_to_startup = copy_running_to_startup;
        dbcbs.running_chk_not_modified = running_chk_not_modified;
    }

    /* Init library  */
    confd_init("aaa", estream, debuglevel);

    /* Initialize daemon context */
    if ((dctx = confd_init_daemon("aaa")) == NULL)
        fatal(LIBERR, "Failed to initialize confd\n");

    if ((ctlsock = socket(PF_INET, SOCK_STREAM, 0)) < 0 )
        fatal(SYSERR, "Failed to open ctlsocket\n");

    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_family = AF_INET;
    addr.sin_port = htons(CONFD_PORT);

    /* Init data model in library */
    if (confd_load_schemas((struct sockaddr *)&addr, sizeof(addr)) != CONFD_OK)
        fatal(CONNECTERR, "Failed to confd_load_schemas() from confd \n");
    cmd_ops_type = confd_find_ns_type(aaa__ns, "cmdOperationType");
    data_ops_type = confd_find_ns_type(aaa__ns, "dataOperationType");

    /* Create the first control socket, all requests to */
    /* create new transactions arrive here */

    if (confd_connect(dctx, ctlsock, CONTROL_SOCKET, (struct sockaddr*)&addr,
                      sizeof (struct sockaddr_in)) < 0)
        fatal(CONNECTERR, "Failed to confd_connect() to confd \n");


    /* Also establish a workersocket, this is the most simple */
    /* case where we have just one ctlsock and one workersock */

    if ((workersock = socket(PF_INET, SOCK_STREAM, 0)) < 0 )
        fatal(SYSERR, "Failed to create workersocket\n");
    if (confd_connect(dctx, workersock, WORKER_SOCKET,(struct sockaddr*)&addr,
                      sizeof (struct sockaddr_in)) < 0)
        fatal(CONNECTERR, "Failed to confd_connect() to confd \n");


    confd_register_trans_cb(dctx, &trans);
    confd_register_db_cb(dctx, &dbcbs);

    /* we also need to register our read/write callbacks */

    if (confd_register_data_cb(dctx, &data) == CONFD_ERR)
        fatal(LIBERR, "Failed to register data cb \n");

    if (confd_register_done(dctx) != CONFD_OK)
        fatal(LIBERR, "Failed to complete registration \n");

    /* Initialize our data structures */
    init_db();

    while (1) {
        struct pollfd set[3];
        int ret;

        /* Always read stdin */
        set[0].fd = 0;
        set[0].events = POLLIN;
        set[0].revents = 0;

        set[1].fd = ctlsock;
        set[1].events = POLLIN;
        set[1].revents = 0;

        set[2].fd = workersock;
        set[2].events = POLLIN;
        set[2].revents = 0;

        if (poll(&set[0], 3, -1) < 0) {
            perror("Poll failed:");
            continue;
        }

        /* Check for I/O */
        if (set[0].revents & POLLIN) {
            if (interactive) {
                char buf[BUFSIZ];
                fgets(buf, BUFSIZ, stdin);  /* clear fd */
                fpsave(stderr);
            }
            else {
                fatal(NORMAL, "EOF on stdin\n");
            }
        }
        else if (set[1].revents & POLLIN) {
            if ((ret = confd_fd_ready(dctx, ctlsock)) == CONFD_EOF) {
                fatal(NORMAL, "EOF on Control socket\n");
            } else if (ret == CONFD_ERR && confd_errno != CONFD_ERR_EXTERNAL) {
                fatal(LIBERR, "Error on Control socket request\n");
            }
        }
        else if (set[2].revents & POLLIN) {
            if ((ret = confd_fd_ready(dctx, workersock)) == CONFD_EOF) {
                fatal(NORMAL, "EOF on Worker socket\n");
            } else if (ret == CONFD_ERR && confd_errno != CONFD_ERR_EXTERNAL) {
                fatal(LIBERR, "Error on Worker socket request\n");
            }
        }

    }
}



